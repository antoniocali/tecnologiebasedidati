#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Tecnologie delle Basi di Dati M
\end_layout

\begin_layout Author
Antonio Davide Calì
\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset href
LatexCommand href
name "WWW.ANTONIOCALI.COM"
target "http://www.antoniocali.com"

\end_inset


\begin_inset Newline newline
\end_inset

Anno Accademico 2013/2014
\begin_inset Newline newline
\end_inset

Professori: Marco Patella, Paolo Ciaccia
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
Strutture di Indicizzazione
\end_layout

\begin_layout Standard
Nel capitolo precedente abbiamo introdotto l'organizzazione delle pagine
 (e record) attraverso file, le quali indubbiamente portano alcuni vantaggi
 quali inserimenti molto veloci (nel caso di 
\emph on
heap file) 
\emph default
e ricerche mediamente rapide per quasi tutte le operazioni (in caso di 
\emph on
sequential file
\emph default
).
 Entrambe però hanno alcuni svantaggi, infatti la ricerca negli 
\emph on
heap file
\emph default
 risulta molto lenta, mentre la ricerca sui 
\emph on
sequential file
\emph default
 risulta efficiente solo se è effettuata sull'attributo di ordinamento (che
 richiede inoltre periodiche riorganizzazioni).
\end_layout

\begin_layout Standard
Si può dunque far di meglio?
\end_layout

\begin_layout Section
Strutture di indicizzazione
\end_layout

\begin_layout Standard
Le strutture di indicizzazione sono strutture 
\emph on
ausiliarie 
\emph default
che permettono di recuperare velocemente i 
\series bold
RID
\series default
 (Record ID) dei crecord che soddisfano una certa condizione.
 Ogni 
\series bold
indice
\series default
 facilita la ricerca di una diversa condizione (
\emph on
chiave di ricerca
\emph default
)
\emph on
 
\emph default
ed è (sostanzialmente) formato da una collezione di coppie 
\emph on
<chiave,RID> 
\emph default
detta 
\series bold
entry
\series default
.
 Lo scopo dell'indicie è quello di velocizzare il recupero delle 
\emph on
entry 
\emph default
il cui valore della chiave soddisfa la condizione.
 Il vantaggio introdotto dagli 
\emph on
indici
\emph default
 è dovuto alla grandezza ridotta delle 
\emph on
entry
\emph default
 rispetto alla grandezza maggiore dei 
\emph on
record
\emph default
, questo permetterà dunque di organizzare gli indici su disco in maniera
 
\begin_inset Quotes eld
\end_inset

furba
\begin_inset Quotes erd
\end_inset

 per riuscire ad accedere ad essi in modo sequenziale.
 I dati vengono comunque memorizzati come già visto precedentemente (
\emph on
heap/sequential file
\emph default
).
 
\end_layout

\begin_layout Standard
Gli indici sono indubbiamente strutture molto comode, e ci si potrebbe chiedere
 perchè non applicarli a tutti gli attributi di tutte le relazioni.
 Mantenere gli indici ha un costo elevato in termini di prestazioni, in
 quanto ad ogni modifica/aggiunta/rimozione di un 
\emph on
record
\emph default
 in una tabella, bisogna aggiornare tutti gli indici relativi.
 Bisogna inoltre ricordare che per quanto la grandezza degli indici sia
 molto inferiore a quella delle relazioni, essi comunque occupano spazio
 su disco.
 Non è dunque pensabile di mantenere un indice per ogni attributo ed è infatti
 compito dell'
\emph on
amministratore
\emph default
 del database decidere per quali attributi creare gli indici.
 
\end_layout

\begin_layout Standard
La costruzione di indici su una relazione (tabella) serve per dare modalità
 alternative, chiamate 
\series bold
cammini di accesso
\series default
, per localizzare e accedere velocemente ai dati di interesse.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:camminoaccessopreview"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/Antonio/Google Drive/Lyx/Base Di Dati/INDICIZZAZIONE/camminiaccessopreview.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:camminoaccessopreview"

\end_inset

) vengono mostrati effettivamente due possibili cammini di accesso, il primo
 attraverso un albero e il secondo attraverso una funzione hash (li vedremo
 entrambi più avanti).
\end_layout

\begin_layout Standard
Si usa comunemente il termine (valore di) 
\series bold
chiave
\series default
 (di ricerca) per indicare il valore di un campo usato per la selezione
 dei record (Esempio.
 B è una chiave).
\end_layout

\begin_layout Section
Indici
\end_layout

\begin_layout Standard
Quale è il principio di base degli indici?
\end_layout

\begin_layout Standard
Sostanzialmente un indice è visto come un 
\emph on
insieme di coppie 
\emph default
(
\series bold
entry
\series default
) del tipo 
\series bold
(k
\begin_inset script subscript

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset

,p
\begin_inset script subscript

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset

) 
\series default
dove:
\end_layout

\begin_layout Itemize

\series bold
k
\begin_inset script subscript

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset


\series default
 è un 
\emph on
valore di chiave
\emph default
 del campo su cui l'indice è costruito
\end_layout

\begin_layout Itemize

\series bold
p
\begin_inset script subscript

\begin_layout Plain Layout

\series bold
i
\series default
 
\end_layout

\end_inset


\series default
è un 
\emph on
puntatore ai record
\emph default
 (eventualmente uno solo se l'unico) con il valore di chiave k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

(nei 
\emph on
dbms
\emph default
 è quindi il 
\series bold
RID 
\series default
o al limite un 
\series bold
PID
\series default
).
\end_layout

\begin_layout Standard
La entry è dunque formata da una coppia <chiave,RID> è fatta da un valore
 presente nell'attributo per il quale stiamo creando l'indice (chiave) e
 da uno o più RID poichè è possibile che ci siano più 
\emph on
record
\emph default
 che abbiano lo stesso valore dell'attributo per il quale l'indice viene
 creato (chiave).
\end_layout

\begin_layout Standard
Il vantaggio di usare un indice nasce dal fatto che la chiave è solo parte
 dell'informazione contenuta in un record, pertanto 
\emph on
l'indice occupa uno spazio molto minore rispetto al file dati
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempioindice"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempioindice.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
I diversi indici differiscono essenzialmente nel modo con cui vengono organizzat
e le coppie 
\series bold
(k
\begin_inset script subscript

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset

,p
\begin_inset script subscript

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset

) 
\series default
.
\end_layout

\begin_layout Standard
Si consideri ora un indce su chiave primaria usato per ricercare il record
 con chiave k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

.
 Lo schema generale per accedere è dato da:
\end_layout

\begin_layout Enumerate
Accede all'indice
\end_layout

\begin_layout Enumerate
Cercare la coppia (k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

,p
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

)
\end_layout

\begin_layout Enumerate
Accedere alla pagina contenente i dati di interesse
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename schemaindice.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Tipi di Indici
\end_layout

\begin_layout Standard
Esistono diverse tipologie di 
\emph on
indici
\emph default
.
 Una prima distinzione la si ha tra:
\end_layout

\begin_layout Itemize

\series bold
Indici ordinati
\series default
: i valori di chiave k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 vengono mantenuti ordinati in modo da poter essere reperiti più efficientemente
 attraverso una ricerca binaria (di contro devo appunto mantenere ordinato
 l'indice).
\end_layout

\begin_layout Itemize

\series bold
Indici hash
\series default
: si usa una funzione hash per determina la posizione dei valori di chiave
 k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

.
 Il vantaggio lo si trova in una 
\emph on
ricerca per chiave 
\emph default
in quanto con una sola operazione ottengo direttamente il 
\series bold
RID
\series default
, di contro però forniscono pessime prestazioni nelle 
\emph on
ricerche per intervallo
\emph default
 poichè la funzione hash memorizza due valori molto vicini (esempio: case
 e casi) in ordine completamente sparso, dunque per accedervi devo effettivament
e chiamare h(case) e h(casi).
 
\emph on
h denota la funzione hash
\emph default
.
\end_layout

\begin_layout Subsubsection
Nomenclatura
\end_layout

\begin_layout Standard
La 
\emph on
terminologia
\emph default
 che andremo ad introdurre 
\series bold
non
\series default
 è standard anche se è la più diffusa (infatti alcuni non fanno distinzione
 fra i primary/clustered e secondary/unclustered).
\end_layout

\begin_layout Itemize

\series bold
Clustered vs unclustered
\end_layout

\begin_layout Itemize

\series bold
Primary vs secondary
\end_layout

\begin_layout Itemize

\series bold
Single-level vs multi-level
\end_layout

\begin_layout Itemize

\series bold
Dense vs sparse
\end_layout

\begin_layout Paragraph
Clustered e Unclustered
\end_layout

\begin_layout Standard
Un indice è detto 
\series bold
clustered
\series default
 se è costrutito sul campo su cui i 
\emph on
record
\emph default
 nel file dati sono mantenuti ordinati (cioè se l'ordinamento dei 
\emph on
record
\emph default
 sul file e dell'indice è lo stesso).
 L'indice è detto 
\series bold
unclustered
\series default
 altrimenti.
\end_layout

\begin_layout Standard
Ovviamente si può costruire al massimo un indice clustered per relazione
 (poichè il file può essere ordinato solo in un modo e solo un indice può
 essere costruito ottenendo lo stesso ordinamento), mentre possono essere
 costrutiti un numero arbitrario di indici unclustered.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename clusteredindex.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nonostante l'ordinamento dei 
\emph on
record
\emph default
 dei file dati e dell'
\emph on
indice
\emph default
 risulti uguale negli indici 
\series bold
clustered
\series default
, essi ricoprono un ruolo essenziale dovuti al fatto che la loro dimensione
 risulta essere molto ridotta rispetto al file dati.
\end_layout

\begin_layout Paragraph
Primary e Secondary
\end_layout

\begin_layout Standard
Un indice è detto 
\series bold
primary
\series default
 (primario) se è costruito su un campo a valori non ripetuti (chiave candidata,
 attributo 
\emph on
UNIQUE
\emph default
) e dunque ad ogni valore di chiave è associato un solo RID.
 L'indice è detto 
\series bold
secondary
\series default
 altrimenti e dunque sono possibili più RID per un unico valore di chiave.
\end_layout

\begin_layout Standard
In figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:primaryindex"

\end_inset

) si supponga attributo B come attributo UNIQUE.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:primaryindex"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename primaryindex.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Negli indici 
\series bold
secondary
\series default
 per evitare di replicare inutilmente valori di chiave, la soluzione più
 comunemente adottata consiste nel 
\emph on
raggruppare tutte le coppie con lo stesso valore di chiave in una lista
 di puntatori
\emph default
 (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:primaryindexbis"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:primaryindexbis"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename primaryindexbis.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Dense e Sparse
\end_layout

\begin_layout Standard
Un indice si dice 
\series bold
dense
\series default
 (denso) se il numero di entry dell'indice è pari al numero di 
\emph on
record
\emph default
 del file dati.
 L'indice si disce 
\series bold
sparse
\series default
 (sparso) in caso il numero di entry risulti minore (tipicamente uno per
 pagina dati).
 L'indice sparso è una 
\emph on
soluzione applicabile con indici clustered, 
\emph default
e il vantaggio evidente risulta essere la dimensione sempre più ridotta
 dell'indice stesso.
 Lo svantaggio da pagare è presente in caso dell'assenza di un determinato
 valore di chiave.
 Si veda l'esempio in figura (Fig.
 ), se si vuole cercare la chiave 
\series bold
25
\series default
 (non presente), con un indice sparso sono obbligato a leggere l'intera
 pagina associata all'indice 
\series bold
10
\series default
 per accorgermi che l'entry 
\series bold
25
\series default
 non esiste.
 Invece se l'indice fosse stato denso, ci si accorgeva subito (senza dover
 leggere la pagina) che il valore non era presente.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:denseindex"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename denseindex.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Single-level e Multi-level
\end_layout

\begin_layout Standard
Un indice si dice 
\series bold
single-level
\series default
 se esso indicizza direttamente un 
\emph on
file dati
\emph default
.
 È tuttavia possibile 
\begin_inset Quotes eld
\end_inset

indicizzare indici
\begin_inset Quotes erd
\end_inset

 creando dunque una 
\series bold
struttura multi-livello (albero)
\series default
 utilizzando indici 
\emph on
sparsi
\emph default
 (altrimenti creerei indici identici).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:multilvindex"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename indexmultilv.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
N.B.
 Il primo livello è l'indice che indicizza indici, il secondo livello è
 l'indice che indicizza il 
\emph on
file dati (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:multilvindex"

\end_inset


\emph default
).
\end_layout

\begin_layout Standard
Per ragioni di efficienza solitamente gli indici sono 
\series bold
multi-livello
\series default
 (alberi), poichè, ad esempio, se continuo ad indicizzare indici fino a
 che non mi ritrovo ad avere un indice con una sola entry ho costruito esattamen
te un albero.
 In questo caso posso utilizzare la 
\emph on
ricerca binaria
\emph default
 applicata ad un albero piuttosto che la 
\emph on
ricerca binaria
\emph default
 applicata ai 
\emph on
file dati
\emph default
.
 Ad ogni livello di indice si legge una sola pagina, dunque se si hanno
 5 indici si leggono solo 5 pagine.
\end_layout

\begin_layout Subsubsection
Creazione Indici SQL
\end_layout

\begin_layout Standard
In SQL la definizione di indici avvine mediante lo statemente CREATE INDEX
 (non standardizzato).
\end_layout

\begin_layout Standard
Alcuni esempi in DB2:
\end_layout

\begin_layout Itemize

\family typewriter
CREATE INDEX VotoIDX ON Esami(Voto DESC) 
\family default
crea un indice di nome 
\bar under
VotoIDX
\bar default
 applicandolo all'attributo 
\bar under
Voto
\bar default
 della tabella 
\bar under
Esami
\bar default
 (la specifica DESC per dire che voglio ordinarlo in maniera discendente,
 ASC è la specifica di default).
 Essendo 
\bar under
Voto
\bar default
 un attributo non UNIQUE l'indice sarà 
\emph on
unclustered
\end_layout

\begin_layout Itemize

\family typewriter
CREATE UNIQUE INDEX MatrIDX ON Studenti(Matricola) 
\family default
crea un indice 
\bar under
MatrIDX
\bar default
 su attributo 
\bar under
Matricola
\bar default
 della tabella 
\bar under
Studenti
\bar default
.
 La specifica 
\emph on
UNIQUE 
\emph default
è facoltativa, il sistema si accorge automaticamente di star lavorando su
 attributi chiave.
 L'indice è di tipo 
\emph on
clustered
\emph default
.
 NB Non è possibile specificare UNIQUE su un indice applicato a un attributo
 che UNIQUE non è.
\end_layout

\begin_layout Itemize

\family typewriter
CREATE INDEX VotoIDX ON Esami(Voto DESC) CLUSTER
\family default
 crea un indice uguale al primo indicato.
 Aggiungendo però la specifica CLUSTER obbligherà il sistema a ordinare
 la 
\series bold
tabella
\series default
 
\bar under
Esami
\bar default
 sull'attributo 
\bar under
Voto
\bar default
 in maniera discendente.
 Ogni volta che viene aggiunta la specifica CLUSTER a un indice, il sistema
 riordina la tabella associata, 
\begin_inset Quotes eld
\end_inset

declusterizzando
\begin_inset Quotes erd
\end_inset

 i precedenti indici che erano stati segnati CLUSTER (vengono 
\begin_inset Quotes eld
\end_inset

declusterizzati
\begin_inset Quotes erd
\end_inset

 nel senso che l'indice automaticamente non rispecchierà più l'ordine del
 file).
\end_layout

\begin_layout Itemize

\family typewriter
CREATE INDEX Anagrafica ON Persone(Cognome,Nome)
\family default
 crea un indice multi-attributo (ordinato quindi per cognome-nome).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alcuni esempi
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempio1.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempio2.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
B-Tree
\end_layout

\begin_layout Standard
Ci si potrebbe chiedere se possiamo 
\begin_inset Quotes eld
\end_inset

adattare
\begin_inset Quotes erd
\end_inset

 alla memoria secondaria gli alberi di ricerca pensati per la memoria centrale.
\end_layout

\begin_layout Standard
Purtroppo questo non è possibile in quanto sono richiesti alcuni requisiti
 che in memoria secondaria non vengono rispettati:
\end_layout

\begin_layout Itemize
Bilanciamento (prestazioni nel caso peggiore).
\end_layout

\begin_layout Itemize
Paginazione (letture da disco).
 Il problema fulcro riguarda il rispetto di questo requisito in quanto gli
 
\emph on
indici
\emph default
 devono essere paginati, e non è facile spostare poi gli indici da memoria
 principale a memoria secondaria e viceversa.
\end_layout

\begin_layout Itemize
Utilizzazione minima delle pagine (dimensioni).
 Bisogna evitare di creare spazio inutilizzato.
\end_layout

\begin_layout Itemize
Effiencienza in aggiormento
\end_layout

\begin_layout Standard
Solitamente infatti, in memoria centrale, gli alberi sono tipicamente binari
 (
\emph on
AVL tree, red-black tre
\emph default
), il cui numero di nodi è molto alto (e dunque la visita richiede molti
 accessi) i quali vengono inclusi all'interno di una pagina (ad esempio
 7 nodi per pagina).
 Se come costo dell'algoritmo prendessi la visita di un nodo, avere molti
 nodi implicherebbe un costo eccessivo.
 Una buona soluzione sarebbe quindi quella di avere un numero di nodi non
 proporzionale al numero di tuple (
\emph on
record
\emph default
) ma bensì al numero di 
\emph on
pagine
\emph default
.

\emph on
 
\emph default
Ricordiamo che il nostro scopo è riuscire a paginare in maniera efficiente
 gli alberi per la costruzione di indici.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:7nodi"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 7nodi.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Con un tale schema di albero binario purtroppo si crea in efficienza, in
 quanto si creano complicazioni sull'algoritmo di bilanciamento e inoltre
 non viene data alcuna garanzia di avere occupazione minima delle pagine.
 Bisogna quindi trovare una soluzione specifica.
\end_layout

\begin_layout Subsubsection
Definizione B-Tree
\end_layout

\begin_layout Standard
Ci serve dunque una struttura dati ad albero che mantenga i 
\emph on
dati ordinati
\emph default
 e i 
\emph on
nodi bilanciati
\emph default
 permettendo operazioni di inserimento, cancellazione e ricerca in 
\emph on
tempo ammortizzati logaritmicamente
\emph default
.
\end_layout

\begin_layout Standard
Un 
\series bold
B-tree
\series default
 è un 
\emph on
albero a più vie perfettamente bilanciato organizzato a nodi che corrispondono
 a pagine
\emph default
.
 Dire che l'albero sia 
\emph on
a più vie
\emph default
 significa che il fattore di diramazione è
\begin_inset Formula $\geq2$
\end_inset

, mentre dire che sia 
\emph on
perfettamente bilanciato
\emph default
 implica che 
\emph on
il percorso dalla radice ad una qualsiasi foglia ha la stessa lunghezza
\emph default
 (altezza dell'albero).
 Ogni nodo contiene un numero di 
\emph on
entry
\emph default
 
\series bold
m
\series default
 che può variare tra 
\series bold
d 
\series default
e 
\series bold
2d
\series default
 
\begin_inset Formula $d\leq m\leq2d$
\end_inset

 (
\series bold
d=
\emph on
ordine
\series default
\emph default
 dell'albero), cioè in ogni nodo sono memorizzate più di una 
\emph on
entry
\emph default
 (il numero di nodi non è più proporzionale al numero di tuple).
\end_layout

\begin_layout Standard
Il numero di nodi figli di un nodo è pari a 
\series bold
m+1
\series default
 (può dunque variare tra 
\series bold
d+1
\series default
 e 
\series bold
2d+1
\series default
).
 Questo implica un 
\emph on
fan-out
\emph default
 elevato e quindi altezza limitata, un costo di ricerca (molto) basso e
 dimensioni ridotte.
 Il costo per accedere a una foglia è sempre pari all'
\emph on
altezza
\emph default
 dell'albero.
\end_layout

\begin_layout Standard

\series bold
NB.

\series default
 La radice è l'unico nodo che può violare il vincolo di minima utilizzazione
 e avere anche una sola 
\emph on
entry
\emph default
 (dunque per la radice il numero 
\series bold
m
\series default
 è compreso tra 
\begin_inset Formula $1\leq m\leq2d$
\end_inset

).
\end_layout

\begin_layout Standard
Ogni ricerca 
\emph on
segue un unico percorso dalla radice ad una foglia
\emph default
 (
\begin_inset Formula $costo\leq altezza$
\end_inset

 quindi operazioni ammortizate logaritmicamente).
 Il 
\emph on
bilanciamento
\emph default
 è garantito dalle operazione di 
\series bold
inserimento
\series default
 e 
\series bold
cancellazione
\series default
 dei record (la 
\begin_inset Quotes eld
\end_inset

chiave
\begin_inset Quotes erd
\end_inset

 per mantenere l'albero bilanciato risiede nel fatto che il numero di 
\emph on
figli
\emph default
 è variabile), dunque le operazioni di diramazione di un nodo avvengo verso
 l'alto e non verso il basso (cioè in caso di sbilanciamento, una foglia
 può essere portata ad essere un figlio alternativo del nodo 
\emph on
antenato
\emph default
).
 L'occupazione minima è del 50% (ad eccezione della radice), mentre l'occupazion
e tipica è 
\begin_inset Formula $>66\%$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Formato dei nodi 
\end_layout

\begin_layout Standard
Il formato dei nodi differisce a seconda che il nodo sia 
\emph on
interno
\emph default
 o sia una 
\emph on
foglia
\emph default
.
\end_layout

\begin_layout Paragraph
Nodi Interni
\end_layout

\begin_layout Standard
I nodi interni hanno il formato mostrato in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:nodinterni"

\end_inset

) in cui 
\begin_inset Formula $k{\scriptscriptstyle 1}<k{\scriptscriptstyle 2}<\ldots<k{\scriptscriptstyle m}$
\end_inset

 .
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:nodinterni"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename nodiinterni.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si evince dalla figura i nodi interni sono dunque composti sia da 
\series bold
entry
\series default
 (k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

,r
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

) sia da 
\emph on
puntatori
\emph default
 ai nodi 
\emph on
figli
\emph default
.
\end_layout

\begin_layout Paragraph
Foglie
\end_layout

\begin_layout Standard
Le foglie hanno un formato (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:foglie"

\end_inset

) simile a quello dei nodi interni in cui 
\begin_inset Formula $k{\scriptscriptstyle 1}<k{\scriptscriptstyle 2}<\ldots<k{\scriptscriptstyle m}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:foglie"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename foglie.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vista la mancanza dei puntatori ai 
\emph on
sotto-alberi
\emph default
 tipicamente le foglie contengono più entry dei nodi interni.
\end_layout

\begin_layout Subsubsection
Algoritmo di Ricerca
\end_layout

\begin_layout Standard
L'algoritmo di ricerca in un 
\series bold
B-tree
\series default
 è relativamente semplice ma altrettanto efficace.
\end_layout

\begin_layout Enumerate
Si parte dalla radice dell'albero (generalmente le radici di tutti i 
\emph on
b-tree
\emph default
 sono mantenute in memoria centrale per questioni di efficienza).
\end_layout

\begin_layout Enumerate
Si cerca la chiave k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 tra quelle del nodo corrente
\end_layout

\begin_deeper
\begin_layout Itemize
Se è presente: fine (Result: 
\series bold
trovato
\series default
)
\end_layout

\begin_layout Itemize
Se non è presente e siamo in una 
\emph on
foglia
\emph default
: fine (Result: 
\series bold
non trovato
\series default
)
\end_layout

\begin_layout Itemize
Se non è presente e siamo in un nodo interno, sostituisci il nodo corrente
 in memoria con il i-esimo nodo figlio dove 
\begin_inset Formula $k{\scriptscriptstyle i-1}<k<k{\scriptscriptstyle i}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Esempio
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esricercabtree"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempioricercabtree.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cerchiamo la chiave k=40
\end_layout

\begin_layout Enumerate
40<100 
\begin_inset Formula $\Rightarrow$
\end_inset

seguiamo il figlio sinistro
\end_layout

\begin_layout Enumerate
40>30 
\begin_inset Formula $\Rightarrow$
\end_inset

seguiamo il figlio destro
\end_layout

\begin_layout Enumerate
40 è presente nelle entry del nodo corrente: fine (Result: 
\series bold
trovato
\series default
)
\end_layout

\begin_layout Paragraph
Costo della ricerca
\end_layout

\begin_layout Standard
Ogni nodo caricato in memoria viene sostituito (in caso) da un unico figlio
 (dunque l'occupazione in memoria è ottima).
 Nel caso peggiore bisogna arrivare ad una foglia.
 Il costo è comunque sempre minore uguale all'altezza dell'albero: 
\begin_inset Formula $costo\leq altezza\, dell'albero-1+1$
\end_inset

 dove
\end_layout

\begin_layout Itemize
-1 poichè la radice è già pre-caricata in memoria centrale
\end_layout

\begin_layout Itemize
+1 perchè una volta trovata l'
\series bold
entry
\series default
 bisogna accedere al 
\emph on
file dati
\emph default
 (potrebbe essere non necessario se l'indice invece che contenere le 
\series bold
entry
\series default
 contenesse direttamente il 
\emph on
file dati
\emph default
).
\end_layout

\begin_layout Standard
Ne consegue che per sapere il costo della ricerca 
\emph on
occorre saper calcolare l'altezza di un B-tree
\emph default
 di ordine 
\series bold
d
\series default
.
\end_layout

\begin_layout Subsubsection
Numero nodi di un B-tree
\end_layout

\begin_layout Standard
Il numero dei nodi (
\series bold
b
\series default
)
\series bold
 
\series default
presenti in un B-tree varia, ovviamente, tra in un intervallo compreso fra
 
\begin_inset Formula $b{\scriptscriptstyle min}\leq b\leq b{\scriptscriptstyle max}$
\end_inset

.
 Non ci resta dunque che calcolare b
\begin_inset script subscript

\begin_layout Plain Layout
min
\end_layout

\end_inset

 e b
\begin_inset script subscript

\begin_layout Plain Layout
max
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Numero Minimo di Nodi
\end_layout

\begin_layout Standard
Il numero minimo di nodi si ha quando tutti i nodi (ad eccezione della 
\emph on
radice
\emph default
) sono pieni a metà, ovvero 
\begin_inset Formula $m=d$
\end_inset

 (numero di entry uguale all'ordine dell'albero) e quando la radice ha esattamen
te una sola 
\emph on
entry 
\emph default
(il che vuol dire che ha due soli nodi figli).
\end_layout

\begin_layout Standard
Ogni nodo interno ha quindi 
\series bold
d+1
\series default
 figli e dunque il numero di nodi è dato da
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
b_{min}=1+2\sum_{I=0}^{h-2}(d+1)^{I}=1+2\frac{(d+1)^{h-1}-1}{d}
\]

\end_inset


\end_layout

\begin_layout Standard
e il corrispondente numero di 
\emph on
entry
\emph default
 è dunque di
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
N_{min}=1+d\cdot(b_{min}-1)=2(d+1)^{h-1}-1
\]

\end_inset


\end_layout

\begin_layout Paragraph
Numero Massimo di nodi
\end_layout

\begin_layout Standard
Il numero massimo di nodi si ha quando tutti i nodi sono pieni (compresa
 la radice) ovvero 
\begin_inset Formula $m=2d$
\end_inset

 (numero di entry uguale a 2d).
\end_layout

\begin_layout Standard
Ogni nodo interno ha quindi 
\series bold
2d+1
\series default
 
\emph on
figli
\emph default
 e dunque il numero di nodi è dato da
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
b_{max}=\sum_{I=0}^{h-1}(2d+1)^{I}=\frac{(2d+1)^{h}-1}{2d}
\]

\end_inset


\end_layout

\begin_layout Standard
e il corrispondente numero di 
\emph on
entry 
\emph default
è dunque di
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
N_{max}=2d\cdot b_{max}=(2d+1)^{h}-1
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Altezza B-tree
\end_layout

\begin_layout Standard
Dato il numero di 
\emph on
entry 
\emph default
N (numero noto) è possibile dunque calcolare l'altezza del 
\series bold
B-tree
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
N_{min}\leq N\leq N_{max}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
2(d+1)^{h-1}-1\leq N\leq(2d+1)^{h}-1
\]

\end_inset


\end_layout

\begin_layout Standard
e passando ai logaritmi si ha
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left\lceil \log_{2d+1}(N+1)\right\rceil \leq h\leq\left\lfloor \log_{d+1}(\frac{N+1}{2})\right\rfloor +1
\]

\end_inset


\end_layout

\begin_layout Paragraph
Esempio
\end_layout

\begin_layout Standard
Supponiamo di avere le seguenti dimensioni:
\end_layout

\begin_layout Itemize
Chiave k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

: 8byte
\end_layout

\begin_layout Itemize
RID: 4byte
\end_layout

\begin_layout Itemize
entry (k+RID): 8+4=12byte
\end_layout

\begin_layout Itemize
PID: 2byte
\end_layout

\begin_layout Itemize
Pagina p: 4096byte
\end_layout

\begin_layout Standard
Si ottengono i seguenti risultati.
\end_layout

\begin_layout Standard
\begin_inset Formula $entry\cdot2d+PID\cdot(2d+1)=12\cdot2d+2\cdot(2d+1)=4096$
\end_inset

 voglio calcolare quante entry 
\series bold
d
\series default
 ci stanno in ogni nodo (nel tentativo di riempirlo completamente 
\emph on
2d
\emph default
), considerando che siamo in un nodo interno, formato dunque da 
\series bold
entry
\series default
 e 
\series bold
puntatori
\series default
 ai nodi 
\emph on
figli
\emph default
.
 Dunque 12*2d indica il numero di entry all'interno del nodo, 2*(2d+1) il
 numero dei puntatori ai figli (ricorda che un nodo di 
\emph on
m entry 
\emph default
ha 
\emph on
m+1
\emph default
 figli).
\end_layout

\begin_layout Standard
\begin_inset Formula $d=\left\lfloor \frac{4096-2}{24+4}\right\rfloor =146$
\end_inset

 posso mettere fino a 146 entry in ogni nodo.
\begin_inset Newline newline
\end_inset

Se ho 
\begin_inset Formula $N=10^{9}$
\end_inset

 la ricerca di un valore di chiave richiede al massimo
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
linebreak
\end_layout

\end_inset

 
\begin_inset Formula $\left\lfloor \log_{147}\frac{10^{9}}{2}\right\rfloor +1=5$
\end_inset

 operazioni di I/O (una ricerca binaria richiederebbe 22 accessi supponendo
 di avere le pagine piene).
\end_layout

\begin_layout Standard
Una considerazione importante è la 
\series bold
variabilità di h (l'altezza)
\series default
.
 Fissati N e d (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:tabellaltezza"

\end_inset

), la differenza tra altezza massima (quindi albero pieno a metà 
\begin_inset Formula $m=d$
\end_inset

) e altezza minima (albero completamente pieno 
\begin_inset Formula $m=2d$
\end_inset

) è molto limitata (di 
\begin_inset Formula $\sim1$
\end_inset

).
 Dunque anche se riempiamo l'albero nel modo peggiore possibile (quindi
 creando altezza massima) si avrebbe solo un nodo in più da visitare.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:tabellaltezza"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename tabellaaltezza.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Ricerca per Intervallo
\end_layout

\begin_layout Standard
Supponiamo attraverso l'esempio in Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esricercabtree"

\end_inset

 di voler cercare le 
\emph on
entry
\emph default
 che hanno un valore di chiave tra 40 e 150.
 Da come si nota dall'immagine bisogna arrivare fino alla 
\emph on
foglia
\emph default
 che contiene 40, a quel punto bisogna fare 
\series bold
backtracking
\series default
 e tornare in cima all'albero, alla radice, prendere la strada alternativa
 e scendere per fino alla foglia per trovare i valori 120 e 130, risalire
 ancora una volta e prendere il valore 150.
 Questo processo causa molta inefficienza poichè, si ricordi, che ogni volta
 che si scende in un nodo figlio, il nodo in memoria viene sostituito da
 esso: dover ritornare indietro causa il dover ricaricare nodi non voluti
 ma necessari per il backtracking.
 Ci si può accorgere che se il buffer fosse abbastanza grande da riuscire
 a caricare più nodi contemporanemanete invece che uno alla volta allora
 l'inefficienza cala, ma non è il modo migliore di operare.
\end_layout

\begin_layout Standard
La ricerca di un intervallo presuppone dunque che partendo dalla radice,
 si visiti l'albero 
\emph on
in ordine
\emph default
, passando più volte attraverso gli stessi nodi a causa del backtracking.
 Il punto focale dell'inefficneza è data dal fatto che le 
\series bold
RID
\series default
 non sono memorizzate solo nelle foglie (poichè se così fosse basterebbe
 sapere le pagine in cui i valori sono memorizzati e non sarebbe necessario
 il backtracking).
\end_layout

\begin_layout Standard
Si può dunque fare di meglio?
\end_layout

\begin_layout Subsection
B
\begin_inset script superscript

\begin_layout Plain Layout
+
\end_layout

\end_inset

-tree 
\end_layout

\begin_layout Standard
In parole povere il 
\series bold
B
\begin_inset script superscript

\begin_layout Plain Layout

\series bold
+
\end_layout

\end_inset

-tree 
\series default
(da ora in avanti abbreviato in B+tree) è un 
\emph on
b-tree
\emph default
 in cui le entry vengono memorizzate solo nelle foglie.
\end_layout

\begin_layout Standard
Le principali caratteristiche sono:
\end_layout

\begin_layout Enumerate
le coppie (k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

,r
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

) sono tutte 
\emph on
contenute nelle foglie.

\emph default
 Questo comporta un'altezza maggiore rispetto al 
\emph on
b-tree
\emph default
 poichè ho bisogno di più foglie per poter memorizzare tutte le 
\emph on
entry
\emph default
.
\end_layout

\begin_layout Enumerate
le foglie sono 
\emph on
collegate a lista
\emph default
 (eventualmente doppia) mediante puntatori (
\series bold
PID
\series default
) per favorire la 
\emph on
ricerca di intervallo
\emph default
 (vedremo più avanti).
\end_layout

\begin_layout Enumerate
i nodi interni 
\emph on
contengono solamente valori delle chiavi
\emph default
 (
\bar under
non necessariamente corrispondi a dati esistenti
\bar default
).
 Questo comporta un aumento della capacità dei nodi interni (non devono
 più memorizzare entry, ma solo valori di chiave 
\emph on
k
\emph default
) e di conseguenza diminuisce l'altezza (rispetto al 
\emph on
b-tree
\emph default
)
\end_layout

\begin_layout Standard
Il secondo punto, oltre a favorire la ricerca di intervallo, ci fa supporre
 di avere, al livello delle foglie, la 
\emph on
lista ordinata delle entry
\emph default
: è come se avessimo 
\emph on
paginato
\emph default
 un indice 
\emph on
single-level
\emph default
 e su questo avessimo creato un indice 
\emph on
multi-level sparse
\emph default
 (e in effetti ogni volta che creo un indice multi-livello sparso sto effettivam
ente creando un B+tree).
\begin_inset Newline newline
\end_inset

Il primo e il terzo punto sembrano in contraddizione, in quanto nel primo
 viene detto che l'albero risulta più alto, mentre nel terzo che l'albero
 risulta più basso.
 Effettivamente aver aumentato il numero delle foglie implica necessariamente
 avere un'altezza maggiore, ma contrapposto a questo, aver permesso ai nodi
 interni di contenere solo valori di chiavi (dunque solo dei 
\emph on
k
\emph default
) e non più 
\emph on
entry 
\emph default
(coppie <k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

,r
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

>) aumenta lo spazio a disposizione dei valori 
\emph on
k
\emph default
 nei nodi interni: ricordando che se le 
\emph on
entry
\emph default
 (in questo caso valori di chiave k) di un nodo sono m il numero di figli
 è m+1, allora si può capire che effettivamente l'albero si riduce in altezza
 poichè il suo 
\emph on
fan-out 
\emph default
è maggiore e questo porta ad avere una larghezza maggiore e dunque una riduzione
 dell'altezza a livello pratico.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Il formato dei nodi interni (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:nodinternibpiu"

\end_inset

) è molto simile a quello del semplice 
\emph on
b-tree 
\emph default
(Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:nodinterni"

\end_inset

) in cui 
\begin_inset Formula $k_{1}<k_{2}<\ldots<k_{m}$
\end_inset

.
 Le differenze riguardano ciò che viene memorizzato all'interno del nodo:
 non più le 
\emph on
entry 
\emph default
(k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

,r
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

) ma solo i valori di chiave k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

, e il fatto che i sotto alberi contengono valori 
\begin_inset Formula $\leq$
\end_inset

 o 
\begin_inset Formula $\geq$
\end_inset

di ki (dovuto al fatto che le 
\emph on
entry
\emph default
 sono memorizzate nelle foglie, quindi i valori k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 devono essere presenti nei sotto alberi).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:nodinternibpiu"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename nodiinternibpiu.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Algoritmi di ricerca
\end_layout

\begin_layout Standard
Introduciamo il funzionamento degli algoritmi di 
\emph on
ricerca per chiave 
\emph default
e di 
\emph on
ricerca di intervallo
\emph default
, facendo riferimento per entrambi gli algoritmi alla figura qui mostrata
 (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ricercabpiu"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:ricercabpiu"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ricercabpiu.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notiamo prima però, come già detto, che le foglie sono collegate una all'altra
 attraverso liste (doppiamente) concatenate.
\end_layout

\begin_layout Paragraph
Ricerca di chiave
\end_layout

\begin_layout Standard
Precisiamo subito che a differenza del 
\emph on
b-tree
\emph default
 in cui la ricerca di chiave aveva 
\begin_inset Formula $costo\leq altezza\, dell'albero$
\end_inset

, nel 
\emph on
B+tree
\emph default
 questo non è più vero, in quanto ora il costo è esattamente uguale all'altezza
 dell'albero 
\begin_inset Formula $costo=altezza\, dell'albero$
\end_inset

 poichè le 
\emph on
entry 
\emph default
si trovano nelle foglie, dunque devo sempre e comunque arrivare all'ultimo
 livello (delle foglie).
\end_layout

\begin_layout Standard
L'algoritmo parte dalla radice (in generale mantenuta in 
\emph on
RAM
\emph default
).
 Si cerca la chiave 
\emph on
k
\emph default
 tra quelle del nodo corrente:
\end_layout

\begin_layout Itemize
Se siamo in un nodo interno sostituisci il nodo corrente con il 
\emph on
i-esimo
\emph default
 nodo figlio in cui 
\begin_inset Formula $k_{i-1}<k\leq k_{i}$
\end_inset


\end_layout

\begin_layout Itemize
Se siamo in una foglia e il valore 
\emph on
k 
\emph default
è presente: 
\emph on
fine
\emph default
 (Result: 
\series bold
trovato
\series default
)
\end_layout

\begin_layout Itemize
Se siamo in una foglia e il valore 
\emph on
k
\emph default
 non è presente: 
\emph on
fine
\emph default
 (Result: 
\series bold
non trovato
\series default
)
\end_layout

\begin_layout Paragraph
Ricerca di intervallo
\end_layout

\begin_layout Standard
Supponiamo di voler cercare nell'intervallo 
\begin_inset Formula $\left[k_{low},k_{high}\right]$
\end_inset

.
 Bisogna effettuare come prima cosa una 
\emph on
ricerca di chiave
\emph default
 del valore k
\begin_inset script subscript

\begin_layout Plain Layout
low
\end_layout

\end_inset

 prendendo il primo valore 
\begin_inset Formula $k\geq k_{low}$
\end_inset

 (poichè non è detto che k
\begin_inset script subscript

\begin_layout Plain Layout
low
\end_layout

\end_inset

 esista).
 Siccome ora le foglie sono collegate a lista (doppiamente) concatenata,
 possiamo evitare di effettuare il 
\series bold
backtracking
\series default
 come avveniva nel 
\emph on
b-tree
\emph default
, poichè basterà 
\emph on
scandire sequenzialmente le foglie
\emph default
 fino a quando non troviamo il primo valore 
\begin_inset Formula $k>k_{high}$
\end_inset

.
 L'insieme di tutti i 
\series bold
RID
\series default
 incontrati danno il risultato della 
\emph on
ricerca di intervallo
\emph default
.
 L'esempio in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ricercabpiu"

\end_inset

) mostra effettivamente una ricerca di intervallo per [30,160].
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Alcune considerazioni: 
\end_layout

\begin_layout Itemize
Dato che le foglie sono collegate logicamente attraverso una lista (doppiamente)
 concatenata, sarebbe possibile utilizzare il 
\emph on
b+tree
\emph default
 per memorizzare direttamente il 
\emph on
file data
\emph default
, quindi al posto di inserire 
\emph on
entry
\emph default
 nelle foglie, potremmo inserire direttamente i 
\emph on
record
\emph default
 (ordinati per un determinato attributo).
 Inoltre la memorizzazione ordinata così fatta crea un indice 
\emph on
clustered
\emph default
.
\end_layout

\begin_layout Itemize
Cosa succede se l'indice è 
\emph on
unclustered 
\emph default
(dunque non è ordinato secondo l'ordine della tabella associata)? Se si
 ricerca per intervallo potrebbe capitare che venga restituito più volte
 uno stesso 
\series bold
PID
\series default
 (ricordiamo che il 
\series bold
RID
\series default
 è formato dalla coppia (PID, slot) quindi RID diversi potrebbero avere
 lo stesso PID): di conseguenza verrà richiesto al 
\emph on
dbms
\emph default
 di caricare in momenti successivi la stessa pagina per poter risolvere
 l'interrogazione.
\end_layout

\begin_layout Itemize
Cosa succede se l'indice è 
\emph on
sparse
\emph default
 (dunque le 
\emph on
entry
\emph default
 sono in numero minore dei 
\emph on
record
\emph default
 della tabella associata)? Un indice 
\emph on
sparso
\emph default
 è spesso e volentieri (se non sempre) anche un indice 
\emph on
primario
\emph default
 (quindi fatto su attributi UNIQUE): in una situazione di questo tipo potrebbe
 dunque essere conveniente memorizzare solamente 
\series bold
PID
\series default
 e non più i 
\series bold
RID
\series default
, poichè una volta caricata la pagina nel buffer, leggere le informazioni
 ha costo che possiamo considerare 0 rispetto a una operazione di I/O.
\end_layout

\begin_layout Subsubsection
Inserimento nel B+tree
\end_layout

\begin_layout Standard
Come si inserisce dunque una nuova 
\emph on
entry
\emph default
 in un 
\emph on
B+tree
\emph default
 (l'algoritmo che vedremo è scalabile, ma più complicato, a un semplice
 
\emph on
b-tree
\emph default
)? Bisogna ricordare che sono le operazioni di 
\emph on
inserimento
\emph default
 e di 
\emph on
cancellazione
\emph default
 che mantengono l'albero 
\emph on
perfettamente bilanciato
\emph default
 e 
\emph on
ordinato
\emph default
.
\end_layout

\begin_layout Standard
Supponiamo di voler inserire una nuova 
\emph on
entry
\emph default
 (k,r).
 La procedura di inserimento procede innanzitutto cercando la foglia in
 cui inserire il nuovo valore di chiave 
\emph on
k
\emph default
.
 Trovata la foglia si distinguono due casi:
\end_layout

\begin_layout Enumerate
Nella foglia c'è posto per la memorizzazione, cioè la foglia contiene meno
 di 2d entry: la nuova coppia (k,r) viene inserita e la procedura termina
\end_layout

\begin_layout Enumerate
Nella foglia non c'è più posto, cioè la foglia contiene già esattamente
 2d entry (foglia in 
\emph on
overflow
\emph default
).
\end_layout

\begin_layout Standard
Analizziamo questo secondo caso che è ovviamente il caso di interesse.
\end_layout

\begin_layout Paragraph
Split di una foglia
\end_layout

\begin_layout Standard
La foglia F in 
\emph on
overflow
\emph default
 viene divisa in due foglie (F
\begin_inset script subscript

\begin_layout Plain Layout
L
\end_layout

\end_inset

 e F
\begin_inset script subscript

\begin_layout Plain Layout
R
\end_layout

\end_inset

).
 Ciascuna foglia conterrà circa (poichè essendo 2d pari e volendo aggiungere
 una nuova entry bisognerà ridistribuire in d e d+1 entry) la metà delle
 
\emph on
entry
\emph default
 di F.
 Viene individuato il valore 
\emph on
mediano
\emph default
 k
\begin_inset script subscript

\begin_layout Plain Layout
c
\end_layout

\end_inset

 delle entry di F (normalmente l'indice c corrisponde all'ordine d 
\begin_inset Formula $c=d$
\end_inset

 - Attenzione: dire 
\begin_inset Formula $k_{c}=d$
\end_inset

 è diverso).
 In F
\begin_inset script subscript

\begin_layout Plain Layout
L
\end_layout

\end_inset

 vanno tutte le entry con 
\begin_inset Formula $k\leq k_{c}$
\end_inset

.
 In F
\begin_inset script subscript

\begin_layout Plain Layout
R
\end_layout

\end_inset

 vanno tutte le entry con chiave 
\begin_inset Formula $k>k_{c}$
\end_inset

.
 Nel nodo padre di F il puntatore a F viene sostituito dai due puntatori
 a F
\begin_inset script subscript

\begin_layout Plain Layout
L
\end_layout

\end_inset

 e F
\begin_inset script subscript

\begin_layout Plain Layout
R
\end_layout

\end_inset

 separati dal valore di k
\begin_inset script subscript

\begin_layout Plain Layout
c
\end_layout

\end_inset

.
 Questa tecnica è chiamata 
\series bold
split
\series default
.
 Si noti che lo 
\emph on
split
\emph default
 di una foglia comporta il passaggio da una foglia completamente piena (
\begin_inset Formula $m=2d$
\end_inset

) a due foglie riempite solo a metà (
\begin_inset Formula $m=d$
\end_inset

)
\end_layout

\begin_layout Standard
Cosa succede se il nodo padre di F non ha spazio per contenere questi nuovi
 dati?
\begin_inset Newline newline
\end_inset

Avviene una 
\series bold
propagazione dello split
\series default
, cioè il nodo padre è un nodo che va in 
\emph on
overflow
\emph default
: si agisce come in precedenza applicando uno 
\emph on
split
\emph default
.
 Ne consegue che lo 
\emph on
split
\emph default
 si propaga 
\bar under
ricorsivamente verso l'alto
\bar default
.
 Il caso limite lo si ha quando anche la radice risulta 
\emph on
piena
\emph default
: si divide dunque la radice in due e si crea un nuovo 
\emph on
nodo radice.
 
\emph default
Effetto: l'albero 
\series bold
cresce in altezza
\series default
.
 
\emph on
Osservazione:
\emph default
 il fatto che la radice può non rispettare il vincolo minimo di occupazione
 è dovuto proprio a questo effetto.
\end_layout

\begin_layout Standard
In figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempiosplit"

\end_inset

) troviamo un esempio di split.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempiosplit"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempioinserimento.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Costo dell'inserimento
\end_layout

\begin_layout Standard
Il costo dell'inserimento è diverso in presenza o in assenza dello 
\emph on
split
\emph default
, infatti ogni split causa 2 scritture in più.
 [Notazione: h=altezza dell'albero]
\end_layout

\begin_layout Standard
Senza split risulta essere: 
\emph on
h
\emph default
 letture (per trovare la foglia in cui inserire l'entry) + 1 scrittura (scrivere
 l'entry) [Senza split: h+1].
\end_layout

\begin_layout Standard
Con split:
\end_layout

\begin_layout Itemize
Nel caso peggiore si effettua la ricorsione fino alla radice: 
\emph on
h 
\emph default
letture (per trovare la foglia in cui inserire l'entry) + (
\emph on
2h+1
\emph default
) scritture (poichè come detto ogni split provoca 2 scritture in più, bisogna
 risalire dalla foglia fino alla radice (distanti h) applicando lo split
 ad ogni livello, e infine il +1 per scrivere effettivamente l'entry) [Caso
 peggiore: h+2h+1]
\end_layout

\begin_layout Itemize
Per il calcolo del caso medio dobbiamo ricordare alcuni fattori: se l'albero
 ha 
\series bold
b
\series default
 nodi, allora vuol dire che ci sono stati 
\series bold
b-1
\series default
 split.
 Dato che il numero minimo di 
\emph on
entry 
\emph default

\begin_inset Formula $N_{min}=1+d\cdot(b-1)\leq N$
\end_inset

 otteniamo che il numero medio di split è 
\begin_inset Formula $\frac{b-1}{N}$
\end_inset

 ovvero di circa 
\begin_inset Formula $\frac{1}{d}$
\end_inset

 (ho uno split ogni 
\emph on
d inserimenti
\emph default
).
 Ho dunque 
\emph on
h
\emph default
 letture e 1 + 
\begin_inset Formula $\frac{2}{d}$
\end_inset

 scritture.
 [Costo medio: 
\begin_inset Formula $\leq h+1+\frac{2}{d}$
\end_inset

]
\end_layout

\begin_layout Standard
Da come si intuisce, per avere pochi 
\emph on
split
\emph default
 conviene avere nodi grandi (così da avere un 
\emph on
d
\emph default
 maggiore) comportando però i soliti problemi di frammentazione interna.
 Inoltre è giusto chiarire che gli 
\emph on
split
\emph default
 difficilmente arrivano a propagarsi alla 
\emph on
radice
\emph default
, mentre sono molto più comuni al livello delle foglie.
\end_layout

\begin_layout Paragraph
Ridistribuzione
\end_layout

\begin_layout Standard
Esiste un'alternativa alla tecnica di 
\emph on
split
\emph default
, la 
\series bold
ridistribuzione
\series default
.
 Invece di effettuare uno split vengono ridistribuite alcune entry ai nodi
 fratelli, cioè nodi vicini figli dello stesso padre, che non sono in 
\emph on
overflow.
 
\emph default
Il tutto è permesso anche dal fatto che le foglie sono collegate tra loro
 attraverso lista doppiamente concatenata.
 Il costo della ridistribuzione rimane uguale a quello di uno 
\emph on
split
\emph default
 perchè comunque modifico 3 nodi: i due nodi foglia fratelli per la ridistribuzi
one delle 
\emph on
entry
\emph default
 e inoltre modifico anche il 
\emph on
padre
\emph default
 poichè è necessario modificare anche il valore mediano k
\begin_inset script subscript

\begin_layout Plain Layout
c
\end_layout

\end_inset

 che separava i due figli fratelli: il vantaggio è dovuto al fatto che a
 differenza dello 
\emph on
split
\emph default
 che può propagarsi al 
\begin_inset Quotes eld
\end_inset

nonno
\begin_inset Quotes erd
\end_inset

, la ridistribuzione si ferma con la modifica del padre.
 Bisogna notare che un nodo ha al massimo due fratelli (si considerano sempre
 e solo nodi vicini figli dello stesso padre): cosa succede però se entrambi
 i fratelli sono completamente pieni e quindi non possono ospitare nuove
 
\emph on
entry
\emph default
? In questo caso bisogna per forza applicare la tecnica dello 
\series bold
split
\series default
.
 In effetti l'utilizzo di entrambe le tecniche porta a buone performance
 e ad avere un albero mediamente 
\begin_inset Quotes eld
\end_inset

più pieno
\begin_inset Quotes erd
\end_inset

 (rispetto ad applicare solo lo 
\emph on
split
\emph default
).
 Infine, tipicamente, il 
\emph on
padre
\emph default
 contiene già le informazioni sullo stato di riempimento dei figli migliorando
 ulteriormente le performance (cosicchè la foglia che chiede la ridistribuzione
 non deve andare ad indagare se uno dei fratelli ha lo spazio necessario
 per accettare 
\emph on
entry
\emph default
).
\end_layout

\begin_layout Subsubsection
Cancellazione nel B+tree
\end_layout

\begin_layout Standard
Supponiamo di voler cancellare una entry (k, r): precisiamo subito, è una
 supposizione un po' forte, in quanto, solitamente, la cancellazione avviene
 per ricerca di chiave k (che potrebbe avere dunque più entry associate),
 di conseguenza (come per altro abbiamo fatto in precedenza) supponiamo
 di essere in un indice 
\emph on
primario 
\emph default
(l'attributo è UNIQUE) in cui indicare la chiave k equivale ad indicare
 anche l'entry (k,r).
\end_layout

\begin_layout Standard
La procedura di cancellazione innanzitutto procede cenrcando la foglia in
 cui si trova il valore di chiave k.
 Trovata la foglia si cancella l'entry relativa distinguendo però due casi:
\end_layout

\begin_layout Enumerate
La foglia contiene non meno 
\emph on
d
\emph default
 entry: la procedura termina (rispetta il vincolo di occupazione minima).
\end_layout

\begin_layout Enumerate
La foglia contiene d-1 entry (foglia in 
\emph on
underflow
\emph default
).
\end_layout

\begin_layout Standard
Analiziamo questo secondo caso che è ovviamente il caso di interesse.
\end_layout

\begin_layout Standard
La gestione dell'
\emph on
underflow
\emph default
 (analogamente all'
\emph on
overflow
\emph default
 nell'inserimento) può essere gestita in due modi: 
\series bold
ridistribuzione
\series default
\emph on
 
\emph default
e 
\series bold
cancellazione
\series default
.
\end_layout

\begin_layout Paragraph
Ridistribuzione
\end_layout

\begin_layout Standard
La ridistribuzione, come avveniva nell'inserimento, consiste nel chiedere
 ai fratelli (nodi vicini di uno stesso padre) almeno una 
\emph on
entry
\emph default
 per riuscire a rispettare il vincolo di occupazione minima.
 Questo è possibile solo se entrambi i fratelli (o l'unico fratello) ha
 almeno 
\emph on
d+1
\emph default
 entry, in caso contrario (
\emph on
d entry
\emph default
) il procedimento non è attuabile in quanto il fratello stesso entrerebbe
 in 
\emph on
overflow
\emph default
.
 In caso di 
\emph on
ridistribuzione
\emph default
 bisogna aggiornare il valore separatore del nodo padre (il valore k
\begin_inset script subscript

\begin_layout Plain Layout
c
\end_layout

\end_inset

 mediano): il numero delle 
\emph on
entry 
\emph default
del padre non varia (sto modificando un valore) e il fenomeno non viene
 propagato verso l'alto.
 In caso però che entrambi i fratelli abbiano esattamente 
\emph on
d entry
\emph default
 e la ridistribuzione non sia possibile, bisogna applicare la 
\emph on
cancellazione.
\end_layout

\begin_layout Paragraph
Cancellazione
\end_layout

\begin_layout Standard
È possibile cancellare la foglia in 
\emph on
underflow 
\emph default
in caso la 
\emph on
ridistribuzione
\emph default
 non sia possibile.
 La cancellazione è possibile solo se la foglia/e sorella/e ha/hanno 
\emph on
d
\emph default
 o 
\emph on
d+1
\emph default
 entry.
 Bisogna notare che se cancello una foglia devo eliminare dal nodo padre
 il puntatore alla foglia stessa e ancora una volta se il nodo padre era
 pieno esattamente per metà, si ritroverebbe a violare il vincolo di occupazione
 minima.
 Da questo si deduce che la 
\emph on
cancellazione
\emph default
 potrebbe 
\emph on
propagarsi verso l'alto
\emph default
 allo stesso modo in cui si propagava lo 
\emph on
split
\emph default
.
 Il caso limite se la 
\emph on
cancellazione 
\emph default
arriva alla radice la quale va in 
\emph on
underflow 
\emph default
(cioè la radice aveva 1 solo figlio): in questo caso viene eliminato il
 nodo radice e il suo unico figlio ne prende il posto.
 Conseguenza: l'albero 
\series bold
si abbassa
\series default
.
\end_layout

\begin_layout Standard
In figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempiocancellazione"

\end_inset

) troviamo un esempio di 
\emph on
cancellazione
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempiocancellazione"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempiocancellazione.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Costo di Cancellazione
\end_layout

\begin_layout Standard
Il costo di 
\emph on
cancellazione
\emph default
 è diverso in caso di presenza o assenza di 
\emph on
underflow
\emph default
, infatti ogni 
\emph on
concatenazione
\emph default
 (dovute a canecllazione) causa 1 lettura e 2 scritture in più.
 [Notazione: h=altezza dell'albero].
\end_layout

\begin_layout Standard
In assenza di 
\emph on
underflow: h
\emph default
 letture (per trovare la foglia in cui si trova l'entry da cancellare) +
 1 scrittura (cancellazione dell'entry) [Senza split: h+1].
\end_layout

\begin_layout Standard
In presenza di 
\emph on
underflow:
\end_layout

\begin_layout Itemize
Nel caso peggiore: la 
\emph on
cancellazione
\emph default
 si propaga fino alla radice, avviene dunque una concatenazione per tutti
 i livelli tranne i primi due con una 
\emph on
ridistribuzione
\emph default
 delle 
\emph on
entry
\emph default
 nel figlio della radice, il costo massimo è di dunque 
\begin_inset Formula $2h-1$
\end_inset

 letture + 
\begin_inset Formula $h+1$
\end_inset

 scritture.
 [Caso peggiore: 2h-1+h+1]
\end_layout

\begin_layout Itemize
Per il calcolo del caso medio ho bisogno di sapere il numero medio di concatenaz
ioni: esso ha fatto di 
\begin_inset Formula $\frac{1}{d}$
\end_inset

, dunque il costo medio è di 
\begin_inset Formula $\leq h+1+\frac{1}{d}$
\end_inset

 letture e 
\begin_inset Formula $1+2+\frac{2}{d}$
\end_inset

 scritture.
 [Caso medio: 
\begin_inset Formula $\leq h+1+\frac{1}{d}+1+2+\frac{2}{d}$
\end_inset

]
\end_layout

\begin_layout Subsubsection
Occupazione di memoria
\end_layout

\begin_layout Standard
Ogni nodo interno contiene al più 
\emph on
2d
\emph default
 valori di chiave k e dunque 
\emph on
2d+1
\emph default
 puntatori ai figli (sottoalberi).
 L'ordine 
\emph on
d
\emph default
 di un 
\emph on
B+tree
\emph default
 è quindi dato da:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d=\left\lfloor \frac{pagesize-PIDsize}{2\cdot(keysize+PIDsize)}\right\rfloor 
\]

\end_inset


\end_layout

\begin_layout Standard
Al numeratore abbiamo dunque la grandezza della 
\emph on
pagina 
\emph default
alla quale sottriamo la grandezza di un 
\emph on
pageheader
\emph default
 (che in questo caso assumiamo essere fatto del solo 
\series bold
PID
\series default
), mentre al denominatore abbiamo due volte la grandezza del valore di chiave
 
\emph on
k
\emph default
 e del 
\series bold
PID
\series default
 (serve per i puntatori ai figli).
\end_layout

\begin_layout Standard
Per sapere il numero di entry che una foglia può contenere bisogna distingue
 il caso in cui l'indice sia 
\emph on
primario
\emph default
 e il caso in cui l'indice sia 
\emph on
secondario
\emph default
.
\end_layout

\begin_layout Paragraph
Indice Primario
\end_layout

\begin_layout Standard
Nel caso l'indice sia primario (e dunque non ci siano valori duplicati)
 in ogni foglia troviamo al più 
\emph on
2d
\emph default
 entry (k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

,r
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

) e 1 o 2 puntatori ai nodi vicini (lista 
\begin_inset Quotes eld
\end_inset

doppiamente
\begin_inset Quotes erd
\end_inset

 concatenata).
 Ne consegue che l'ordine 
\emph on
d 
\emph default
delle foglie sia
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d_{leaf}=\left\lfloor \frac{pagesize-2\cdot PIDsize}{2\cdot(keysize+RIDsize)}\right\rfloor 
\]

\end_inset


\end_layout

\begin_layout Standard
Si noti che in questo caso al denominatore abbiamo il 
\series bold
RID 
\series default
(trattandosi di un entry) e al numeratore abbiamo 
\begin_inset Formula $2\cdot PIDsize$
\end_inset

 perchè supponiamo lista doppiamente concatenata.
\end_layout

\begin_layout Standard
Il numero di foglie risulta dunque essere [N=Numero di 
\emph on
entry
\emph default
]
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
NL=\left\lceil \frac{N}{d_{leaf}\cdot u}\right\rceil 
\]

\end_inset


\end_layout

\begin_layout Standard
dove 
\emph on
u
\emph default
 indica il fattore di occupazione medio che normalmente vale 
\begin_inset Formula $\ln2$
\end_inset

.
\end_layout

\begin_layout Standard
Conoscendo ora il numero delle foglie NL è possibile calcolare l'altezza
 del 
\emph on
B+tree 
\emph default
attraverso i soliti passaggi di calcolo di 
\begin_inset Formula $NL_{min}$
\end_inset

 e 
\begin_inset Formula $NL_{max}$
\end_inset


\begin_inset Formula 
\[
NL_{min}\leq NL\leq NL_{max}
\]

\end_inset


\begin_inset Formula 
\[
2\cdot(d+1)^{h-2}\leq NL\leq(2d+1)^{h-1}
\]

\end_inset


\end_layout

\begin_layout Standard
e passando ai logaritmi si ottiene
\begin_inset Formula 
\[
\left\lceil \log_{2d+1}(NL)\right\rceil +1\leq h\leq\left\lfloor \log_{d+1}(\frac{NL}{2})\right\rfloor +2
\]

\end_inset


\end_layout

\begin_layout Paragraph
Indice Secondario
\end_layout

\begin_layout Standard
In caso di valori duplicati occorre che ogni valore di chiave
\emph on
 k
\emph default
 sia associato non più ad un singolo 
\series bold
RID
\series default
, ma ad una 
\emph on
lista di RID
\emph default
.
 Solitamente la lista è ordinata per valori di PID questo perchè, ricordando
 che il 
\series bold
RID
\series default
 è formato dalla coppia <PID,slot>, non accada che in caso ci siano due
 
\emph on
record
\emph default
 con uguale chiave 
\emph on
k
\emph default
 nella stessa pagina (identificata dal PID) per essere letti entrambi venga
 richiesto il caricamente della pagina due volte in momenti diversi.
 Cosa succede se la 
\emph on
lista di RID
\emph default
 è molto lunga? Caso limite: può capitare che una singola entry abbia dimensioni
 maggiori di una singola pagina.
 Possibili soluzioni:
\end_layout

\begin_layout Itemize
Pagine di 
\emph on
overflow
\emph default
 per la foglia in questione
\end_layout

\begin_layout Itemize

\emph on
Duplicazione 
\emph default
delle chiavi nell'indice
\end_layout

\begin_layout Itemize
Uso di 
\emph on
PID
\emph default
 al posto dei 
\emph on
RID
\end_layout

\begin_layout Itemize
Posting file
\end_layout

\begin_layout Subparagraph
Duplicazione delle chiavi nell'indice
\end_layout

\begin_layout Standard
Invece di mantenere una lista di RID associate a una chiave 
\emph on
k
\emph default
, mantengo ogni entry (k,r) separate, duplicando dunque le entry aventi
 la stessa chiave 
\emph on
k
\emph default
.
 Questa soluzione richiede di modificare leggermente l'algoritmo di ricerca:
 bisogna dunque cercare il 
\emph on
primo
\emph default
 valore uguale alla chiave di ricerca 
\emph on
k
\emph default
, quindi proseguire con la lista delle foglie (ottenendo tutti i RID).
 Inoltre non tutte le foglie sono 
\begin_inset Quotes eld
\end_inset

indirizzate
\begin_inset Quotes erd
\end_inset

, si noti la figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:duplicazionechiavi"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:duplicazionechiavi"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename duplicazionechiavi.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inoltre la soluzione diventa inefficiente in 
\emph on
cancellazione
\emph default
 in quanto per eliminare una 
\emph on
entry
\emph default
 bisogna specificare anche il 
\series bold
RID
\series default
, e non solo la chiave di ricerca 
\emph on
k 
\emph default
(se utilizzassimo sempre la coppia <k,RID> per qualsiasi operazione l'indice
 diventa 
\emph on
primario
\emph default
).
\end_layout

\begin_layout Subparagraph
Utilizzo dei PID
\end_layout

\begin_layout Standard
Si potrebbe pensare di mantenere un elenco di PID invece che l'elenco dei
 RID, includendo solo le pagine che contengono almeno un record della chiave
 
\emph on
k
\emph default
.
 Il primo vantaggio è dovuto al fatto che 
\begin_inset Formula $PIDsize\leq RIDsize$
\end_inset

, un secondo riguarda il fatto che il numero di PID è solitamente molto
 minore dei numero dei RID (dunque sono proprio di meno e la lista non potrà
 essere lunga), infine se l'indice risulta 
\emph on
clustered
\emph default
 (ordinato per il valore di chiave 
\emph on
k
\emph default
) l'efficienza aumenta di molto sopratutto se in una singola pagina ci sono
 molti record con lo stesso valore di chiave 
\emph on
k
\emph default
.
\end_layout

\begin_layout Subparagraph
Posting File
\end_layout

\begin_layout Standard
L'elenco dei RID viene mantenuto in un file separato (il 
\emph on
posting file
\emph default
): ogni entry del 
\emph on
posting file
\emph default
 ha la forma (k,l) dove:
\end_layout

\begin_layout Itemize

\series bold
k
\series default
 è il valore di chiave
\end_layout

\begin_layout Itemize

\series bold
l
\series default
 è la lista di RID aventi 
\series bold
k
\series default
 come valore di chiave
\end_layout

\begin_layout Standard
Le entry del 
\emph on
B+tree 
\emph default
conterranno ora riferimenti alle 
\emph on
entry
\emph default
 del 
\emph on
posting file
\emph default
.
 Lo svantaggio maggiore è (oltre all'occupazione in memoria) è che si introduce
 un ulteriore livello di indirezione, facendo aumentare di 1 il costo di
 ogni singola operazione.
\end_layout

\begin_layout Subsubsection
B+tree nella pratica
\end_layout

\begin_layout Standard
Finora abbiamo parlato di un 
\emph on
B+tree
\emph default
 teorico (cioè applicato a un indice 
\emph on
primary
\emph default
 e magari anche 
\emph on
clustered
\emph default
).
 Ma nella pratica?
\end_layout

\begin_layout Standard
In pratica i 
\emph on
B+tree 
\emph default
devono tener conto di molte altre esigenze:
\end_layout

\begin_layout Itemize

\emph on
B+tree
\emph default
 come organizzazione principale dei dati
\end_layout

\begin_layout Itemize
Chiavi a lunghezza variabile
\end_layout

\begin_layout Itemize
Compressione delle chiavi
\end_layout

\begin_layout Itemize

\emph on
B+tree 
\emph default
multi-attributo
\end_layout

\begin_layout Itemize
Bulk-loading
\end_layout

\begin_layout Itemize
Implementazione 
\emph on
B+tree: 
\series bold
GiST
\end_layout

\begin_layout Paragraph
B+tree come organizzazione principale
\end_layout

\begin_layout Standard
Inizialmente il B+tree nacque proprio con questo scopo, cioè di introdurre
 i 
\emph on
record dati 
\emph default
direttamente nelle foglie dell'albero.
 Evidentemente questo permetteva di ordinare il 
\emph on
file dati
\emph default
 automaticamente grazie alle operazione di inserimento/cancellazione: di
 contro però, ad ogni operazione, i record si spostavano, e dunque il 
\series bold
RID
\series default
 cambiava.
 Cambiare il 
\series bold
RID
\series default
 implica dover aggiornare tutti gli indici che contengono la tupla associata:
 questo è stato il motivo principale per cui il 
\emph on
B+tree
\emph default
 venne poi solo usato per memorizzare indici.
\end_layout

\begin_layout Paragraph
Chiavi a lunghezza variabile
\end_layout

\begin_layout Standard
Tutto ciò che abbiamo visto fino ad ora aveva come assunzione che le 
\emph on
entry
\emph default
 fossero di lunghezza fissa.
 Questo nella pratica è difficilmente vero:
\end_layout

\begin_layout Itemize
Chiavi di lunghezza variabile (es.
 
\emph on
varchar
\emph default
)
\end_layout

\begin_layout Itemize
Indice secondario (dunque 
\emph on
lista di RID
\emph default
 associata ad ogni entry)
\end_layout

\begin_layout Itemize
Indice come organizzazione principale dei dati (dunque ogni entry in realtà
 è un record quasi sempre di lunghezza variabile)
\end_layout

\begin_layout Standard
In questi casi il concetto di ordine 
\emph on
d
\emph default
 dell'albero perde di validità, ma questo non inficia la 
\emph on
ratio
\emph default
 utilizzata dietro il meccanismo dei 
\emph on
B+tree
\emph default
: invece di applicare il vincolo di occupazione minima alle 
\emph on
entry
\emph default
, esso viene applicato all'utilizzazione dello spazio (fisico) all'interno
 del nodo.
\end_layout

\begin_layout Paragraph
Compressione delle chiavi
\end_layout

\begin_layout Standard
È evidente che, per minimizzare i tempi di accesso all'albero, conviene
 avere valori elevati di 
\emph on
d 
\emph default
(ordine dell'albero).
 Si può pensare di ridurre la lunghezza dei valori della chiave di ricerca
 
\emph on
k
\emph default
 
\series bold
nei nodi 
\series default
(nelle foglie è bene non attuarlo poichè nelle foglie vengono memorizzate
 effettivamente le 
\emph on
entry
\emph default
)
\emph on
 
\emph default
attraverso una 
\emph on
compressione
\emph default
, con lo scopo di aumentare il numero dei valori 
\emph on
k
\emph default
 inseribili all'interno di ogni nodo
\end_layout

\begin_layout Standard
Nei 
\emph on
B+tree non è necessario
\emph default
 che i nodi interni contengano valori di chiavi esistenti nei dati, essi
 servono prettamente a differenziare il contenuto di nodi figli adiacenti.
\end_layout

\begin_layout Standard
Se ad esempio nella foglia A abbiamo le due entry (Semenzara, RID
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

) (Serbelloni Mazzanti Vien Dal Mare, RID
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

) e nella foglia B abbiamo l'entry (Silvani, RID
\begin_inset script subscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

) si nota che basterebbe salvare nel nodo padre il valore di ricerca 
\begin_inset Quotes eld
\end_inset

Ser
\begin_inset Quotes erd
\end_inset

 per riuscire a distinguere in quale foglia andare a cercare effettivamente
 l'entry.
\end_layout

\begin_layout Paragraph
Ricerche multi-attributo
\end_layout

\begin_layout Standard
Supponiamo di avere la seguente query:
\begin_inset Newline newline
\end_inset


\family typewriter
SELECT * FROM persone
\begin_inset Newline newline
\end_inset

WHERE cognome=
\begin_inset Quotes erd
\end_inset

Rossi
\begin_inset Quotes erd
\end_inset


\begin_inset Newline newline
\end_inset

AND anno>1990
\end_layout

\begin_layout Standard
Come possiamo utilizzare un indice per risolvere efficentemente la query?
 Si noti che il WHERE richiede due chiavi di ricerca, una per il cognome
 e una per l'anno.
\end_layout

\begin_layout Standard
Una prima soluzione che può venire in mente è quella di usare un solo indice:
 si recuperano attraverso l'indice i record che soddisfano il primo (o il
 secondo) predicato e si scelgono solo quelli che soddisfano anche l'altro.
 È giusto sottolineare che la soluzione può migliorare se l'indice selezionato
 
\begin_inset Quotes eld
\end_inset

taglia
\begin_inset Quotes erd
\end_inset

 il più possibile: nell'esempio è più facile che siano presenti meno record
 il cui cognome sia Rossi piuttosto il cui anno di nascita sia superiore
 a 1990, ecco che la strategia migliore è di applicare un indice al campo
 cognome.
\end_layout

\begin_layout Standard
Una seconda soluzione prevede di usare invece entrambi gli indici: si recuperano
 separatamente i 
\series bold
RID
\series default
 che soddisfano i due predicati (uno da un primo indice e l'altro dal secondo)
 e se ne effettua l'intersezione.
 La soluzione diventa più efficiente se i RID sono mantenuti ordinati.
 
\end_layout

\begin_layout Standard
In entrambi i casi il lavoro aggiuntivo può vanificare il vantaggio di usare
 l'indice.
 Una buona soluzione è dunque quella di costruire un indice 
\emph on
multi-attributo
\emph default
.
 La chiave di ricerca 
\emph on
k
\emph default
 è composta ora dalla concatenazione degli attributi coinvolti e l'ordinamento
 risulta essere quello lessicografico.
 
\series bold
NB
\series default
 solo a parità di un attributo si considera l'attributo successivo.
\end_layout

\begin_layout Standard
In figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempiomultiattributo"

\end_inset

) un esempio di indice 
\emph on
multi-attributo
\emph default
 su attributi (cognome,anno).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempiomultiattributo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempiomultiattributo.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo indice è in grado di risolvere efficientemente interrogazioni su
 
\emph on
cognome
\emph default
 e su (
\emph on
cognome
\emph default
,
\emph on
anno
\emph default
).
 Risolve efficientemente anche interrogazioni di tipo intervallo però solo
 applicate ai cognomi (Le persone che hanno cognome da 'Bianchi' a 'Rossi')
 o ai cognomi e anno (I 'Rossi' nati dal '1985' al '1990').
 L'indice in figura non è però in grado di risolvere efficientemente interrogazi
oni solo su 
\emph on
anno
\emph default
: il motivo è ovvio, l'ordine degli attributi è importante per permettere
 l'ordinamento lessicografico.
 In generale se ho n attributi posso costruire n! indici ed è compito dell'
\emph on
amministratore
\emph default
 del database scegliere gli indici opportuni.
\end_layout

\begin_layout Paragraph
Bulk-Loading
\end_layout

\begin_layout Standard
Spesso si ha la necessità di costruire (o ricostruire) un indice ex novo:
 infatti molto spesso la decisione di costruire un indice non avviene in
 fase di creazione del database ma solo in inseguito (ad esempio ci accorgiamo
 ci accorgiamo che una query è lenta) o ancora quando richiediamo l'ordinamento
 fisico di un file con modifiche ai relativi RID.
 Inserire una per una le 
\emph on
entry
\emph default
, come visto, provoca 
\emph on
mediamente
\emph default
 uno split ogni 
\series bold
d
\series default
 record inseriti (poichè la probabilità di split ricordiamo è 
\begin_inset Formula $\frac{1}{d}$
\end_inset

).
 Evidentemente creare un indice effettuando l'inserimento uno a uno non
 risulta essere la soluzione migliore.
 Ecco dunque che si può ricorrere alla tecnica del 
\series bold
bulk-loading
\series default
: si crea una lista di coppie (k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

,RID
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

) e la si ordina per valori della chiave (
\series bold
N.B.

\series default
 non ci stiamo preoccupando al momento di capire come ordinare una lista
 di coppie che non sono in memoria centrale, facciamo l'assunzione che sia
 possibile farlo, più avanti vedremo come si risolve il problema), questa
 lista (opportunamente paginata) corrisponde al livello delle foglie del
 nostro B+tree (N.B.
 è possibile non usare le foglie direttamente al 100% ma lasciare spazio
 libero così da non provocare un immediato split al prossimo inserimento).
 A partire ora dal livello delle foglie viene creata una nuova lista (sostanzial
mente i separatori) di coppie (k
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

,PID
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

): paginando opportunamente anche questa lista abbiamo costruito il livello
 superiore alle foglie.
 Il procedimento prosegue via via fino ad ottenere la radice.
 Osserviamo dunque che stiamo costruendo l'indice dal basso verso l'alto.
\end_layout

\begin_layout Subsection
GiST
\end_layout

\begin_layout Standard
Il 
\series bold
GiST
\series default
 (
\series bold
G
\series default
eneral
\series bold
i
\series default
zed 
\series bold
S
\series default
earch 
\series bold
T
\series default
ree), creato da 
\emph on
Hellerstein
\emph default
, 
\emph on
Naughton
\emph default
, 
\emph on
Pfeffer
\emph default
 nel 1995 (come si vede è successivo al B-tree e B+tree) non è una implementazio
ne del 
\emph on
B+tree
\emph default
 ma un 
\emph on
framework
\emph default
 del tuto generale che permette di creare alberi; non è dunque uno specifico
 metodo di accesso bensì una struttura generalizzata che a seconda di come
 viene istanziata può comportarsi come un 
\emph on
B+tree
\emph default
 o un 
\emph on
R-tree 
\emph default
(vedremo più avanti) ecc...
\end_layout

\begin_layout Standard
Il GiST permette dunque di capire i principi costruttivi degli alberi con
 l'obiettivo principale di semplificare lo sviluppo di diversi metodi di
 accesso (e non dunque di definire un nuovo tipo di indice).
\end_layout

\begin_layout Standard
Esempio: nel sistema 
\emph on
postgres
\emph default
 (dbms) i 
\emph on
B+tree
\emph default
 vengono implementati in circa 3000 righe di codice C.
 Lo stesso 
\emph on
B+tree
\emph default
 implementato come istanza del GiST richiede circa in totale 500 righe di
 codice (questo perchè molta parte implementativa viene gestitata da GiST
 stesso).
\end_layout

\begin_layout Subsubsection
Concetti alla base di GiST
\end_layout

\begin_layout Standard
Invece di considerare specifiche 
\emph on
query, 
\emph default
GiST ne generalizza il concetto portandolo a livello di 
\emph on
predicato
\emph default
 (
\series bold
p
\series default
).
 Ogni 
\series bold
nodo
\series default
 del GiST contiene una serie di 
\emph on
entry
\emph default
 formate dalla coppia 
\series bold
(p,ptr)
\series default
 dove
\end_layout

\begin_layout Itemize

\series bold
p
\series default
 è un 
\emph on
predicato generico 
\emph default
(una chiave poi nel nostro B+tree)
\end_layout

\begin_layout Itemize

\series bold
ptr
\series default
 è 
\emph on
puntatore generico
\emph default
: può dunque puntare sia a un altro nodo dell'albero (dunque a una pagina)
 sia direttamente a una tupla (quindi a un RID)
\end_layout

\begin_layout Standard
L'accesso a un sottoalbero individuato dal puntatore associato a una chiave
 avviene 
\series bold
solo se
\series default
 la chiave è 
\emph on
consistente
\emph default
 con il 
\emph on
predicato q
\emph default
, ovvero solo se la chiave non esclude la possibilità che il sottoalbero
 relativo possa contenere dati che soddisfino q: chiedersi se il predicato
 P è consistente al predicato Q vuol dire chiedersi se P può fare in modo
 che Q sia vero.
 Il 
\series bold
solo se
\series default
 prima evidenziato ha il dovere di permettere l'accesso all'albero anche
 nei casi in cui il predicato P non soddisfi poi in realtà il predicato
 Q.
 Tentiamo di spiegarci meglio con un esempio sul 
\emph on
B+tree
\emph default
: la radice contiene il valore 50 e ci chiediamo se il valore 20 esiste
 nell'albero (notiamo che qui il nostro predicato P riguarda l'esistenza
 del 20); sicuramente essendo 
\begin_inset Formula $20<50$
\end_inset

, sono sicuro che devo accedere al sottoalbero sinistro e sicuramente non
 al destro perchè anche se non sono sicuro che il 20 esista davvero nell'albero
 poichè lo scoprirò solo al livello delle foglie (e qui si spiega il 
\series bold
solo se
\series default
), esso (il 20) è 
\emph on
consistente
\emph default
 con il sottoalbero sinistro ma non con il sottoalbero destro.
\end_layout

\begin_layout Standard
Proprietà fondamentale di un GiST è la 
\series bold
monotonicità del predicato p:
\series default
 cioè se il predicato p vale per un determinato nodo (che sia foglia o nodo
 interno) esso dovrà valere 
\series bold
per forza
\emph on
 
\series default
\emph default
per tutti i suoi antenati (propri).
 Se così non fosse mi potrei ritrovare che il predicato p risulta essere
 consistente per il nodo N ma non per il padre la qual cosa mi porterebbe
 a scartare l'accesso al nodo padre stesso facendomi perdere informazioni
 poichè p consistente con il nodo N.
 I predicati che troviamo a livelli delle foglie sono più 
\emph on
restrittivi
\emph default
 (specifici) di quelli che troviamo nei livelli superiori che risultano
 più 
\emph on
laschi
\emph default
: questo implica che è difficile 
\begin_inset Quotes eld
\end_inset

buttare
\begin_inset Quotes erd
\end_inset

 sottoalberi a livelli alti, e man mano che si scende l'albero fino al livello
 foglie, la probabilità aumenta fino a diventare certezza.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:predicatoP"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename predicatoP.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vediamo un esempio (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:predicatoP"

\end_inset

).
 Nella figura abbiamo rappresentato un nodo contentente l'entry (p,ptr)
 specificate.
 Ci chiediamo ora se alcuni predicati (query) Q sono consistenti con il
 predicato p.
\end_layout

\begin_layout Itemize
Q=italiano(X) && studente(X) è consistente con p poichè italiano è anche
 un europeo e studente potrebbe essere un laureando (il condizionale è d'obbligo
, solo scendendo poi l'albero lo scopriremo)
\end_layout

\begin_layout Itemize
Q=messicano(X) && matricola(X) non è consistente con p poichè messicano
 non è europeo
\end_layout

\begin_layout Itemize
Q=francese(X) && lavoratore(X) è consistente con p di nuovo perchè francese
 è europeo e un lavoratore potrebbe essere anche un laureando
\end_layout

\begin_layout Itemize
Q=messicano(X) OR studente(X) è consistene con p poichè anche se il messicano
 non è europeo, uno studente potrebbe benissimo essere un laureando.
\end_layout

\begin_layout Standard
Cosa potrebbe ora contenere il figlio di questo nodo (cioè il sottoalbero
 puntato da ptr)?
\end_layout

\begin_layout Standard
Il nodo figlio potrebbe avere entry con predicato p=italiano(X) && laureando(X)
 e per monotonicità del predicato ciò che risulterebbe vero per il figlio
 lo risulterebbe anche il padre.
 Il nodo figlio invece non può contenere entry con predicato p=italiano(X)
 && studente(X) poichè non tutti gli studenti sono laureandi (
\series bold
n.b.

\series default
 qui ci stiamo chiedendo quale entry può avere il figlio non se il predicato
 è consistente con il nodo mostrato in figura - 
\series bold
n.b.2 
\series default
come detto prima, man mano che si scende nell'albero i predicati diventano
 più stringenti ecco perchè italiano(X) && studente(X) non può essere figlio
 del nodo mostrato, poichè studente è una generalizzazione di laureando)
 e non può contenere neppure un entry con predicato p=italiano(X) poichè
 non tutti gli italiani sono laureandi.
\end_layout

\begin_layout Subsubsection
Proprietà di un GiST
\end_layout

\begin_layout Standard
Indipendentemente dalla specifica istanziazione, ogni Gist gode delle seguenti
 proprietà:
\end_layout

\begin_layout Itemize
Un GiST è un 
\emph on
albero paginato perfettamente bilanciato
\end_layout

\begin_layout Itemize
Una 
\emph on
entry
\emph default
 di un 
\emph on
nodo intermedio
\emph default
 è una coppia (p,ptr) con
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
p
\series default
 predicato usato come chiave di ricerca
\end_layout

\begin_layout Itemize

\series bold
ptr
\series default
 puntatore a un altro nodo del GiST
\end_layout

\end_deeper
\begin_layout Itemize
Una 
\emph on
entry
\emph default
 di un 
\emph on
nodo foglia
\emph default
 è una coppia (p,ptr) con
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
p 
\series default
valore di chiave
\end_layout

\begin_layout Itemize

\series bold
ptr
\series default
 puntatore a una tupla (oggetto del database) che soddisfa p
\end_layout

\end_deeper
\begin_layout Itemize
Ogni nodo, ad eccezione della radice, contiene un massimo di 
\series bold
M
\series default
 entry e un minimo di 
\begin_inset Formula $f\cdot M$
\end_inset

 entry, con 
\begin_inset Formula $\frac{2}{M}\leq f\leq\frac{1}{2}$
\end_inset

 (f=fattore di caricamento).
 Come si nota a differenza del B+tree ora il fattore minimo di riempimento
 può essere anche minore del 50%.
 Si nota che il massimo valore che 
\emph on
f
\emph default
 può assumere è proprio del 50% (cioè il massimo sul vincolo di riempimento
 minimo è 
\begin_inset Formula $\frac{1}{2}$
\end_inset

) mentre invece il minimo è 2 (posso mettere come minimo al vincolo minimo
 di riempimento 2 entry).
 Come accadeva nel B+tree in caso di lunghezza variabile si usano fattori
 non legati al numero di entry ma alla loro dimensione e al loro valore
 di riempimento.
\end_layout

\begin_layout Itemize
La 
\emph on
radice
\emph default
, se non è una foglia, ha almeno due 
\emph on
entry
\end_layout

\begin_layout Itemize
Per ogni entry (p,ptr) di un nodo intermedio, 
\emph on
p
\emph default
 vale per pgni tupla raggiungibile via ptr: cioè se ho il mio nodo il cui
 figlio è identificato dal determinato ptr associato, il predicato 
\emph on
p 
\emph default
vale anche per ogni entry del nodo figlio prima indicato.
\end_layout

\begin_layout Subsubsection
Realizzazione concreta
\end_layout

\begin_layout Standard
Alla base del GiST vi è la definizione di una serie di metodi relativi alla
 gestione:
\end_layout

\begin_layout Itemize
dei valori di chiave (
\series bold
key methods
\series default
)
\end_layout

\begin_layout Itemize
dell'albero (
\series bold
Tree methods
\series default
)
\end_layout

\begin_layout Standard
La definizione del GiST specifica solo i 
\emph on
Tree methods
\emph default
, la specifica dei 
\emph on
Key methods
\emph default
 è eseguita quando si istanzia il GiST per gestire uno specifico tipo di
 chiavi (Esempio: tipo di chiavi a valori interi istanzierà un 
\emph on
B+tree
\emph default
, tipo di chiavi a intervalli multi-dimensionali istanzierà un 
\emph on
R-tree
\emph default
).
\begin_inset Newline newline
\end_inset

Poichè i 
\emph on
Key methods
\emph default
 sono invocati da 
\emph on
Tree methods
\emph default
 è necessario standarizzare l'interfaccia dei primi.
\end_layout

\begin_layout Subsubsection
Key Methods
\end_layout

\begin_layout Paragraph
Consistent (Utilizzato in Ricerca)
\end_layout

\begin_layout Standard

\family typewriter
Consistent(E,q)
\end_layout

\begin_layout Itemize

\series bold
Input: 
\series default
Entry E = (p,ptr) - q: predicato di ricerca q
\end_layout

\begin_layout Itemize

\series bold
Output: 
\family typewriter
IF 
\series default
(p&q==false) 
\series bold
THEN
\series default
 false 
\series bold
ELSE
\series default
 true
\end_layout

\begin_layout Standard
Lo scopo di 
\emph on
Consistent
\emph default
 è eseguire un 
\begin_inset Quotes eld
\end_inset


\emph on
pruning
\begin_inset Quotes erd
\end_inset

 
\emph default
(potatura) dello spazio di ricerca (ovvero eliminare sotto-alberi).
 Se il predicato di un sotto-albero non è consistente con la query (predicato),
 si evita di accedere all'intero sotto albero.
 Nel caso il test 
\family typewriter
(p&q==false) 
\family default
risulti oneroso è comunque possibile lavorare con approssimazioni conservative
 ovvero rispondere 
\emph on
true
\emph default
 anche se poi risulterà essere 
\emph on
false
\emph default
, questo poichè se avessimo risposto 
\emph on
false
\emph default
 avremmo potuto tagliare sotto-alberi che contenevano invece informazioni
 necessarie, avendo invece risposto 
\emph on
true
\emph default
 ci addentriamo nel sottoalbero e, in caso, solo al livello delle foglie
 ci accorgeremo se effettivamente risulti essere true o false (serve insomma
 a mantenere la monotonicità della consistenza sui predicati).
 Ciò incide a livello di prestazioni ma non di correttezza poichè si accede
 a un sottoalbero anche se i suoi dati non contribuiscono al risultato della
 query.
 
\emph on
Consistent
\emph default
 (così come gli altri metodi) è specificato per lavorare con predicati di
 complessità arbitraria anche se poi in pratica i predicati possono essere
 
\emph on
ristretti
\emph default
 per migliorarne l'efficienza.
\end_layout

\begin_layout Standard

\series bold
Consistent applicato al B+tree
\end_layout

\begin_layout Standard
Ogni 
\emph on
predicato p 
\emph default
delle 
\emph on
entry
\emph default
 è in realtà un intervallo 
\series bold
[x,y[
\series default
.
 Se la query q è un valore 
\series bold
v
\series default
 
\emph on
Consistent 
\emph default
restituisce 
\emph on
true
\emph default
 se e solo se 
\begin_inset Formula $x\leq v<y$
\end_inset

 (
\series bold
NB
\series default
 se la 
\emph on
entry
\emph default
 invece di aver salvato un intervallo, avesse salvato un singolo valore
 
\series bold
x
\series default
 si potrebba ancora applicare la specifica prima descritta utilizzando l'interva
llo 
\series bold
[x,x[
\series default
 ).
 Se la query q è invece un intervallo 
\series bold
[v,w[
\series default
 
\emph on
Consistent 
\emph default
restituisce 
\emph on
true 
\emph default
se e solo se 
\begin_inset Formula $x<w$
\end_inset

 o 
\begin_inset Formula $y>v$
\end_inset

 (se l'interesezione tra i due intervalli è non vuota).
\end_layout

\begin_layout Paragraph
Union (Utilizzato nella creazione di predicati)
\end_layout

\begin_layout Standard

\family typewriter
Union(P)
\end_layout

\begin_layout Itemize

\series bold
Input: 
\series default
Insieme di entry 
\begin_inset Formula $P=\{(p_{1},ptr_{1}),\ldots,(p_{n},ptr_{n})\}$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Outout:
\series default
 Un 
\emph on
predicato r
\emph default
 che vale per tutte le tuple accessibili tramite uno dei puntatoridelle
 
\emph on
entry
\emph default
.
\end_layout

\begin_layout Standard
Scopo di 
\emph on
Union
\emph default
 è di fornire l'informazione necessaria a caratterizzare il predicato di
 un nodo padre a partire dai predicati dei nodi figli.
 In generale il 
\emph on
predicato r
\emph default
 può essere logicamente derivato come un predicato per cui vale 
\begin_inset Formula $(p_{1}|\ldots|p_{n})\Rightarrow r$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Union applicato al B+tree
\end_layout

\begin_layout Standard
Dato l'insieme di entry 
\begin_inset Formula $P=\{([v_{1},w_{1}[,ptr_{1}),\ldots,([v_{n},w_{n}[,ptr_{n})\}$
\end_inset

 restituisce un nuovo 
\emph on
predicato r 
\emph default
sotto forma di un intervallo 
\begin_inset Formula $r=[min\{v_{1},\ldots,v_{n}\},max\{w_{1},\ldots,w_{n}\}[$
\end_inset

.
\end_layout

\begin_layout Standard
\align center

\family typewriter
---[---|-----[----|----[---|---
\begin_inset Newline newline
\end_inset

---v1--w1----v2---w2---v3--w3--
\begin_inset Newline newline
\end_inset

Restituisce
\begin_inset Newline newline
\end_inset

---[-----------------------|---
\begin_inset Newline newline
\end_inset

---v-----------------------w---
\end_layout

\begin_layout Standard

\series bold
NB
\series default
 L'
\emph on
Union
\emph default
 non sta restituendo la vera unione di tutti gli intervalli, ma solo l'intervall
o creato dal minimo e dal massimo (rende più generale il predicato dei figli).
\end_layout

\begin_layout Paragraph
Compress (Utilizzato nella compressione delle chiavi)
\end_layout

\begin_layout Standard

\family typewriter
Compress(E)
\end_layout

\begin_layout Itemize

\series bold
Input:
\series default
 Entry E = (p,ptr)
\end_layout

\begin_layout Itemize

\series bold
Output: 
\series default
una nuova Entry E'=(p',ptr) con p' rappresentazione compressa di p
\end_layout

\begin_layout Standard
Data una 
\emph on
entry
\emph default
 ne restituisce una nuova che abbia lo stesso puntatore 
\emph on
ptr
\emph default
 ma un diverso predicato 
\emph on
p'
\emph default
 rappresentazione compressa del predicato originale 
\emph on
p
\emph default
.
\begin_inset Newline newline
\end_inset

Scopo di 
\emph on
Compress
\emph default
 è fornire una rappresentazione più efficiente del 
\emph on
predicato p
\emph default
.
 Esempio: separatori al posto di intervalli totalmente ordinati (invece
 che indicare l'intervallo [x,y[ posso indicare solo x) o prefissi a partire
 da stringhe (
\begin_inset Quotes eld
\end_inset

Serbelloni Mazzanti Vien Dal Mare
\begin_inset Quotes erd
\end_inset

 viene trasformato in solo 
\begin_inset Quotes eld
\end_inset

Ser
\begin_inset Quotes erd
\end_inset

).
 La compressione diminuisce l'informazione rappresentata e può essere sia
 con perdita che senza perdita.
\end_layout

\begin_layout Paragraph
Decompress (Utilizzato nella decompressione delle chiavi)
\end_layout

\begin_layout Standard

\family typewriter
Decompress(E)
\end_layout

\begin_layout Itemize

\series bold
Input: 
\series default
Entry E' = (p', ptr) con p' derivato da una compressione 
\begin_inset Formula $p'=Compress(p)$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Output:
\series default
 una nuova Entry E = (r, ptr) con 
\begin_inset Formula $p\Rightarrow r$
\end_inset


\end_layout

\begin_layout Standard
La compressione in generale non è 
\emph on
lossless
\emph default
 (cioè in generale è con perdita),questo richiede che il 
\emph on
predicato r 
\emph default
della nuova 
\emph on
entry
\emph default
 sia una derivazione logica dal 
\emph on
predicato p originale 
\begin_inset Formula $p\Rightarrow r$
\end_inset

 
\emph default
cioè se data una query Q, Q non è consistente con p allora Q non è consistente
 con r.
 Il caso più semplice di 
\emph on
decompressione 
\emph default
è che questa risulti essere la funzione identità.
\end_layout

\begin_layout Paragraph
Penalty (Utilizzato nell'inserimento)
\end_layout

\begin_layout Standard
Penalty(E
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

,E
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Input
\series default
: Entry E
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 = (p
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

,ptr
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

) e Entry E
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 = (p
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

,ptr
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Output: 
\series default
Un valore di 
\begin_inset Quotes eld
\end_inset

penalità
\begin_inset Quotes erd
\end_inset

 che risulta dall'inserire l'entry E
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 nel sottoalbero avente per radice E
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Data una nuova 
\emph on
entry
\emph default
 (o un nuovo nodo) devo scegliere in quale sottoalbero (o nodo) inserirla,
 allora 
\emph on
Penalty 
\emph default
restituisce una valore intero di 
\begin_inset Quotes eld
\end_inset

penalità
\begin_inset Quotes erd
\end_inset

 che verrà confrontato con diversi altri valori di penalità per altri nodi
 permettendo di stabilire la scelta corretta.
\end_layout

\begin_layout Standard

\series bold
Penalty applicato al B+tree
\end_layout

\begin_layout Standard
Nel B+tree 
\emph on
Penalty
\emph default
 descrive un valore associato a quanto dobbiamo ingrandire l'intervallo
 del padre per poter includere l'intervallo dell'entry che stiamo inserendo.
\end_layout

\begin_layout Standard
Date due Entry: 
\begin_inset Formula $E_{1}=([x_{1},y_{1}[,ptr_{1})$
\end_inset

 e 
\begin_inset Formula $E_{2}=([x_{2},y_{2}[,ptr_{2})$
\end_inset


\end_layout

\begin_layout Standard

\emph on
Penalty
\emph default
 restituisce un valore che indica di quanto dobbiamo ingrandire il primo
 intervallo per includere il secondo (normalmente si può ingrandire sia
 a destra che a sinistra).
\end_layout

\begin_layout Itemize
Caso generale: 
\emph on
Penalty
\emph default
 restituisce 
\begin_inset Formula $max\{y_{2}-y_{1},0\}+max\{x_{1}-x_{2},0\}$
\end_inset


\end_layout

\begin_layout Itemize
E
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 è la prima 
\emph on
entry
\emph default
 del suo nodo: 
\emph on
Penalty 
\emph default
restituisce 
\begin_inset Formula $max\{y_{2}-y_{1},0\}$
\end_inset


\end_layout

\begin_layout Itemize
E
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 è l'ultima entry del suo nodo: 
\emph on
Penalty
\emph default
 restituisce 
\begin_inset Formula $max\{x_{1}-x_{2},0\}$
\end_inset


\end_layout

\begin_layout Paragraph
PickSplit (Utilizzato per lo split)
\end_layout

\begin_layout Standard

\family typewriter
PickSplit(P)
\end_layout

\begin_layout Itemize

\series bold
Input:
\series default
 Insieme di M+1 entry
\end_layout

\begin_layout Itemize

\series bold
Output: 
\series default
Due insiemi di 
\emph on
entry
\emph default
 P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 e P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 di cardinalità 
\begin_inset Formula $\geq f\cdot M$
\end_inset


\end_layout

\begin_layout Standard
Ho un insieme di M+1 entry poichè un nodo è andato in 
\emph on
overflow
\emph default
 e devo dunque dividirlo in due, esso restitusce un insieme di due entry
 con cardinalità maggiore del fattore minimo di occupazione che avevo imposto
 
\begin_inset Formula $\geq f\cdot M$
\end_inset

.
 
\emph on
PickSplit
\emph default
 implementa la vera e propria strategia di split che non viene specificata
 a questo livello e anche in questo caso, tipicamente, esso tenta di minimizzare
 similmente a come fa 
\emph on
Penalty
\end_layout

\begin_layout Standard

\series bold
PickSplit applicato al B+tree
\end_layout

\begin_layout Standard
Nel B+tree i due nuovi insieme di entry P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 e P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 si divideranno le entry in modo tale che P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 contenga le prime 
\begin_inset Formula $\frac{M+1}{2}$
\end_inset

 entry e che P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 contenga le rimanenti.
 Nel caso di 
\emph on
entry
\emph default
 di lunghezza variabile invece di utilizzare il numero di 
\emph on
entry
\emph default
 si utilizzano criteri legati alla loro dimensione, questo però potrebbe
 portare a violare il vincolo di utilizzazione minima.
 (Ad esempio: ho una 
\emph on
entry
\emph default
 che deve essere messa o in P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 o in P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

.
 Se messa in P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 essa può essere compressa però portando in 
\emph on
overflow
\emph default
 P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 perchè non abbastanza riempito, mentre se messa in P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 essa viene inserita integra portando però in 
\emph on
overflow
\emph default
 P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

).
\end_layout

\begin_layout Subsubsection
Tree Methods
\end_layout

\begin_layout Standard
I 
\emph on
Tree methods 
\emph default
si richiamano fra loro e utilizzano alcuni dei 
\emph on
key methods
\emph default
 prima definiti.
 Si assume implcitamente che le chiavi vengano compresse in fase di scrittura
 e decompresse in fase di lettura.
 I 
\emph on
Tree methods
\emph default
 in breve sono:
\end_layout

\begin_layout Description
Search permette la ricerca e utilizza 
\emph on
Consistent
\end_layout

\begin_layout Description
Insert permette l'inserimento e utilizza 
\series bold
ChooseSubtree
\series default
, 
\series bold
Split
\series default
 e 
\series bold
AdjustKeys
\end_layout

\begin_layout Description
ChooseSubtree permette di determinare il nodo in cui inserire e utilizza
 
\emph on
Penalty
\end_layout

\begin_layout Description
Split permette lo split e utilizza 
\emph on
PickSplit
\emph default
 e 
\emph on
Union
\end_layout

\begin_layout Description
AdjustKeys permette di sistemare le chiavi di ricerca e utilizza 
\emph on
Union
\end_layout

\begin_layout Description
Delete permette di eliminare una entry e utilizza 
\series bold
Search
\series default
 e 
\series bold
CondenseTree
\end_layout

\begin_layout Description
CondenseTree permette la 
\begin_inset Quotes eld
\end_inset

ridistribuzione
\begin_inset Quotes erd
\end_inset

 e l'abbassamento dell'altezza dell'albero in caso di cancellazione e usa
 
\series bold
AdjustKeys
\series default
 e 
\series bold
Insert
\end_layout

\begin_layout Paragraph
Search
\end_layout

\begin_layout Standard

\family typewriter
Search(R,q)
\end_layout

\begin_layout Itemize

\series bold
Input
\series default
: (sotto-)albero con 
\emph on
radice R 
\emph default
e 
\emph on
predicato 
\emph default
(query) 
\emph on
q
\end_layout

\begin_layout Itemize

\series bold
Output
\series default
: Tutti i record (entry) che soddisfano (sono consistenti) con 
\emph on
q
\end_layout

\begin_layout Standard

\family typewriter
\series bold
if
\series default
 R non è una foglia
\begin_inset Newline newline
\end_inset


\series bold
--for each 
\series default
E 
\series bold
in 
\series default
R
\begin_inset Newline newline
\end_inset


\series bold
----if
\series default
 
\emph on
Consistent
\emph default
(E,q) 
\series bold
then 
\series default
\emph on
Search
\emph default
(*(E.ptr),q)
\begin_inset Newline newline
\end_inset


\series bold
else for each
\series default
 E
\series bold
 in
\series default
 R
\begin_inset Newline newline
\end_inset


\series bold
--if
\series default
 
\emph on
Consistent
\emph default
(E,q) 
\series bold
then
\begin_inset Newline newline
\end_inset


\series default
----aggiungi *(E.ptr) al risultato
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\bar under
Algoritmo a parole:
\bar default

\begin_inset Newline newline
\end_inset

Se R non è una foglia per ogni 
\emph on
entry
\emph default
 in R: se l'
\emph on
entry
\emph default
 è consistente con il predicato faccio il 
\emph on
Search
\emph default
 sul relativo figlio
\begin_inset Newline newline
\end_inset

Se R è una foglia, per ogni 
\emph on
entry
\emph default
 in R: se è l'
\emph on
entry
\emph default
 è consistente con il predicato aggiungo il puntatore (che sarà un RID)
 al risultato.
\end_layout

\begin_layout Standard
Che succede però se sto cercando un intervallo? Sembrerebbe essere tornato
 in causa il 
\series bold
backtracking
\series default
 tanto agoniato.
 In realtà per domini lineari (totalmente ordinati) come nel caso dei B+tree,
 la specifica del GiST pervede un'estensione del 
\series bold
Search
\series default
 più efficinete che sfrutta la contiguità delle foglie per risolvere la
 ricerca per intervallo.
 In particolare la 
\series bold
Search
\series default
 raggiunge la prima foglia 
\emph on
consistente
\emph default
 con la query q, dopodiché sfrutta il collegamento a lista delle foglie
 fino a che non si raggiunge la prima foglia 
\emph on
non consistente
\emph default
 con il predicato q.
\end_layout

\begin_layout Paragraph
Insert
\end_layout

\begin_layout Standard

\family typewriter
Insert(R,E,l)
\end_layout

\begin_layout Itemize

\series bold
Input
\series default
: Albero con 
\emph on
radice R
\emph default
, la Entry E da inserire, il livello l in cui inserirla
\end_layout

\begin_layout Itemize

\series bold
Output:
\series default
 un nuovo albero con la Entry E inserita al livello l.
\end_layout

\begin_layout Standard

\family typewriter
N = 
\emph on
ChooseSubtree
\emph default
(R,E,I)
\begin_inset Newline newline
\end_inset


\series bold
if
\series default
 E può essere inserita in N 
\series bold
then
\series default
 inserisci E in N
\begin_inset Newline newline
\end_inset


\series bold
else
\series default
 
\emph on
Split
\emph default
(R,N,E)
\begin_inset Newline newline
\end_inset


\emph on
AdjustKeys
\emph default
(R,N)
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\bar under
Algoritmo a parole:
\end_layout

\begin_layout Standard
Scelgo il nodo 
\emph on
N
\emph default
 a livello l in cui inserire la mia entry 
\emph on
E
\emph default
 attraverso il metodo 
\emph on
ChooseSubtree
\begin_inset Newline newline
\end_inset


\emph default
Se 
\emph on
E
\emph default
 può essere inserita in 
\emph on
N
\emph default
 allora inserisci
\begin_inset Newline newline
\end_inset

Altrimenti esegui lo 
\emph on
Split
\emph default
(R,N,E)
\begin_inset Newline newline
\end_inset

Infine aggiusta le chiavi attraverso 
\emph on
AdjustKeys
\end_layout

\begin_layout Standard
L'algoritmo di inserimento viene usato sia per inserire nuove entry, sia
 per re-inserire 
\emph on
entry
\emph default
 
\begin_inset Quotes eld
\end_inset

orfane
\begin_inset Quotes erd
\end_inset

 risultanti da 
\emph on
underflow
\emph default
.
 Per tale motivo viene passato in input anche il livello dell'albero in
 cui inserire l'
\emph on
entry
\emph default
 (poichè le entry orfane potrebbero trovarsi a livelli superiori rispetto
 alle foglie) con la convezione che le foglie siano al livello 0.
 In caso di 
\emph on
overflow
\emph default
 viene attivata la procedura di 
\emph on
Split
\emph default
 (che può propagarsi) portando i cambiamenti anche verso l'alto.
\end_layout

\begin_layout Paragraph
ChooseSubtree
\end_layout

\begin_layout Standard

\family typewriter
ChooseSubtree(R,E,I)
\end_layout

\begin_layout Itemize

\series bold
Input
\series default
: Albero con radice R, l'entry E da inserire, il livello l in cui inserirla
\end_layout

\begin_layout Itemize

\series bold
Output
\series default
: nodo 
\emph on
N
\emph default
 al livello l in cui inserire 
\emph on
E
\emph default
.
\end_layout

\begin_layout Standard

\family typewriter
\series bold
if
\series default
 R è al livello l 
\series bold
return 
\series default
R
\begin_inset Newline newline
\end_inset


\series bold
else
\series default
 scegli tra tutte le entry F=(p',ptr') 
\series bold
in
\series default
 R quella per cui 
\emph on
Penalty
\emph default
(F,E) è minimo
\begin_inset Newline newline
\end_inset


\series bold
return
\series default
 
\emph on
ChooseSubtree
\emph default
(*(F.ptr'),E,I)
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\bar under
Algoritmo a parole:
\end_layout

\begin_layout Standard
Se R (la radice dell'albero/sottoalbero) si trova al livello l ritorno R
 (ho trovato il nodo in cui inserire E)
\begin_inset Newline newline
\end_inset

Altrimenti scegli tra tutte le entry 
\emph on
F
\emph default
 che stanno nel nodo 
\emph on
R 
\emph default
quella che ha 
\emph on
Penalty
\emph default
 minima con la entry E da inserire e richiama 
\emph on
ChooseSubtree
\emph default
 sul nodo figlio associato alla F selezionata.
\end_layout

\begin_layout Standard
Il 
\emph on
ChooseSubtree
\emph default
 non torna mai indietro su una decisione ad un certo livello (fa una scelta
 greedy) utilizzando 
\emph on
Penalty
\emph default
 per determinare ricorsivamente il sotto-albero in cui inserire E.
\end_layout

\begin_layout Paragraph
Split
\end_layout

\begin_layout Standard

\family typewriter
Split(R,N,E)
\end_layout

\begin_layout Itemize

\series bold
Input
\series default
: Albero con radice R, il nodo N che si deve suddividere e la entry E che
 si deve inserire
\end_layout

\begin_layout Itemize

\series bold
Output:
\series default
 Nuovo albero con N suddiviso ed E inserita.
\end_layout

\begin_layout Standard

\family typewriter
P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

,P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 = 
\emph on
PickSplit
\emph default
({entry in N} U {E})
\begin_inset Newline newline
\end_inset

inserisci P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 in N e P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 in un nuovo nodo N'
\begin_inset Newline newline
\end_inset

p'=
\emph on
Union
\emph default
(P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

)
\begin_inset Newline newline
\end_inset

ptr'=&N'
\begin_inset Newline newline
\end_inset

E'=(p',ptr')
\begin_inset Newline newline
\end_inset


\series bold
if 
\series default
E' può essere inserita in 
\emph on
Parent
\emph default
(N) 
\series bold
then
\series default
 inserisci E' in 
\emph on
Parent
\emph default
(N)
\begin_inset Newline newline
\end_inset


\series bold
else
\series default
 
\emph on
Split
\emph default
(R,
\emph on
Parent
\emph default
(N),E')
\begin_inset Newline newline
\end_inset

F = entry in Parent(N) con F.ptr=&N
\begin_inset Newline newline
\end_inset

F.p=Union(P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

)
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\bar under
Algortimo a parole:
\end_layout

\begin_layout Standard
Prima cosa chiamo 
\emph on
PickSplit
\emph default
 che mi restituisce i due insiemi di 
\emph on
entry
\emph default
 P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 e P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Inserisci P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 in N e P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 in un nuovo nodo N'
\begin_inset Newline newline
\end_inset

Costruisco la nuova Entry E' (p',ptr') che contiene informazioni sul nuovo
 nodo N' che abbia p'
\emph on
=Union
\emph default
(P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

) e ptr'=&N'
\begin_inset Newline newline
\end_inset

Il padre di N ha spazio per inserire la nuova entry E'?
\begin_inset Newline newline
\end_inset

Se sì: inserisco E' nel padre di N
\begin_inset Newline newline
\end_inset

Se no: eseguo lo 
\emph on
Split
\emph default
 sul padre di N e con la nuova Entry E' (da inserire)
\begin_inset Newline newline
\end_inset

Infine cerco l'entry F nel padre di N che puntava al vecchio nodo ormai
 suddiviso e gli aggiorno il predicato p a Union(P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

)
\end_layout

\begin_layout Standard

\emph on
Split 
\emph default
usa 
\emph on
PickSplit
\emph default
 per dividere le entry di un nodo in overflow.
 Diamo per ipotesi che il nodo padre del nodo in overflow si trovi sullo
 stack quindi raggiungibile.
\end_layout

\begin_layout Paragraph
AdjustKeys
\end_layout

\begin_layout Standard

\family typewriter
AdjustKeys(R,N)
\end_layout

\begin_layout Itemize

\series bold
Input
\series default
: Albero con radice R e il nodo N dal quale si vogliono sistemare le chiavi
\end_layout

\begin_layout Itemize

\series bold
Output:
\series default
 Nuovo albero con gli antenati di N con valori di chiave (predicati) corretti
 e accurati
\end_layout

\begin_layout Standard

\family typewriter
E = entry (p,ptr) il cui ptr=&N
\begin_inset Newline newline
\end_inset


\series bold
if
\series default
 N=R 
\series bold
or
\series default
 E.p=
\emph on
Union
\emph default
({entry di N}) 
\series bold
return
\begin_inset Newline newline
\end_inset

else
\series default
 E.p = 
\emph on
Union
\emph default
({entry di N})
\begin_inset Newline newline
\end_inset


\emph on
AdjustKeys
\emph default
(R,
\emph on
Parent
\emph default
(N))
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\bar under
Algoritmo a parole:
\end_layout

\begin_layout Standard
Trovo l'entry 
\emph on
E
\emph default
 tale per cui il suo campo ptr punti al nodo 
\emph on
N
\emph default
 di input.
\begin_inset Newline newline
\end_inset

Se N è la radice oppure E.p è già uguale all'
\emph on
Union 
\emph default
delle entry di N (cioè ha il predicato già accurato) allora 
\series bold
return
\series default
 (fine)
\begin_inset Newline newline
\end_inset

Altrimenti modifico il valore E.p ponendolo uguale all'
\emph on
Union
\emph default
 delle entry di N
\begin_inset Newline newline
\end_inset

Infine richiamo 
\emph on
AdjustKeys
\emph default
 al padre del nodo N.
\end_layout

\begin_layout Standard

\emph on
AdjustKeys
\emph default
 ricalcola i valori di chiave (predicati) a seguito di modifiche.
 L'algoritmo risale ricorsivamente l'albero e termina quando si raggiunge
 la radice o quando trova un valore di chiave già accurato.
\end_layout

\begin_layout Paragraph
Delete
\end_layout

\begin_layout Standard

\family typewriter
Delete(R,E)
\end_layout

\begin_layout Itemize

\series bold
Input: 
\series default
Albero con radice R e 
\emph on
entry 
\emph default
E = (p,ptr) da eliminare
\end_layout

\begin_layout Itemize

\series bold
Output: 
\series default
Albero con l'entry E rimossa
\end_layout

\begin_layout Standard

\family typewriter
\emph on
Search
\emph default
(R,E.p)
\begin_inset Newline newline
\end_inset


\series bold
if 
\series default
E non trovata 
\series bold
return
\begin_inset Newline newline
\end_inset


\series default
L = nodo che contiene E
\begin_inset Newline newline
\end_inset

Rimuovi E da L
\begin_inset Newline newline
\end_inset


\emph on
CondenseTree
\emph default
(R,L)
\begin_inset Newline newline
\end_inset


\series bold
if
\series default
 R ha una sola 
\emph on
entry
\emph default

\begin_inset Newline newline
\end_inset

--rimuovi R
\begin_inset Newline newline
\end_inset

--rendi il figlio di R la nuova radice del GiST
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\bar under
Algoritmo a parole:
\end_layout

\begin_layout Standard
Cerco E.p
\begin_inset Newline newline
\end_inset

Se non trovo una corrispondenza allora termino (nulla da cancellare)
\begin_inset Newline newline
\end_inset

Identifico L come il nodo che contiene l'entry E e rimuovo l'entry dal Nodo.
\begin_inset Newline newline
\end_inset

Applico il 
\emph on
CondenseTree
\emph default
(R,L) al nodo L
\begin_inset Newline newline
\end_inset

Se R (radice) ha una sola entry allora elimino la radice e rendo il suo
 unico figlio la nuova radice del GiST.
\end_layout

\begin_layout Standard

\emph on
Delete
\emph default
 mantiene l'albero bilanciato e ne riduce l'altezza se la radice, al termine
 di 
\emph on
CondenseTree
\emph default
 ha un solo figlio.
 Ovviamente abbiamo supposto di voler cancellare una determinata 
\emph on
entry
\emph default
 in presenza di predicati 
\emph on
univoci
\emph default
 (se così non fosse devo mettere nella ricerca la coppia (p,ptr) a causa
 di chiavi duplicate).
\end_layout

\begin_layout Paragraph
CondenseTree
\end_layout

\begin_layout Standard
CondenseTree(R,L)
\end_layout

\begin_layout Itemize

\series bold
Input:
\series default
 Albero con radice R e la foglia L da cui partire
\end_layout

\begin_layout Itemize

\series bold
Output:
\series default
 un nuovo albero (che non per forza dovrà essere un GiST poichè la radice
 potrebbe avere un solo figlio cosa non permessa nei GiST)
\end_layout

\begin_layout Standard

\family typewriter
N=L
\begin_inset Newline newline
\end_inset

Q={ }
\begin_inset Newline newline
\end_inset

if N = R 
\series bold
goto
\series default
 end
\begin_inset Newline newline
\end_inset

else 
\begin_inset Newline newline
\end_inset

--P = Parent(N)
\begin_inset Newline newline
\end_inset

--E = entry in P tale che E.ptr=&N
\begin_inset Newline newline
\end_inset

if #{entry di N} < f*M
\begin_inset Newline newline
\end_inset

--Q = Q U {entry di N}
\begin_inset Newline newline
\end_inset

--rimuovi E da P
\begin_inset Newline newline
\end_inset

--
\emph on
AdjustKeys
\emph default
(R,P)
\begin_inset Newline newline
\end_inset

if E non è stata rimossa da P
\begin_inset Newline newline
\end_inset

--
\emph on
AdjustKeys
\emph default
(R,P)
\begin_inset Newline newline
\end_inset

else
\begin_inset Newline newline
\end_inset

--N = P
\begin_inset Newline newline
\end_inset

--
\emph on
restart
\emph default

\begin_inset Newline newline
\end_inset

for each E in Q 
\begin_inset Newline newline
\end_inset

--
\emph on
Insert
\emph default
(R,E,level(E))
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\bar under
Algoritmo a parole:
\end_layout

\begin_layout Standard
Sia N = al nodo di cui ci stiamo occupando
\begin_inset Newline newline
\end_inset

Sia Q = l'insieme inizialmente vuoto delle entry orfane
\begin_inset Newline newline
\end_inset

Se N = R (radice) allora ho finito (cioè la radice è una foglia)
\begin_inset Newline newline
\end_inset

Altrimenti
\begin_inset Newline newline
\end_inset

Prendo il padre P del nodo N di cui ci stiamo occupando
\begin_inset Newline newline
\end_inset

Prendo l'entry E nel padre che corrisponde al nodo N
\begin_inset Newline newline
\end_inset

Se il numero di Entry nel nodo risulta minore di 
\emph on
f*M
\emph default
 (fattore minimo di occupazione), cioè il nodo N è in 
\emph on
underflow
\emph default
 allora: aggiorno la lista delle entry orfane aggiungendo quelle di N, rimuovo
 l'entry E dal padre P (poichè il nodo non è più presente) e aggiusto il
 predicato del padre P attraverso 
\emph on
AdjustKeys
\begin_inset Newline newline
\end_inset


\emph default
Se l'entry E non è stata rimossa dal padre P (cioè il nodo N non era in
 
\emph on
underflow
\emph default
) allora devo aggiornare il predicato del padre P (poichè non è stato fatto
 al punto precedente) attravers 
\emph on
AdjustKeys
\begin_inset Newline newline
\end_inset


\emph default
Altrimenti (cioè ho fatto la cancellazione) impongo il nuovo nodo di interesse
 N uguale al padre P e riparti da capo (in poche parole devo risalire la
 catena e controllare che anche il padre P non sia andato in 
\emph on
undeflow
\emph default
).
\begin_inset Newline newline
\end_inset

Infine: inserisco tutte le entry orfane E che stavano nella lista Q nell'albero
 attraverso 
\emph on
Insert
\emph default
 specificando per ogni 
\emph on
entry
\emph default
 il proprio livello.
\end_layout

\begin_layout Standard
Il 
\emph on
CondenseTree
\emph default
 gestisce il reinserimento al livello originario delle entry orfane di nodi
 in underflow che sono state mantenute in un insieme Q a parte.
\end_layout

\begin_layout Subsubsection
Prestazioni
\end_layout

\begin_layout Standard
Fino ad ora abbiamo calcolato le prestazioni della ricerca per un B+tree
 usato come indice primario, ma questo non avviene sempre, dobbiamo dunque
 capire le prestazioni in caso di un indice 
\emph on
secondario 
\emph default
(e dunque con chiavi ripetute) o in caso di ricerca per intervallo (che
 può essere paragonato alla ricerca su indice secondario, in quanto una
 volta arrivato alle foglie devo poi scorrerle per trovare i risultati all'inter
no dell'intervallo).
 In questo caso bisogna capire
\end_layout

\begin_layout Itemize
Quante siano le foglie contenenti 
\emph on
entry
\emph default
 del risultato (quindi il numero di foglie)
\end_layout

\begin_layout Itemize
Quante siano le pagine dati contenenti i record associati alle entry risultanti
 (quindi il numero di pagine)
\end_layout

\begin_layout Standard
Supporremo che
\end_layout

\begin_layout Itemize
Le liste dei riferimenti nelle foglie siano ordinate (per PID) così da non
 accedere più di una volta alla stessa pagina dati
\end_layout

\begin_layout Itemize
I valori degli attributi siano distribuiti uniformemente nel file dati,
 cosicché ogni valore sia ripetuto in media 
\begin_inset Formula $\frac{N_{t}}{N_{k}}$
\end_inset

 volte (con 
\begin_inset Formula $N_{t}$
\end_inset

 numero di tuple e 
\begin_inset Formula $N_{k}$
\end_inset

 numero di valore di chiavi distinti - Da adesso in poi indicheremo con
 
\begin_inset Formula $N$
\end_inset

 il numero di tuple a meno che non espressamente specificata la differenza).
 
\series bold
NB 
\series default
in caso i valori non siano distribuiti in maniera uniforme si può pensare
 che determinati 
\emph on
cataloghi
\emph default
 specializzati proprio in questo, riportino un istogramma statistico sulla
 ripetizione dei vari valori.
\end_layout

\begin_layout Itemize
I record siano distribuiti uniformemente nelle pagine del file dati
\end_layout

\begin_layout Paragraph
Stima del numero di pagine
\end_layout

\begin_layout Standard
Andiamo ora a stimare il numero di pagine medio da caricare per riuscire
 a risolvere la nostra query (cioè il numero di pagine in cui trovo i 
\emph on
risultati
\emph default
, ad esempio se la ricerca risponde che la query è risolta da un numero
 
\emph on
R 
\emph default
di tuple, in quante pagine queste tuple sono distribuite? Sappiamo per certo
 essere un numero 
\begin_inset Formula $\leq R$
\end_inset

).
\end_layout

\begin_layout Standard
Se 
\series bold
R
\series default
 sono i record da reperire in 
\series bold
P
\series default
 pagine:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\frac{1}{P}$
\end_inset

 = probabilità che uno (specifico) dei R record si trovi in una data pagina
\end_layout

\begin_layout Enumerate
\begin_inset Formula $1-\frac{1}{P}$
\end_inset

 = probabilità la data pagina non contenga lo specifico record dei R record
\end_layout

\begin_layout Enumerate
\begin_inset Formula $(1-\frac{1}{P})^{R}$
\end_inset

 = probabilità che la pagina non contenga ALCUN record
\end_layout

\begin_layout Enumerate
\begin_inset Formula $1-(1-\frac{1}{P})^{R}$
\end_inset

 = probabilità che la pagina contenga ALMENO un record
\end_layout

\begin_layout Standard
Moltiplicando ora il punto 4 (probabilità che la pagina contenga almeno
 un record) per il numero delle pagine 
\series bold
P
\series default
 otteniamo il numero medio di pagine da dover caricare
\begin_inset Formula 
\[
\Phi(R,P)=P\cdot(1-(1-\frac{1}{P})^{R})\leq min\{R,P\}
\]

\end_inset


\end_layout

\begin_layout Standard

\bar under
Esempio
\bar default
: Dato un cassetto contenente calzini di P colori, ogni colore ripetuto
 un 
\emph on
infinito
\emph default
 numero di volte, quanti colori distinti risultano, in media, dall'estrazione
 di R calzioni?
\end_layout

\begin_layout Standard
Ma nell'esempio appena descritto a cosa corrisponde il numero 
\emph on
infinite
\emph default
 di volte poi nel nostro modello di databse? Il modello appena visto (chiamato
 
\series bold
modello di Cadenas
\series default
) assume pagine di capacità 
\emph on
infinita
\emph default
 (si noti infatti che 
\begin_inset Formula $N_{t}$
\end_inset

 non figura da nessuna parte come argomento): un modello di questo tipo
 porta a 
\emph on
sottostimare
\emph default
 apprezzabilmente il valore corretto nel caso di pagine con meno di circa
 10 record (cioè in realtà il valore reale medio di pagine da caricare risulterà
 più alto, d'altronde è ovvio che se ho pagine che contengono un numero
 finito di record avrò bisogno di più pagine da caricare per riuscire ad
 avere tutti gli R record che rispondono alla query).
\end_layout

\begin_layout Standard
Nel caso che 
\begin_inset Formula $R=N_{t}$
\end_inset

 (cioè il numero di Record sia uguale al numero di tuple), la formula restituisc
e un valore di P (pagine da caricare) minore, infatti:
\begin_inset Formula 
\[
\Phi(N_{t},P)=P\cdot(1-(1-\frac{1}{P})^{N}\thickapprox P\cdot(1-e^{-\frac{N}{P}})
\]

\end_inset


\end_layout

\begin_layout Standard
Si veda in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cardenas"

\end_inset

) l'andamento della probabiltà nel modello di Cardenas.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cardenas"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename cardenas.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il modello di Cardenas, dunque, non tiene conto della capacità effettiva
 delle pagine (
\begin_inset Formula $C=\frac{N}{P}$
\end_inset

), cosa che il 
\series bold
modello di Yao
\series default
 invece fa.
 La sua derivazione considera tutti i modi possibili in cui si possono trovare
 allocati i 
\series bold
R
\series default
 record richiesti sulle 
\series bold
P
\series default
 pagine
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\dbinom{N}{R}$
\end_inset

 = numero di combinazioni possibili dei R record tra le N tuple
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\dbinom{N-C}{R}$
\end_inset

 = numero di combinazioni possibili dei R record tra le N tuple escludendo
 una pagina
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\dbinom{N}{R}-\dbinom{N-C}{R}$
\end_inset

 = numero di combinazioni possibili che interessano una determinata pagina
\end_layout

\begin_layout Enumerate
\begin_inset Formula $1-\frac{\dbinom{N-C}{R}}{\dbinom{N}{R}}$
\end_inset

 = probabilità che una determinata pagina contenga almeno un record
\end_layout

\begin_layout Standard
Moltiplicando ora il valore 4 per il numero di pagine otteniamo il valor
 medio del numero di pagine accedute
\begin_inset Formula 
\[
\Phi(R,N,C)=P\cdot\left(1-\frac{\dbinom{N-C}{R}}{\dbinom{N}{R}}\right)
\]

\end_inset

 Si veda in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:confrontodaticardenasyao"

\end_inset

) un confronto tra i modelli che mostra la probabilità di dover accedere
 ad una determinata pagina al crescere dei numero di Record [Dati della
 figura 
\begin_inset Formula $N=1000$
\end_inset

, 
\begin_inset Formula $P=250$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:confrontodaticardenasyao"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename confrontosudaticardenasyao.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nel caso di pagine con un numero variabile di record si puà dimostrare che
 la formula di 
\series bold
Yao
\series default
 sovrastima la probabilità.
 In generale se l'allocazione dei record non è casuale entrambi i modelli
 sovrastimano.
 Infine notiamo che se R (numero dei record) è grande, il calcolo della
 formula di Yao può richiedere tempi elevati
\begin_inset Formula 
\[
\Phi(R,N,C)=P\cdot(1-\prod_{i=1}^{R}\frac{N-C-i+1}{N-i+1})
\]

\end_inset

 Ecco dunque che la maggior parte di volte si preferisce utilizzare il modello
 di Cardenas per avere un calcolo veloce.
 
\series bold
NB
\series default
 Questi modelli sono utili al 
\emph on
dbms
\emph default
 poichè deve decidere a volte se è conveniente accedere ai dati in maniera
 sequenziale (direttamente sulle tabelle) oppure attraverso gli indici.
\end_layout

\begin_layout Paragraph
Costo dell'accesso con indice
\end_layout

\begin_layout Standard
Andiamo ora a vedere quale è il costo generale dell'accesso con indice.
 Notiamo che: 
\end_layout

\begin_layout Itemize
Il Costo Totale = Costo di Indice + Costo pagine dati (cioè il costo per
 trovare le entry sull'indice e poi caricare le pagine dati per avere i
 record)
\end_layout

\begin_layout Itemize
Il Costo di Indice = costo per la prima foglia + costo per leggere tutte
 le foglie (cioè il costo per trovare la foglia contenente la prima entry
 più il costo per leggere tutte le foglie a seguire) sequenzialmente fino
 a trovare la prima foglia che non contiene entry utili).
\end_layout

\begin_deeper
\begin_layout Itemize
Costo per la prima foglia = h-1
\end_layout

\begin_layout Itemize
Numero di foglie da dover leggere = 
\begin_inset Formula $\left\lceil L\cdot\frac{E_{k}}{K}\right\rceil $
\end_inset

(cioè la frazione di foglie che soddisfano il predicato): 
\begin_inset Formula $E_{k}$
\end_inset

 è il numero di chiavi che abbiamo nel predicato, N
\begin_inset script subscript

\begin_layout Plain Layout
K
\end_layout

\end_inset

è il numero di chiavi (distinte) totali, L è il numero totale di foglie
 dell'indice.
\end_layout

\end_deeper
\begin_layout Itemize
Il Costo pagine dati = 
\begin_inset Formula $E_{K}$
\end_inset

 volte (una per ogni chiave del predicato) la formula di Cardenas (o Yao):
 
\begin_inset Formula $E_{K}\cdot\Phi(\frac{N_{t}}{N_{k}},P)$
\end_inset

 dove 
\begin_inset Formula $\frac{N_{t}}{N_{k}}$
\end_inset

 rappresenta il numero di record per un certo valore di chiave.
\end_layout

\begin_layout Standard
Andiamo ora a confrontare (attraverso un Esempio) il costo di accesso con
 indice al costo di accesso sequenziale (cioè leggere tutte le pagine che
 contengono la tabella) che ricordiamo essere 
\begin_inset Formula $Costo\, Sequenziale=P$
\end_inset

.
\end_layout

\begin_layout Standard

\bar under
Esempio:
\end_layout

\begin_layout Itemize
File con 
\begin_inset Formula $N_{t}=10^{6}$
\end_inset

 numero di tuple distribuiti su 
\begin_inset Formula $P=40000$
\end_inset

 pagine.
\end_layout

\begin_layout Itemize
Indice unclustered (non ordinato come il file/tabella) su un campo con 
\begin_inset Formula $N_{K}=10^{5}$
\end_inset

 valori di chiave (distinti), con 
\begin_inset Formula $L=7045$
\end_inset

 foglie e di altezza 
\begin_inset Formula $h=4$
\end_inset

 (Si noti come l'altezza dell'albero sia del tutto ininfluente).
\end_layout

\begin_layout Standard
Come si vede dalla figura (Fig.
 ) all'aumentare del numero di chiavi che abbiamo nel predicato 
\begin_inset Formula $E_{k}$
\end_inset

, superando già il 10% (100.000) del numero totale di chiavi N=1.000.000, conviene
 decisamente accedere ai dati in maniera sequenziale.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:sequentialvsindex"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename indexvssequential.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Manca ora solo controllare il costo per ricerca con intervallo 
\begin_inset Formula $A\epsilon[x,y]$
\end_inset

.
\end_layout

\begin_layout Standard
Vediamo di nuovo il costo con indice, poichè il costo di accesso sequenziale
 rimane sempre uguale a 
\series bold
P
\series default
.
\end_layout

\begin_layout Itemize
Costo totale = costo indice + costo pagine dati
\end_layout

\begin_layout Itemize
Costo indice = costo per la prima foglia + costo per leggere 
\begin_inset Quotes eld
\end_inset

sequenzialmente
\begin_inset Quotes erd
\end_inset

 le foglie (cioè il costo per trovare la foglia contenente la prima entry
 più il costo per leggere sequenzialmente le foglie fino a trovare la prima
 foglia che non contiene entry utili).
\end_layout

\begin_deeper
\begin_layout Itemize
Costo per la prima foglia = h-1
\end_layout

\begin_layout Itemize
Numero di foglie = 
\begin_inset Formula $\left\lceil L\cdot fs\right\rceil $
\end_inset

 dove 
\emph on
fs
\emph default
 è il fattore di selettività del predicato (
\begin_inset Formula $fs=\frac{y-x}{max(A)-min(A)})$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Costo pagine dati: 
\begin_inset Formula $\left\lceil fs\cdot E_{K}\right\rceil $
\end_inset

 volte la formula di Cardenas (o Yao):
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $=\left\lceil fs\cdot E_{K}\right\rceil \cdot\Phi(\frac{N}{K},P)$
\end_inset

 se l'attributo non è di ordinamento
\end_layout

\begin_layout Itemize
\begin_inset Formula $=\left\lceil fs\cdot E_{K}\right\rceil $
\end_inset

 se l'attributo è di ordinamento
\end_layout

\end_deeper
\begin_layout Subsection
Organizzazione hash
\end_layout

\begin_layout Standard
A differenza delle tecniche di tipo 
\begin_inset Quotes eld
\end_inset

tabellare
\begin_inset Quotes erd
\end_inset

 in cui l'associazione <chiave, RID> è mantenuta in forma esplicita, una
 organizzazione hash 
\emph on
utilizza una funzione hash 
\series bold
\emph default
H
\series default
, che 
\emph on
trasforma ogni valore di chiave in un indirizzo
\emph default
.
 La funzione hash in breve è una funzione che data una 
\emph on
chiave K 
\emph default
restituisce automaticamente la RID
\emph on
 
\emph default
dei record che hanno quel valori di chiave K (si veda figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:hashinbreve"

\end_inset

).
 Piccola osservazione: data la figura, invece di mettere l'hash function
 nel box centrale avessimo messo una I di Index Table avremo comunque i
 RID dei record associati.
 Questo a sottolineare che queste sono solo strutture indirizzate a dare
 lo stesso risultato (RID) ma attraverso cammini d'accesso diversi.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:hashinbreve"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename funzionehashinbreve.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Salvo casi particolari, le funzioni 
\emph on
hash
\emph default
 non sono 
\emph on
iniettive
\emph default
, cioè date due chiavi diverse non sempre si ottengono funzioni hash diverse
 (
\begin_inset Formula $k_{1}\neq k_{2}\nRightarrow H(k_{1})\neq H(k_{2})$
\end_inset

).
 Quando questo accade si dice che si è verificata una 
\series bold
collisione 
\series default
cioè quando date due chiavi 
\begin_inset Formula $k_{1}$
\end_inset

 e 
\begin_inset Formula $k_{2}\neq k_{1}$
\end_inset

accade che 
\begin_inset Formula $H(k_{1})=H(k_{2})$
\end_inset

.
 Una funzione hash che non genera collisioni si dice 
\emph on
perfetta
\emph default
.
\end_layout

\begin_layout Standard
Sostanzialmente che cosa è un indice hash? Detto in breve è un insieme di
 
\emph on
pagine
\emph default
.
 Ogni indirizzo generato dalla funzione 
\emph on
hash
\emph default
 individua una pagina logica chiamata 
\series bold
bucket
\series default
, quindi data una chiave k la funzione hash non fa altro che individuare
 l'indirizzo della pagina logica che conterrà il RID (o le RID).
 Se confrontato l'indice hash con un indice tabellare, il vantaggio della
 struttura hash è che se la funzione è efficiente, quindi calcolarla è veloce
 (cioè non chiede di dover leggere una pagina da disco), il costo della
 struttura hash è 1.
\end_layout

\begin_layout Standard
Il numero di elementi (per elementi si possono intendere sia valori di chiave
 se l'organizzazione è un indice ma anche i record dati se l'organizzazione
 è primaria) che possono essere allocati nello stesso bucket determina la
 
\emph on
capacità 
\series bold
C 
\series default
\emph default
del bucket stesso.
\end_layout

\begin_layout Standard
L'area di memoria costituita dai bucket indirizzabili dalla funzione hash
 è detta 
\emph on
area primaria
\emph default
, cioè è il codominio della funzione costituito dall'insieme degli indirizzi
 che la funzione può dare in output.
 Se una chiave viene assegnata a un bucket contenente già 
\emph on
C chiavi
\emph default
 si ha un 
\series bold
overflow
\series default
: la presenza di overflow può richiedere, a seconda della specifica organizzazio
ne, l'uso di un'area di memoria separata, detta appunto 
\emph on
area di overflow.
\end_layout

\begin_layout Standard
Una funzione hash deve essere suriettiva (cioè deve poter raggiungere tutti
 gli indirizzi del codominio, altrimenti si avrebbero 
\emph on
bucket
\emph default
 inutili) e quindi generare 
\series bold
P
\series default
 indirizzi tanti quanti sono i bucket dell'area primaria.
 Se il valore di 
\series bold
P
\series default
 è, per una data organizzazione, 
\emph on
costante
\emph default
 allora l'organizzazione è detta 
\emph on
statica
\emph default
 e in questo caso il dimensionamento dell'area primaria è parte integrante
 del progetto dell'organizzazione.
 Al contrario, se l'area primaria può espandersi e contrarsi (dunque P è
 dinamico, cioè il numero dei bucket può crescere e/o diminuire) per meglio
 adattarsi al volume effetivo dei dati da gestire allora l'organizzazione
 è detta 
\emph on
dinamica
\emph default
 (in caso dimanico sono necessarie più funzioni hash poichè se il codominio
 aumenta o diminuisce c'è bisogno di una funzione hash diversa per ogni
 codominio possibile).
 Le prime organizzazioni hash dinamiche sono nate intorno alla fine degli
 anni 70 mentre quelle statiche sono state sviluppate a partire dagli anni
 50.
\end_layout

\begin_layout Subsubsection
Caratteristiche organizzazioni hash
\end_layout

\begin_layout Standard
Sia che si tratti di una organizzazione statica, sia che sia dinamica, ci
 sono alcuni aspetti comuni che meritano considerazione:
\end_layout

\begin_layout Itemize
La scelta della funzione hash H
\end_layout

\begin_layout Itemize
La politica di gestione degli overflow
\end_layout

\begin_layout Itemize
La 
\emph on
capacità C
\emph default
 dei bucket dell'area primaria
\end_layout

\begin_layout Itemize
La 
\emph on
capacita C
\begin_inset script subscript

\begin_layout Plain Layout

\emph on
OV
\end_layout

\end_inset


\emph default
 dei bucket dell'eventuale area di overflow (non necessariamente è uguale
 a C)
\end_layout

\begin_layout Itemize
L'utilizzazione della memoria allocata.
\end_layout

\begin_layout Standard
Normalmente le funzioni hash sono applicate a campi 
\emph on
primari 
\emph default
(ma l'applicazione ai campi secondari è possibile) e generalmente non preservano
 l'ordine (cioè non sono funzioni monotone).
 Non preservare l'ordine significa che se ho due valori vicini (esempio
 casa e case) il risultato della funzione hash potrà avere valori arbitrariament
e distanti: questo incide fortemente in termini di efficienza nelle interrogazio
ni di intervallo.
\end_layout

\begin_layout Subsubsection
Static Hashing
\end_layout

\begin_layout Standard
Mostriamo come prima cosa un semplice esempio di organizzazione hash statica
 (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:statichashexample"

\end_inset

) in cui:
\end_layout

\begin_layout Itemize
Le chiavi sono numeri naturali
\end_layout

\begin_layout Itemize
L'area primaria consiste in P=5 (numero di bucket/pagine) di capacità C=5
\end_layout

\begin_layout Itemize
La funzione hash è siffata; 
\begin_inset Formula $H(k_{i})=k\%5$
\end_inset

 (
\emph on
k mod 5
\emph default
)
\end_layout

\begin_layout Itemize
Gli overflow sono gestiti allocando, per ogni bucket dell'area primaria,
 uno o più bucket di overflow di capacità C
\begin_inset script subscript

\begin_layout Plain Layout
OV
\end_layout

\end_inset

=5 collegati a lista.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:statichashexample"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename statichashexample.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Visto un semplice esempio controlliamo subito l'
\series bold
analisi dei costi
\series default
.
\begin_inset Newline newline
\end_inset

Un file 
\emph on
hash
\emph default
 con N record, con capacità di bucket C=COV, con area primaria avente P
 bucket, comporta, nell'ipotesi di perfetta ripartizione dei record (cioè
 i record vengono ripartiti esattamente in tutti i bucket) sullo spazio
 dei P indirizzi, che:
\end_layout

\begin_layout Itemize
ogni indirizzo è generato 
\begin_inset Formula $\frac{N}{P}$
\end_inset

 volte
\end_layout

\begin_layout Itemize
ogni catena (si intende l'insieme dei bucket collegati sia in area primaria
 che in overflow) consiste di 
\begin_inset Formula $\frac{N}{P\cdot C}$
\end_inset

 bucket
\end_layout

\begin_layout Standard
Il costo di ricerca di un record risulta pertanto propozionale a 
\begin_inset Formula $\frac{N}{P\cdot C}$
\end_inset

 poichè, data una chiave, il RID del record che cerchiamo potrebbe trovarsi
 all'ultimo bucket situato nell'area di overflow.
 
\bar under
Esempio:
\bar default
 
\begin_inset Formula $N=10^{6}$
\end_inset

, 
\begin_inset Formula $C=10$
\end_inset

, 
\begin_inset Formula $P=25000$
\end_inset

 Una ricerca (con successo) accede in media a 2 bucket (ho eseguito il calcolo
 di 
\begin_inset Formula $\frac{N}{P\cdot C}$
\end_inset

) e nel caso peggiore a 4 bucket (l'ultimo in area di overflow).
 Questo risulta essere anche il numero di operazioni I/O se si assume che
 ogni bucket può essere letto con una sola operazione.
\end_layout

\begin_layout Subsubsection
Funzioni hash
\end_layout

\begin_layout Standard
Una funzione hash è 
\emph on
una trasformazione 
\emph default
(suriettiva) 
\emph on
dallo spazio K delle chiavi allo spazio 
\begin_inset Formula $\{0,\ldots,P-1\}$
\end_inset

 degli indirizzi
\emph default
.
 L'ipotesi che un arbitrario sottoinsieme di K si ripartisca su P indirizzi
 in maniera perfettamente omogenea è una pura astrazione, di scarsa utilità
 per analizzare le prestazioni ottenibili dalle diverse organizzazioni hash.
\end_layout

\begin_layout Standard
Il caso ideale rispetto al quale è ragionevole confrontare una speifica
 funzione hash H è quello di distribuzione uniforme sullo spazio degli indirizzi
, in cui, per ogni sotto insieme di K chiavi, ognuno dei P indirizzi ha
 la stessa probabilità 
\begin_inset Formula $\frac{1}{P}$
\end_inset

 di essere generato.
 Controlliamo dunque la funzione hash con distribuzione uniforme.
\end_layout

\begin_layout Paragraph
Funzione hash con distribuzione uniforme
\end_layout

\begin_layout Standard
Nel caso ideale il numero di chiavi 
\begin_inset Formula $X_{j}$
\end_inset

 assegnate al 
\emph on
j-esimo
\emph default
 bucket seguen una distribuzione binomiale
\begin_inset Formula 
\[
P(X_{j}=x_{j})=\dbinom{N}{x_{j}}\cdot(\frac{1}{P})^{x_{j}}\cdot(1-\frac{1}{P})^{N-x_{j}}
\]

\end_inset


\end_layout

\begin_layout Standard
con valor medio μ e varianza 
\begin_inset Formula $\text{σ}^{2}$
\end_inset

 dati da
\begin_inset Formula $\text{μ}=\frac{N}{P}$
\end_inset

 e 
\begin_inset Formula $\text{σ}^{2}=\frac{N}{P}\cdot(1-\frac{1}{P})$
\end_inset

 in cui né μ nè 
\begin_inset Formula $\sigma^{2}$
\end_inset

 dipendono dallo specifico bucket.
 Come si nota per 
\begin_inset Formula $P\gg1$
\end_inset

 il rapporto 
\begin_inset Formula $\frac{\sigma}{\sqrt{\mu}}\sim1$
\end_inset

.
\end_layout

\begin_layout Paragraph
Qualità di una funzione hash
\end_layout

\begin_layout Standard
Nel caso di funzioni hash 
\emph on
reali
\emph default
 le prestazioni variano al variare dello specifico set di chiavi.
 Ad esempio la funzione hash 
\begin_inset Formula $H(k_{i})=k_{i}\%P$
\end_inset

 è una 
\begin_inset Quotes eld
\end_inset

buona
\begin_inset Quotes erd
\end_inset

 funzione ma nel caso il set di chiavi sia
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\{0,P,2P,3P,\ldots,N\cdot P\}$
\end_inset

 alloca tutte le chiavi nel bucket 0.
 
\series bold
NB 
\series default
Per ogni funzione hash esiste un set di chiavi che dà luogo a pessime prestazion
i nel caso peggiore.
 Nel caso 
\begin_inset Quotes eld
\end_inset

medio
\begin_inset Quotes erd
\end_inset

 tuttavia, considerando arbitrari sottoinsiemi dell'insieme K di chiavi
 e file dati reali, si osserva che le diverse funzioni hash si comportano
 effettivamente in modo diverso.
\end_layout

\begin_layout Standard
Un criterio adeguato di valutazione di una funzione 
\emph on
H
\emph default
, riferito ad un particolare insieme di chiavi 
\emph on
K
\emph default
, è dato dall'analisi della sua 
\series bold
degenerazione 
\begin_inset Formula $\frac{\sigma}{\sqrt{\mu}}$
\end_inset

 
\series default
dove
\begin_inset Formula 
\[
\mu=\sum_{j=0}^{P-1}\frac{x_{j}}{P}=\frac{N}{P}
\]

\end_inset


\begin_inset Formula 
\[
\sigma^{2}=\sum_{j=0}^{P-1}\frac{(x_{j}-\mu)^{2}}{P}
\]

\end_inset

 sono calcolati su tutti i 
\series bold
P 
\series default
bucket e 
\begin_inset Formula $x_{j}$
\end_inset

 è il numero di record osservato nel j-esimo bucket.
 Quanto più bassa è la degenerazione tanto migliore è il comportamento della
 funzione hash.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph
Esempi Funzioni Hash
\end_layout

\begin_layout Standard
Elencheremo di seguito alcuni fra i più comuni esempi di funzione hash.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subparagraph
Mid Square
\end_layout

\begin_layout Standard
La chiave k viene moltiplicata per sé stessa, viene dunque estratto un numero
 di cifre centrali pari a quelle di P-1, il numero ottenuto viene dunque
 normalizzato a P.
\end_layout

\begin_layout Standard
Ad esempio con la chiave 
\begin_inset Formula $k=145142$
\end_inset

 si ottiene 
\begin_inset Formula $k^{2}=145142^{2}=21066200164$
\end_inset

 e con numero di bucket 
\begin_inset Formula $P=8000$
\end_inset

 la normalizzazione produce 
\begin_inset Formula $\left\lfloor 6620\cdot0.8\right\rfloor =5296$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subparagraph
Shifting
\end_layout

\begin_layout Standard
La chiave k viene suddivisa in un certo numero di sotto parti, ognuna costituita
 da un numero di cifre pari a P-1, infine si sommano le parti e si normalizza
 il risultato.
\end_layout

\begin_layout Standard
Ad esempio con la chiave 
\begin_inset Formula $k=14514387$
\end_inset

 si ottengono le sotto parti 
\begin_inset Formula $k_{1}=387$
\end_inset

, 
\begin_inset Formula $k_{2}=514$
\end_inset

 e 
\begin_inset Formula $k_{3}=14$
\end_inset

, se ne fa la somma 
\begin_inset Formula $k_{1}+k_{2}+k_{3}=387+514+14=915$
\end_inset

 e con un numero di bucket 
\begin_inset Formula $P=800$
\end_inset

 la normalizzazione produce 
\begin_inset Formula $\left\lfloor 915\cdot0.8\right\rfloor =732$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subparagraph
Folding
\end_layout

\begin_layout Standard
La chiave k viene suddivisa come allo stesso modo in cui accadeva nello
 
\series bold
shifting
\series default
, però ora le parti vengono 
\begin_inset Quotes eld
\end_inset

ripiegate
\begin_inset Quotes erd
\end_inset

 (si immagini di avere un foglio e piegare verso l'interno man mano il foglio
 stesso) e sommate, infine si normalizza il risultato.
\end_layout

\begin_layout Standard
Ad esempio con 
\begin_inset Formula $k=14514387$
\end_inset

 si ottengono le sotto parti 
\begin_inset Formula $k_{1}=783$
\end_inset

 (prima 
\begin_inset Quotes eld
\end_inset

ripiegatura
\begin_inset Quotes erd
\end_inset

, come si vede è la cifra 387 scritta al contrario), 
\begin_inset Formula $k_{2}=514$
\end_inset

 (la seconda non viene ripiegata, proprio come in un foglio accade che la
 seconda parte permane integra) e 
\begin_inset Formula $k_{3}=41$
\end_inset

 (ultima 
\begin_inset Quotes eld
\end_inset

ripiegatura
\begin_inset Quotes erd
\end_inset

, è l'opposto di 14); se ne fa la somma 
\begin_inset Formula $k_{1}+k_{2}+k_{3}=783+514+41=1338$
\end_inset

 e con un numero di bucket 
\begin_inset Formula $P=800$
\end_inset

 la normalizzazione produce 
\begin_inset Formula $1338\%800=538\longrightarrow\left\lfloor 538\cdot0.8\right\rfloor =430$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subparagraph
Divisione
\end_layout

\begin_layout Standard
La chiave 
\emph on
numerica
\emph default
 k viene divisa per un numero Q e l'indirizzo è ottenuto considerando il
 resto (il 
\emph on
mod
\emph default
 o %), cioè 
\begin_inset Formula $H(k)=k\%Q=k\, mod\, Q$
\end_inset

.
 Per la scelta di Q ci sono alcune linee guida pratiche:
\end_layout

\begin_layout Itemize
Q è il più grande 
\emph on
numero primo
\emph default
 minore o uguale a P (numero di bucket)
\end_layout

\begin_layout Itemize
Q è non primo, minore o uguale a P, con nessun 
\emph on
fattore primo 
\emph default
minore di 20
\end_layout

\begin_layout Itemize
Se 
\begin_inset Formula $Q<P$
\end_inset

 si deve porre 
\begin_inset Formula $P=Q$
\end_inset

 per non perdere la suriettività della funzione hash (poichè tutti i bucket
 superiori a 
\begin_inset Formula $P-Q$
\end_inset

 risulterebbero non raggiungibili).
\end_layout

\begin_layout Subsubsection
Chiavi alfanumerica
\end_layout

\begin_layout Standard
Fino ad ora abbiamo sempre pensato e usato chiavi 
\emph on
numeriche
\emph default
: questa semplificazione però non è attuabile in pratica, infatti, come
 sappiamo, gli attributi alfanumerici fanno da padroni nei database.
 Si rivela dunque necessario trattare le stringhe 
\emph on
alfanumeriche
\emph default
.
\end_layout

\begin_layout Standard
Una chiave 
\emph on
alfanumerica
\emph default
 ha bisogno di una fase preliminare di conversione per essere poi realmente
 gestita attraverso funzioni hash.
\begin_inset Newline newline
\end_inset

Uno dei metodi più comuni è quello di stabilire
\end_layout

\begin_layout Itemize
Un alfabeto A a cui appertengono i caratterei delle stringhe
\end_layout

\begin_layout Itemize
Una funzione 
\series bold
biettiva
\series default
 
\emph on
ord
\emph default
(
\begin_inset space ~
\end_inset

) che associa ad ogni elemento dell'alfabeto un intero appartenente all'interval
lo 
\begin_inset Formula $[1,\,|A|]$
\end_inset


\end_layout

\begin_layout Itemize
Una 
\emph on
base b 
\emph default
di conversione
\end_layout

\begin_layout Standard
Una stringa 
\begin_inset Formula $S=s_{n-1},\ldots,s_{i},\ldots,s_{0}$
\end_inset

 viene dunque convertita in una 
\emph on
chiave numerica
\emph default
 nel seguente modo
\begin_inset Formula 
\[
k(S)=\sum_{i=0}^{n-1}ord(s_{i})\cdot b^{i}
\]

\end_inset


\end_layout

\begin_layout Standard
Facciamo un semplice esempio.
\begin_inset Newline newline
\end_inset

Scegliamo come alfabeto 
\begin_inset Formula $A=\{a,b,\ldots,z\}$
\end_inset

 di cardinalità 
\begin_inset Formula $|A|=26$
\end_inset

 a cui associamo la nostra funzione 
\emph on
biettiva ord
\emph default
(
\begin_inset space ~
\end_inset

) a valori nell'intervallo 
\begin_inset Formula $[1,\,26]$
\end_inset

.
 Scegliamo come base 
\begin_inset Formula $b=32$
\end_inset

 e vediamo come ottenere la nostra chiave numerica della stringa 
\begin_inset Quotes eld
\end_inset

indice
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
k("indice")=5\cdot32^{5}+14\cdot32^{4}+4\cdot32^{3}+9\cdot32^{2}+3\cdot32^{1}+5\cdot32^{0}=316810341
\]

\end_inset


\end_layout

\begin_layout Standard
Esistono anche metodi più semplici per la conversione di stringhe alfanumeriche
 che non fanno uso di alcuna 
\emph on
base
\emph default
 quali ad esempio
\begin_inset Formula 
\[
k(S)=\sum_{i=0}^{n-1}ord(s_{i})
\]

\end_inset


\end_layout

\begin_layout Standard
in cui 
\emph on
ord
\emph default
(
\begin_inset space ~
\end_inset

) ricopre lo stesso ruolo prima descritto.
 Questi metodi sono più facili da utilizzare ma funzionano meno bene, in
 quanto generano la stessa chiave numerica a partire da anagrammi diversi
 di una stessa stringa (ad esempio 
\emph on
caso
\emph default
 e 
\emph on
cosa
\emph default
 produrranno la stesssa chiave numerica).
\end_layout

\begin_layout Paragraph
Scelta della base
\end_layout

\begin_layout Standard
Se si dovesse scegliere come funzione 
\emph on
hash
\emph default
 il metodo della 
\series bold
divisione
\series default
 si riscontrano seri problemi se la 
\emph on
base b
\emph default
 ha 
\emph on
fattori primi in comune 
\emph default
con 
\series bold
P 
\series default
(numero dei bucket).
 Per chiarire facciamo subito un esempio.
 
\begin_inset Formula $A=\{a,b,\ldots,z\}$
\end_inset

, 
\begin_inset Formula $b=32$
\end_inset

, 
\begin_inset Formula $P=512$
\end_inset

.
 Come si vede 32 e 512 hanno uno stesso fattore primo in comune (il 2).
 Calcoliamo ora le chiavi numeriche di 
\begin_inset Quotes eld
\end_inset


\emph on
folder
\emph default

\begin_inset Quotes erd
\end_inset

 e di 
\begin_inset Quotes eld
\end_inset


\emph on
primer
\emph default

\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
I valori di ord( ) delle due parole producono il vettore di coefficenti
\begin_inset Formula 
\[
ord("folder")=(6,15,12,4,5,18)
\]

\end_inset


\begin_inset Formula 
\[
ord("primer")=(16,18,9,13,5,18)
\]

\end_inset


\end_layout

\begin_layout Standard
e calcoliamo ora anche i valori di chiave numeriche
\begin_inset Formula 
\[
k("folder")=215'452'722
\]

\end_inset


\begin_inset Formula 
\[
k("primer")=556'053'682
\]

\end_inset


\end_layout

\begin_layout Standard
e infine calcoliamo la funzione hash dei valori numerici
\begin_inset Formula 
\[
H(215'452'722)=178
\]

\end_inset


\begin_inset Formula 
\[
H(556'053'682)=178
\]

\end_inset


\end_layout

\begin_layout Standard
In questo cosa, attraverso alcune proprietà dell'operatore %, si può notare
 che il valore di 
\begin_inset Formula $H(k(S))$
\end_inset

 è determinato solo dagli ultimi due caratteri.
 Per capire perchè insorge questo tipo di problema è necessario rifarsi
 ad una serie di proprietà dell'operatore modulo (% o mod).
 Il caso più semplice da considerare è quello in cui 
\series bold
P 
\series default
(numero di bucket) è un multiplo di 
\emph on
b
\emph default
 (base), ovvero 
\begin_inset Formula $P=\alpha\cdot b$
\end_inset

 con 
\begin_inset Formula $\alpha$
\end_inset

 valore intero.
 Esisterà un valore 
\emph on
y
\emph default
 tale per cui 
\begin_inset Formula $b^{y}\,\%\,(\alpha\cdot b)=0$
\end_inset

.
 Poichè per l'operatore % vale la seguente proprietà (utile per il calcolo
 di k(S))
\begin_inset Formula 
\[
H(k(S))=\left[\sum_{i=0}^{n-1}ord(s_{i})\cdot b^{i}\right]\%(\alpha\cdot b)=\left(\sum_{i=0}^{n-1}\left[\left(ord(s_{i})\cdot b^{i}\right)\%(\alpha\cdot b)\right]\right)\%(\alpha\cdot b)
\]

\end_inset


\end_layout

\begin_layout Standard
i caratteri da 
\begin_inset Formula $s_{n-1}$
\end_inset

 a 
\begin_inset Formula $s_{y}$
\end_inset

 danno contributo uguale a zero al valore 
\begin_inset Formula $H(k(S))$
\end_inset

 (nell'esempio prima mostrato 
\begin_inset Formula $y=2$
\end_inset

) e quindi la stringa 
\begin_inset Quotes eld
\end_inset

utile
\begin_inset Quotes erd
\end_inset

 è lunga solo 
\emph on
y
\emph default
 caratteri.
 Con base 
\begin_inset Formula $b=26$
\end_inset

 si ganno problemi quando P ha come fattori 13 e 2.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Viene mostrato di seguito un esperimento eseguito da 
\emph on
Mullin
\emph default
 nel 1991 facendo uso come set di chiavi 
\emph on
k
\emph default
 tutte le parole di 6 caratteri costruite sull'alfabeto 
\begin_inset Formula $A=\{a,b,\ldots,z\}$
\end_inset

 usate dallo spelling checker di Unix.
 La figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:miller"

\end_inset

) si riferisce al caso di 
\emph on
base b
\emph default
=26 con P che varia tra 420 e 520.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:miller"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename miller.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
I picchi della distribuzione si hanno per valori di P multipli di 13.
 In particolare il massimo si ottiene per 
\begin_inset Formula $P=507=13\cdot13\cdot3$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Parametri
\end_layout

\begin_layout Paragraph
Fattore di caricamento
\end_layout

\begin_layout Standard
Supponiamo di aver scelto la nostra funzione hash statica e di cominciare
 a pensare quanto far grande la nostra organizzazione ad hash: una prima
 idea potrebbe essere quella, una volta avuta la stima del numero N di record,
 di avere il numero di bucket P in modo tale che i record N vadano ad occupare
 
\begin_inset Quotes eld
\end_inset

completamente
\begin_inset Quotes erd
\end_inset

 i nostri bucket.
 In realtà potremmo pensare di lasciare 
\begin_inset Quotes eld
\end_inset

un po' di spazio
\begin_inset Quotes erd
\end_inset

 disponibile nei nostri bucket, cioè di realizzare un'area primaria più
 grande del necessario, per tentare di evitare l'overflow infatti potrebbe
 convenire avere dello spazio vuoto in più piuttosto che rischiare l'immediato
 overflow.
\end_layout

\begin_layout Standard
Data una stima del numero N di record da gestire e fissata la capacità C
 dei bucket, la scelta di un determinato 
\emph on
fattore di caricamento d
\emph default
 determina il numero di bucket 
\series bold
P
\series default
 in area primaria, infatti al diminuire di 
\emph on
d
\emph default
 diminuisce la percentuale di record in overflow: di conseguenza non è consiglia
bile utilizzare fattori di caricamento elevati.
 Valori tipici che rappresentano un buon compromesso tra utilizzazione della
 memoria e costi di esercuzioni delle operazioni si hanno nell'intervallo
 [0.7, 0.8].
\end_layout

\begin_layout Paragraph
Capacità dei bucket
\end_layout

\begin_layout Standard
È evidente che avere una capacità 
\emph on
C
\emph default
 dei bucket tale da richiedere più operazioni di I/O per il trasferimento
 di un singolo bucket non comporta alcun vantaggio.
 Il motivo per cui invece è conveniente avere bucket di capacità 
\begin_inset Formula $C>1$
\end_inset

 è essenzialmente legato alla relazione esistente tra C e tra la percentuale
 di record costretti ad andare in 
\emph on
overflow
\emph default
.
 Sotto le ipotesi di una funzione hash ideale e di gestione degli overflow
 in un'area separata, all'aumentare di 
\emph on
C
\emph default
 (e a parità di fattore di caricamento 
\emph on
d
\emph default
) la percentuale di record in overflow diminuisce (sperimentalmente si vede
 che il risultato è valido anche nel caso di funzioni hash non ideali),
 quindi si potrebbe pensare anche di avere C maggiore anche della grandezza
 della pagina con la supposizione però di poter scrivere i blocchi in maniera
 contigua (in modo da evitare il tempo di latenza).
\end_layout

\begin_layout Standard
Poichè un aumento del numero di record in 
\emph on
overflow 
\emph default
tende a deteriorare le prestazioni è consigliabe lavorare con bucket di
 capacità C
\emph on
 massima 
\emph default
soggetti però ai seguenti vincoli:
\end_layout

\begin_layout Itemize
C deve essere tale che la lettura di un bucket deve comportare ad una singola
 richiesta di I/O (quindi per ovviare al problema dei blocchi contigui)
\end_layout

\begin_layout Itemize
C deve essere tale che il trasferimento di un bucket di capacità C deve
 poter avvenire in un tempo minore rispetto al trasferimento di due bucket
 di capacità 
\begin_inset Formula $\bar{C}<C$
\end_inset


\end_layout

\begin_layout Subsubsection
Overflow
\end_layout

\begin_layout Standard
Ci occupiamo ora della gestione degli 
\emph on
overflow
\emph default
 causati dalla presenza di un numero di elementi nel bucket j-esimo di 
\emph on
capacità C
\emph default
 superiore al 
\emph on
fattore di caricamento d.
\end_layout

\begin_layout Paragraph
Numero medio di overflow
\end_layout

\begin_layout Standard
Il numero di volte che una funzione di 
\emph on
hash 
\emph default
genera lo stesso indirizzo 
\emph on
j
\emph default
 è riconducibile a una variabile aleatoria 
\emph on

\begin_inset Formula $X_{j}$
\end_inset

 
\emph default
con
\emph on
 distribuzione binomiale.
 
\emph default
Il numero medio di overflow del 
\emph on
j
\emph default
-esimo bucket è 
\begin_inset Formula 
\[
OV_{j}(C)=\sum_{x_{j}=C+1}^{N}\left(x_{j}-C\right)\cdot Pr\{X_{j}=x_{j}\}
\]

\end_inset

 che non dipende dal 
\emph on
j
\emph default
-esimo bucket specifico ma dalla probabilità che la funzione hash scelta
 generi l'indirizzo esattamente 
\begin_inset Formula $x_{j}$
\end_inset

 volte.
 Per brevità da ora in poi scriveremo Pr(x) al posto di 
\begin_inset Formula $Pr\{X_{j}=x_{j}\}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Distribuzione degli overflow
\end_layout

\begin_layout Standard
Il numero totale di 
\emph on
overflow
\emph default
 si ottiene sommando il numero medio degli overflow prima citato su tutti
 i P bucket, dunque
\begin_inset Formula 
\[
OV(C)=\sum_{j=0}^{P-1}OV_{j}(C)=P\cdot\sum_{x_{j}=C+1}^{N}\left[\left(x_{j}-C\right)\cdot Pr(x)\right]
\]

\end_inset


\end_layout

\begin_layout Standard
Per valori elevati di N (numero dei record) e P (numero dei bucket) è possibile
 approssimare la distribuzione binomiale con la distribuzione di 
\emph on
Poisson
\emph default
:
\begin_inset Formula 
\[
Pr(x)=\dbinom{N}{x}\cdot\left(\frac{1}{P}\right)^{x}\cdot\left(1-\frac{1}{P}\right)^{N-x}\approx\left(\frac{N}{P}\right)^{x}\frac{e^{-\frac{N}{P}}}{x!}
\]

\end_inset


\end_layout

\begin_layout Standard
Essendo inoltre 
\begin_inset Formula $P=\frac{N}{C\cdot d}$
\end_inset

 otteniamo sostituendo
\begin_inset Formula 
\[
Pr(x)\thickapprox\left(C\cdot d\right)^{x}\cdot\frac{e^{-C\cdot d}}{x!}
\]

\end_inset

 
\begin_inset Formula $C\cdot d$
\end_inset

 denota il numero medio di elementi in un bucket.
\end_layout

\begin_layout Paragraph
Numero totale di overflow
\end_layout

\begin_layout Standard
Il numero totale di 
\emph on
overflow
\emph default
 si ottiene quindi sostituendo alle formule le approssimazioni prima scritte
 ottenendo
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
OV(C)\thickapprox P\cdot\sum_{x=C+1}^{N}\left[\left(x-C\right)\cdot\frac{(C\cdot d)^{x}\cdot e^{-(C\cdot d)}}{x!}\right]
\]

\end_inset


\begin_inset Newline newline
\end_inset

cambiando variabile in 
\begin_inset Formula $i=x-C$
\end_inset

 otteniamo
\begin_inset Formula 
\[
OV(C)\thickapprox P\cdot\frac{\left(C\cdot d\right)^{C+1}\cdot e^{-(C\cdot d)}}{C!}\cdot\sum_{i=1}^{N-C}\frac{i\cdot C^{i-1}\cdot d^{i-1}}{(C+1)\cdot(C+2)\cdot\ldots\cdot(C+i)}
\]

\end_inset


\begin_inset Newline newline
\end_inset

e ricordando nuovamente che 
\begin_inset Formula $P=\frac{N}{C\cdot d}$
\end_inset

 e sostituendo otteniamo
\begin_inset Formula 
\[
OV(C)\thickapprox N\cdot\frac{\left(C\cdot d\right)^{C}\cdot e^{-(C\cdot d)}}{C!}\cdot f(C,d)
\]

\end_inset

 dove 
\begin_inset Formula $f(C,d)$
\end_inset

 è la sommatoria presente nella formula precedente (che si nota essere una
 funzione solo della capacità C e del fattore di riempimento d)
\end_layout

\begin_layout Standard
Mostriamo dunque un grafico (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempionumeroverflow"

\end_inset

) in cui viene raffigurato l'andamento degli overflow al variare della 
\emph on
capacità C
\emph default
 e del 
\emph on
fattore di riempimento d.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempionumeroverflow"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempionumeroverflow.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Gestione degli overflow
\end_layout

\begin_layout Standard
I metodi studiati per la gestione degli 
\emph on
overflow
\emph default
 mirano a ridurre al minimo gli accessi a bucket necessari per reperire
 il record cercato.
 Esistono sostanzialmente due strategie:
\end_layout

\begin_layout Enumerate
Metodi di 
\series bold
concatenamento
\series default
 (chaining) i quali:
\end_layout

\begin_deeper
\begin_layout Enumerate
Utilizzano puntatori (per sapere dove reperire i bucket overflow)
\end_layout

\begin_layout Enumerate
Possono usare o meno l'area di overflow
\end_layout

\end_deeper
\begin_layout Enumerate
Metodi di 
\series bold
indirizzamento aperto
\series default
 (open addressing) i quali:
\end_layout

\begin_deeper
\begin_layout Enumerate
Non fanno uso di puntatori, ma utilizzano una famiglia di funzioni hash
\end_layout

\begin_layout Enumerate
Usano bucket in area primaria per memorizzare i record in overflow
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph
Metodi di concatenamento
\end_layout

\begin_layout Standard
I metodi di concatenamento possono differenziarsi a seconda dell'utilizzo
 o meno dell'area di overflow.
 Guardiamo nel dettaglio entrambi i metodi.
\end_layout

\begin_layout Subparagraph
Concatenamento in area primaria
\end_layout

\begin_layout Standard
Il concatenamento in area primaria può avvenire utilizzando due tecniche
\end_layout

\begin_layout Enumerate

\series bold
Liste separate
\end_layout

\begin_deeper
\begin_layout Standard
Se il bucket 
\emph on
j
\emph default
 va in 
\emph on
overflow
\emph default
, si inserisce il nuovo record nel primo bucket 
\series bold
non pieno
\series default
 successivo a 
\emph on
j
\emph default
.
 In questo caso è necessario che sia i record in 
\emph on
overflow
\emph default
 sia i record 
\bar under
non
\bar default

\begin_inset space ~
\end_inset

in overflow siano collegati a lista (in modo separato), così da riuscire
 a distinguere, in un bucket, se il record presente nel bucket stesso fa
 parte del bucket poichè indirizzato dalla funzione hash oppure se la sua
 presenza è dovuta a un bucket precedente andato in oveflow
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Liste confluenti
\series default
 (coalesced chaining)
\end_layout

\begin_deeper
\begin_layout Standard
A differenza delle 
\emph on
liste separate
\emph default
 nelle 
\emph on
liste confluenti 
\emph default
si utilizza un solo puntatore per ogni bucket (e non più per ogni record).
 Se ora un bucket 
\emph on
j
\emph default
 va in overflow, esso sceglierà ancora il primo bucket libero successivo
 ad esso per mandare i record, ma avrà un puntatore a questo nuovo bucket
 
\emph on
j+h
\emph default
, il quale, se pure lui si trova in overflow, punterà ad un nuovo bucket
 
\emph on
j+h+l
\emph default
 e così via, creando dunque una 
\emph on
lista confluente
\emph default
.
\end_layout

\end_deeper
\begin_layout Standard
Di seguito (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempiolisteconvssep"

\end_inset

) un esempio di liste separate e liste confluenti.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempiolisteconvssep"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempiolisteconvssep.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo a liste confluenti semplifica la gestione dei puntatori ma peggiora
 la prestazioni.
 Si prenda l'esempio e mettiamo di voler cercare una chiave, non presente
 nell'indice, che porti al bucket 
\emph on
j: 
\emph default
nelle liste separate devo proseguire fintanto che i puntatori dei record
 non finiscono, mentre nella lista confluente dovrò seguire la lista fintanto
 che ho bucket collegati (e fino a qui le prestazioni sono simili), ma cosa
 accade se cerco una chiave che porta al bucket 
\emph on
j+h
\emph default
? Nel caso di liste separate ancora una volta proseguo con i puntatori dei
 record fintanto che non trovo il record che sto cercando ed essendo i record
 del bucket collegati posso fermarmi al bucket stesso in caso di record
 trovato, mentre nelle liste confluenti, essendo che ora sono i bucket ad
 essere connessi da lista, dovrò andar a scandire ugualmente i bucket successivi
, azione che potrebbe non essere necessaria ma obbligata.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subparagraph
Concatenamento in area di overflow
\end_layout

\begin_layout Standard
Come detto in precedenza, la capacità dei blocchi nell'area di overflow
 
\begin_inset Formula $C_{OV}$
\end_inset

 può essere diversa dalla capacità dei bucket dell'area primaria 
\emph on
C.
 
\emph default
In genere 
\begin_inset Formula $C_{OV}<C$
\end_inset

 per evitare sprechi: infatti solitamente si tenta di ridurre il meno possibile
 l'overflow, di conseguenza la capacità dei blocchi in overflow può essere
 minore e per lo stesso motivo si può decidere di utilizzare 
\emph on
liste confluenti
\emph default
.
 Ovviamente, in caso di overflow di un bucket di overflow, si otterà una
 lista confluente di bucket di overflow.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subsubsection
Gestione Overflow - Open Addressing
\end_layout

\begin_layout Standard
Dedichiamo ora un sottoparagrafo alla tecnica del open addressing, poichè
 come si vedrà, richiede alcuni particolari accorgimenti.
\end_layout

\begin_layout Standard
A differenza del metodo della gestione a liste, dove a partire dall'indirizzo
 originale seguo una lista attraverso puntatori, nei metodi a 
\emph on
indirizzamento aperto
\emph default
 (open addressing) a ogni valore di chiave 
\begin_inset Formula $k_{i}$
\end_inset

 viene associata 
\series bold
una sequenza di indirizzi 
\begin_inset Formula $H_{0}(k_{i}),\, H_{1}(k_{i}),\,\ldots,\, H_{l}(k_{i})$
\end_inset

 
\series default
(ho creato cioè una 
\begin_inset Quotes eld
\end_inset

lista
\begin_inset Quotes erd
\end_inset

 attraverso una famiglia di funzioni 
\emph on
hash
\emph default
).
 Quando si inserisce una nuova chiave 
\begin_inset Formula $k_{i}$
\end_inset

 si provano tutti gli indirizzi generati da ogni funzione hash 
\begin_inset Formula $H_{0}(k_{i}),\, H_{1}(k_{i}),\,\ldots,\, H_{l}(k_{i})$
\end_inset

 fino a quando non si trova l'indirizzo di un bucket 
\emph on
non pieno
\emph default
.
\end_layout

\begin_layout Paragraph
Ricerca
\end_layout

\begin_layout Standard
Per cercare 
\begin_inset Formula $k_{i}$
\end_inset

 occorre cercare in tutti gli indirizzi associati 
\begin_inset Formula $H_{0}(k_{i}),\,\ldots,\, H_{l}(k_{i})$
\end_inset

 fino a quando:
\end_layout

\begin_layout Itemize
si trova 
\begin_inset Formula $k_{i}$
\end_inset

 (ricerca con successo)
\end_layout

\begin_layout Itemize
si trova un bucket 
\emph on
non pieno 
\emph default
(ricerca con insuccesso)
\emph on
.
\end_layout

\begin_layout Standard
La ricerca infatti può concludersi quando viene trovato un bucket non pieno
 poichè l'inserimento cerca il primo bucket non pieno in cui inserire la
 chiave 
\begin_inset Formula $k_{i}$
\end_inset

 e di conseguenza se raggiungiamo un bucket non pieno e 
\begin_inset Formula $k_{i}$
\end_inset

 non è stata ancora trovata vuol dire che la chiave non è presente.
\end_layout

\begin_layout Standard
Nei metodi a indirizzamento aperto occorre quindi prestare particolare 
\emph on
attenzione 
\emph default
a come si operano le 
\emph on
cancellazioni
\emph default
: infatti se si cancella un record presente in un bucket che risultava 
\emph on
pieno
\emph default
 esso diventerà 
\emph on
non pieno
\emph default

\begin_inset space ~
\end_inset


\begin_inset Quotes eld
\end_inset

interrompendo
\begin_inset Quotes erd
\end_inset

 dunque la ricerca.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph
Cancellazione
\end_layout

\begin_layout Standard
Per la cancellazione è utile introdurre un nuovo 
\begin_inset Quotes eld
\end_inset

stato
\begin_inset Quotes erd
\end_inset

 alle posizioni all'interno del bucket, infatti la semplice distinzione
 pieno e non pieno del bucket non è più esaustiva per la ricerca.
 Ecco allora che le 
\begin_inset Quotes eld
\end_inset

posizioni
\begin_inset Quotes erd
\end_inset

 di un record all'interno di un bucket possono essere marcate come 
\emph on
libere
\emph default
, 
\emph on
occupate
\emph default
, 
\emph on
non occupate.

\emph default
 La posizione di un record cancellato viene quindi marcata come 
\emph on
non occupata 
\emph default
e può essere riutilizzata (e essere marcata nuovamente come 
\emph on
occupata
\emph default
) in seguito a nuovi inserimenti.
 Un bucket risulta
\emph on
 pieno 
\series bold
\emph default
se e solo se 
\series default
tutte le posizioni all'interno del bucket sono 
\series bold
occupate.
 
\series default
Si noti che all'atto dell'inserimento sarà dunque preferibile andare a occupare
 posizioni 
\begin_inset Quotes eld
\end_inset

non occupate
\begin_inset Quotes erd
\end_inset

 piuttosto che posizioni 
\begin_inset Quotes eld
\end_inset

libere
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename liboccnonocc.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Famiglia di Hash
\end_layout

\begin_layout Standard
Come si creano le famiglie di funzioni hash necessarie ad indirizzare tutti
 i bucket presenti in memoria principale?
\end_layout

\begin_layout Standard
La prima idea è la 
\series bold
scansione lineare
\series default
 (linear probing).
 Ad ogni passo l'indirizzo risultante della j-esima funzione hash H è dalla
 somma del risultato della funzione hash 
\emph on
j-1
\emph default
-esima più un 
\series bold
passo costante 
\emph on
s 
\begin_inset Formula $H_{j}(k_{i})=[H_{j-1}(k_{i})+s]\%P$
\end_inset

 
\series default
\emph default
che con una semplice trasformazione risulta essere 
\begin_inset Formula $H_{j}(k_{i})=[H(k_{i})+s\cdot j]\%P$
\end_inset

.
 Si noti che per generare tutti i P indirizzi occorre che il passo 
\emph on
s
\emph default
 sia 
\emph on
cooprimo
\emph default
 con P (cioè che non abbiano divisori comuni) altrimenti verrebbero generati
 solo 
\begin_inset Formula $\frac{P}{MCD(P,s)}$
\end_inset

 indirizzi.
 Ad esempio: P=10, s=4, MCD(10,4)=2, gli indirizzi generabili per le chiavi
 sono 5, infatti 
\begin_inset Formula $k_{i}=3$
\end_inset

 genera gli indirizzi 3, 7, 1, 5, 9, 3.
\end_layout

\begin_layout Standard
In un 
\series bold
clustering primario
\series default
 risulta essere presente un altro problema, il cosiddetto 
\emph on
addensamento di record
\emph default
: se un bucket j va in overflow è molto probabile che il cluster (bucket)
 j+s vada in overflow, quindi che il cluster j+2s vada in overflow e così
 via.
 Ad esempio con P=31 e s=3 vengono generati i seguenti indirizzi:
\end_layout

\begin_layout Itemize
\begin_inset Formula $k_{i}=1234\rightarrow H_{0}(1234)=1234\%31=25\rightarrow H_{1}(25+3)=28\rightarrow0\rightarrow3\rightarrow6\rightarrow9\rightarrow\ldots$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $k_{i}=245\rightarrow H_{0}(245)=245\%31=28\rightarrow H_{1}(28+3)=0\rightarrow3\rightarrow6\rightarrow9\rightarrow\ldots$
\end_inset


\end_layout

\begin_layout Standard
Il problema è dovuto alla linearità del 
\emph on
passo di scansione 
\series bold
s
\series default
\emph default
.
 Per risolvere il problema si può pensare ad introdurre la 
\series bold
scansione quadratica.
 
\series default
Nella scansione quadratica il passo non è una costante s, ma una funzione
 lineare in 
\emph on
j.
 
\emph default
Ad ogni passo l'indirizzo è aumentato di un 
\emph on
passo lineare 
\begin_inset Formula $a+b\cdot(2j-1)$
\end_inset

 
\emph default
e dunque la funzione hash 
\emph on
j-
\emph default
esima è data da 
\begin_inset Formula $H_{j}(k_{i})=[H_{j-1}+a+b\cdot(2j-1)]\%P$
\end_inset

 che con una semplice trasformazione risulta essere 
\begin_inset Formula $H_{j}(k_{i})=[H_{j}(k_{i})+a\cdot j+b\cdot j^{2}]\%P$
\end_inset

.
 Vediamo con un esempio come la scansione quadratica sia riuscita ad evitare
 l'addensamento di record.
 Esempio: P=31, a=3, b=5 indirizzi generati:
\end_layout

\begin_layout Itemize
\begin_inset Formula $k{}_{i}=1234\rightarrow H_{0}(1234)=1234\%31=25\rightarrow H_{1}(25+3\cdot1+5\cdot1)=2\rightarrow20\rightarrow17\rightarrow24\rightarrow\ldots$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $k_{i}=245\rightarrow H_{0}(245)=245\%31=28\rightarrow H_{1}(28+3\cdot1+5\cdot1)=5\rightarrow23\rightarrow20\rightarrow27\rightarrow\ldots$
\end_inset


\end_layout

\begin_layout Standard
e in effeti le liste non confluiscono (si veda il 20 che produce indirizzi
 diversi).
\end_layout

\begin_layout Standard
Rimane però ancora il problema del 
\series bold
clustering secondario 
\series default
dovuto a chiavi aventi lo stesso 
\begin_inset Quotes eld
\end_inset

primo
\begin_inset Quotes erd
\end_inset

 bucket.
 Anche questo caso è un problema risolvibile, grazie alla tecnica del 
\series bold
double hashing
\series default
 la quale consisnte di generare la famiglia di funzioni hash 
\begin_inset Formula $H_{0}(k_{i}),\,\ldots,\, H_{l}(k_{i})$
\end_inset

 a partire da 
\emph on
due funzioni hash H' e H''.

\emph default
 In questo caso le sequenze di indirizzi sonon date da:
\end_layout

\begin_layout Itemize
\begin_inset Formula $H_{0}(k_{i})=H'(k_{i})$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $H_{j}(k_{i})=[H_{j-1}(k_{i})+H"(k_{i})]\%P$
\end_inset

 (se 
\begin_inset Formula $j>0$
\end_inset

)
\end_layout

\begin_layout Standard
Adesso due chiavi generano la stessa sequenza di indirizzi 
\series bold
se e solo se
\series default
 entrambe collidono sia con 
\emph on
H'
\emph default
 sia con 
\emph on
H''
\emph default
 (molto improbabile).
 Si noti come la 
\emph on
double hashing
\emph default
 produce una 
\emph on
scansione lineare
\emph default
 (non è quadratica) quindi a passo costante, però a differenza della semplice
 scansione lineare il passo s varia da chiave a chiave.
 La tecnica del double hashing ha come effetto collaterale quello di produrre
 una forte variabilità degli indirizzi generati, in maniera dipendente dal
 valore di 
\begin_inset Formula $H"(k_{i})$
\end_inset

.
 Considerando l'effettiva allocazione dei bucket in memoria secondaria ciò
 può appesantire 
\emph on
notevolmente 
\emph default
le operazioni di I/O poichè bucket successivi (il primo ed il secondo ad
 esempio) si ritrovano 
\begin_inset Quotes eld
\end_inset

lontani
\begin_inset Quotes erd
\end_inset

 andando ad aumentare parecchio il tempo di latenza (tempo impiegato dalla
 testina per muoversi).
 Nonostante questo svantaggio, il 
\emph on
double hashing
\emph default
 riesce però ad approssimare abbastanza bene il nostro caso ideale di 
\begin_inset Quotes eld
\end_inset


\series bold
hash uniforme
\series default

\begin_inset Quotes erd
\end_inset

 in cui ogni indirizzo ha la stessa probabilità di essere generato al 
\emph on
j
\emph default
-esimo passo.
\end_layout

\begin_layout Standard
Viene infine mostrato un confronto (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:grafovario"

\end_inset

) tra le varie tecniche finora mostrate.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:grafovario"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename grafovario.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Hashing Dinamico
\end_layout

\begin_layout Standard
Finora abbiamo discusso di organizzazioni hash statiche, in cui l'allocazione
 della memoria è effettuata al momento della progettazione iniziale.
 Al momento di progettazione vengono scelti dunque il numero dei bucket
 (P), la loro capacità (C) e il fattore di caricamento (d) basandosi sulla
 stima del numero di record (N) che si dovranno gestire.
 Si noti che essendoci basati su una stima, se essa è in eccesso allora
 lo spazio risulterà poco utilizzato, mentre se è in difetto si dovrà lavorare
 con un alto fattore di caricamento (e conseguentemente elevati costi di
 accessi): se inoltre gli 
\emph on
overflow
\emph default
 vengono gestiti in area primaria bisogna ricordarsi del vincolo 
\begin_inset Formula $d\leq1$
\end_inset

.
 Cosa succede inoltre se il mio dataset (insieme delle chiavi) aumenta?
 I parametri prima imposti che si basavano sulla stima di N ora risulterebbero
 errati proprio perchè N è aumentato.
 Introduciamo dunque l'organizzazione ad 
\emph on
hashing dinamico.
 
\series bold
\emph default
NB 
\series default
L'hashing statico raggiunge la sua ottimalità se utilizzato su una 
\begin_inset Quotes eld
\end_inset

tabella
\begin_inset Quotes erd
\end_inset

 che sappiamo non andrà a cambiare, questo vuol dire che utilizzeremo l'hashing
 statico come strumento di appoggio alla risoluzione di query, poichè alle
 interrogazioni sul server le tabelle sono già 
\begin_inset Quotes eld
\end_inset

date
\begin_inset Quotes erd
\end_inset

 e non possono variare (ad esempio sarà molto utile nella risoluzione di
 
\emph on
join
\emph default
).
\end_layout

\begin_layout Standard
Le tecniche di 
\emph on
hashing dinamico
\emph default
 adattano l'allocazione dell'area primaria in base al numero di tuple attuali.
 Esse si possono raggruppare in due gruppi:
\end_layout

\begin_layout Itemize

\series bold
Con directory
\end_layout

\begin_deeper
\begin_layout Itemize
Virtual hashing
\end_layout

\begin_layout Itemize
Dynamic hashing
\end_layout

\begin_layout Itemize
Extendible hashing
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Senza directory
\end_layout

\begin_deeper
\begin_layout Itemize
Linear hashing
\end_layout

\begin_layout Itemize
Spiral hashing
\end_layout

\end_deeper
\begin_layout Standard
Verranno trattati in maniera specifica l'
\series bold
extendible hashing
\series default
, il 
\series bold
virtual hashing
\series default
 e il 
\series bold
dynamic hashing 
\series default
e il 
\series bold
linear hashing
\series default
 dando alcuni concetti generali delle restanti tecniche.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph
Virtual hashing
\end_layout

\begin_layout Standard
L'idea su cui si basa il 
\emph on
virtual hashing 
\emph default
(Litwin '78) è di 
\emph on
raddoppiare l'area primaria
\emph default
 quando si verifica un 
\emph on
overflow
\emph default
 di un bucket (e ad esso non è associato alcun 
\emph on
bucket buddy 
\emph default
'compagno' sul quale ridistribuire i record).
 La directory terrà memoria di quali 
\emph on
bucket
\emph default
 sono effettivamenti usati e quali no.
 Quando si verifica un 
\emph on
overflow
\emph default
 di un bucket si ridistribuiscono i record tra il bcket saturo e il suo
 
\emph on
buddy 
\emph default
facendo uso di una nuova funzione hash: in pratica si esegue lo 
\emph on
split
\emph default
 del bucket saturo (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:vh01"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:vh01"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename virtualhashing.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se successivamente un altro bucket nell'area primaria originale va in overflow
 e il suo 
\emph on
buddy
\emph default
 non è ancora in uso, il bucket buddy inizia ad essere utilizzato (e quindi
 viene segnato come in uso) e vengono ridistribuiti i record tra il bucket
 e il bucket 
\emph on
buddy
\emph default
 (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:vh02"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:vh02"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename virtualhashing02.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Poichè, in un certo istante, solo alcuni 
\emph on
buddy
\emph default
 sono effettivamente in uso è necessario far uso di una struttura ausiliaria,
 
\emph on
la directory
\emph default
, che permetta di determinare se occorre utilizzare la vecchia o la nuova
 funzione 
\emph on
hash
\emph default
.
 Sostantialmente la directory è un semplice vettore V di bit (0 o 1) in
 cui 
\begin_inset Formula $V[i]=1$
\end_inset

 
\emph on
se e solo se
\emph default
 il bucket i-esimo è in uso.
\end_layout

\begin_layout Standard
Come viene inizializzata l'area primaria? Vengono allocati P
\begin_inset Formula $_{0}$
\end_inset

 bucket di capacità C.
 Si usa una funzione hash H
\begin_inset Formula $_{0}$
\end_inset

 che restituisca valori nell'intervallo 
\begin_inset Formula $[0,\, P_{0}-1]$
\end_inset

.
 Si utilizza un contatore I che determina il numero dei raddoppi eseguiti,
 quindi si inizializza intanto a 0 
\begin_inset Formula $I=0$
\end_inset

.
 Si crea dunque un vettorei binario V di dimensione pari a P
\begin_inset Formula $_{0}$
\end_inset

 ponendo tutti gli elementi al valore 1 (poichè assumiamo che tutti i bucket
 dell'originale area primaria vengano usati).
 Dopo I raddoppi l'area primaria conterrà un numero di bucket P pari a 
\begin_inset Formula $P=2^{I}\cdot P_{0}$
\end_inset

 dove ogni j-esimo bucket (con 
\begin_inset Formula $0\leq j\leq2^{I-1}\cdot P_{0}-1$
\end_inset

 cioè la prima metà dell'area di memoria) ha associato il suo bucket 
\emph on
buddy
\emph default
 all'indirizzo 
\begin_inset Formula $j+2^{I-1}\cdot P_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
Controlliamo ora come avviene uno 
\emph on
split
\emph default
 di un bucket j.
\begin_inset Newline newline
\end_inset

Se 
\begin_inset Formula $I=0$
\end_inset

 (cioè non è stato fatto ancora alcun raddoppio) oppure 
\begin_inset Formula $I>0$
\end_inset

 ma il bucket buddy del nostro bucket j-esimo risulta essere già in uso
 (dunque 
\begin_inset Formula $I>0$
\end_inset

 ma 
\begin_inset Formula $V[j+2^{I-1}\cdot P_{0}]=1$
\end_inset

) o non esiste (dunque 
\begin_inset Formula $I>0$
\end_inset

 ma 
\begin_inset Formula $j\geq2^{I-1}\cdot P_{0}-1$
\end_inset

) allora:
\end_layout

\begin_layout Enumerate
Viene incrementato il valore di I
\begin_inset Formula $\rightarrow I++$
\end_inset


\end_layout

\begin_layout Enumerate
Si raddoppia l'area primaria e il vettore V
\end_layout

\begin_layout Enumerate
I nuovi elementi di V vengono impostati a 0 eccetto per 
\begin_inset Formula $V[j+2^{I-1}\cdot P_{0}]$
\end_inset

 (cioè il bucket buddy del bucket j-esimo)
\end_layout

\begin_layout Enumerate
Si crea una nuova funzione H
\begin_inset Formula $_{I}$
\end_inset

 a valori in 
\begin_inset Formula $[0,\,2^{I}\cdot P_{0}-1]$
\end_inset


\end_layout

\begin_layout Enumerate
Si ridistribuiscono le chiavi del bucket j utilizzando la nuova funzione
 H
\begin_inset Formula $_{I}$
\end_inset


\end_layout

\begin_layout Standard
Se invece il 
\emph on
bucket buddy
\emph default
 del nostro bucket j-esimo esiste ma non è in uso (cioè 
\begin_inset Formula $I>0$
\end_inset

 e 
\begin_inset Formula $V[j+2^{I-1}\cdot P_{0}]=0$
\end_inset

) allora
\end_layout

\begin_layout Enumerate
Viene impostato a 1 il valore di utilizzo del bucket buddy 
\begin_inset Formula $\rightarrow V[j+2^{I-1}\cdot P_{0}]=1$
\end_inset


\end_layout

\begin_layout Enumerate
Si ridistribuiscono le chiavi del bucket j utilizzando la funzione H
\begin_inset Formula $_{I}$
\end_inset

 (che sicuramente esiste già)
\end_layout

\begin_layout Standard
Facciamo un esempio.
 Immaginiamo di avere numero di bucket iniziali 
\begin_inset Formula $P_{0}=7$
\end_inset

 con capacità 
\begin_inset Formula $C=3$
\end_inset

 riempiti come mostrato in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:vh03"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:vh03"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename virtualhashing03.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La famiglia di funzioni hash H
\begin_inset Formula $_{I}$
\end_inset

 sia siffata 
\begin_inset Formula $H_{I}(k)=k\%(2^{I}\cdot P_{0})$
\end_inset

.
 Supponiamo di voler inserire la chiave 
\begin_inset Formula $k=3820$
\end_inset

 la cui funzione hash 
\begin_inset Formula $H_{0}(3820)=5$
\end_inset

 (si noti che non è stato fatto ancora alcun raddoppio quindi 
\begin_inset Formula $I=0$
\end_inset

).
 Il bucket 5 va in overflow (siamo sempre 0-based).
 Bisogna dunque effettuare un raddoppio dell'area di memoria e del vettore
 V impostando a 0 tutti i nuovi valori eccetto quello del bucket buddy,
 incrementare di 1 il valore di I (
\begin_inset Formula $P_{1}=14$
\end_inset

 e 
\begin_inset Formula $I=1$
\end_inset

) e ridistribuire le chiavi del bucket 5, tra il bucket 5 stesso e il suo
 buddy 12 facendo uso della nuova funzione hash 
\begin_inset Formula $H_{1}(k)=k\%14$
\end_inset

.
 In figura viene mostrata la nuova situazione (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:vh04"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:vh04"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename virtualhashing04.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se ora volessi inserire la chiave 3343, si ha 
\begin_inset Formula $H_{1}(3343)=11$
\end_inset

 ma il bucket 11 ha 
\begin_inset Formula $V[11]=0$
\end_inset

 (dunque non in uso), conseguentemente bisogna applicare la funzione hash
 precedente 
\begin_inset Formula $H_{0}(3343)=4$
\end_inset

.
 Il bucket 4 risulta però saturo quindi bisogna eseguire lo split: in questo
 caso però l'area può non raddoppiare perchè il suo bucket buddy esiste
 ed esso risulta non essere ancora utilizzato.
 Di conseguenza viene impostato a 1 il valore di 
\begin_inset Formula $V[11]=1$
\end_inset

 e vengono ridistribuite le chiavi del bucket 4 utilizzando la nuova funzione
 H
\begin_inset Formula $_{1}$
\end_inset

.
 In figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:vh05"

\end_inset

) viene mostrata la nuova situazione.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:vh05"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename virtualhashing05.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Manca ancora da capire come funziona la ricerca di una chiave.
 Per cercare un valore di chiave è necessario sapere con quale funzione
 hash è stato allocato il valore stesso.
 Il vettore V è sufficiente allo scopo.
 Il seguente algoritmo ricorsivo fornisce l'indirizzo del bucket in cui
 potrebbe trovarsi (magari non esiste) la chiave cercata.
\end_layout

\begin_layout Standard

\family typewriter
Address(k, I)
\end_layout

\begin_layout Standard

\series bold
Input: 
\series default
Chiave k da cercare, livello I in cui cercare
\end_layout

\begin_layout Standard

\series bold
Output: 
\series default
Indirizzo del bucket al livello I in cui trovare k
\begin_inset Newline newline
\end_inset


\family typewriter
if (I<0) then la chiave non esiste
\begin_inset Newline newline
\end_inset

else if (V[H
\begin_inset Formula $_{I}$
\end_inset

(k)]=1 return H
\begin_inset Formula $_{I}$
\end_inset

(k)
\begin_inset Newline newline
\end_inset

else return Address(k, I-1)
\end_layout

\begin_layout Standard
Il virtual hashing richiede una 
\emph on
serie di funzioni 
\emph default
hash 
\begin_inset Formula $H_{0},\, H_{1},\,\ldots,\, H_{I},\,\ldots$
\end_inset

 che soddisfino le seguenti condizioni:
\end_layout

\begin_layout Itemize

\series bold
Range condition
\series default
: la funzione H
\begin_inset Formula $_{I}$
\end_inset

 deve essere a valori in 
\begin_inset Formula $[0,\,2^{I}\cdot P_{0}-1]$
\end_inset

, cioè la funzione H
\begin_inset Formula $_{I}$
\end_inset

 possa generare tutti gli indirizzi
\end_layout

\begin_layout Itemize

\series bold
Split condition: 
\series default
Per ogni 
\begin_inset Formula $I>0$
\end_inset

, per ogni chiave 
\emph on
k
\emph default
, e per ogni valore di 
\begin_inset Formula $H_{I}(k)$
\end_inset

 deve valere la seguente relazione:
\begin_inset Formula 
\[
H_{I}(k)=H_{I-1}(k)\, oppure\, H_{I}(k)=H_{I-1}(k)+2^{I-1}\cdot P_{0}
\]

\end_inset

 ovvero lo split di un bucket deve lasciare una chiave o nel bucket stesso
 o allocarla nel bucket 
\emph on
buddy
\emph default
.
\end_layout

\begin_layout Standard
La famiglia di funzioni 
\begin_inset Formula $H_{I}(k)=k\%(2^{I}\cdot P_{0})$
\end_inset

 soddisfa entrambe le condizioni
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph
Dynamic hashing
\end_layout

\begin_layout Standard
A differenza del 
\emph on
virtual hashing
\emph default
 il 
\emph on
dynamic hashing 
\emph default
non raddoppia l'area primaria, bensì la fa cresce di un bucket alla volta,
 utilizzando la struttura ausiliaria della 
\emph on
directory
\emph default
 come un albero (
\emph on
trie
\emph default
) binario.
 Il 
\emph on
dynamic hashing 
\emph default
(Larson '78) evita dunque di ricorrere a tecniche di raddoppio (che oltre
 a causare appesantimenti non trascurabili nel momento in cui l'area primaria
 viene raddoppiata, riducono il fattore di utilizzazione) facendo uso di
 una struttura ausiliaria, la 
\emph on
directory
\emph default
, organizzata come un 
\emph on
trie albero
\emph default
.
 L'idea di base (comune all'
\emph on
extendible hashing
\emph default
) è quella di far uso di una funzione hash che, dato il valore k, restituisce
 una 
\emph on
pseudo-chiave binaria 
\begin_inset Formula $H(k)=b_{0},b_{1},b_{2},\ldots$
\end_inset

 
\emph default
(cioè la chiave 
\emph on
k 
\emph default
viene utilizzata come seme di un generatore di numeri pseudo-casuale).
 La situazione ideale è quella in cui l'insieme di pseudo-chiavi da gestire
 è tale per cui la probabilità di generare un bit (0 o 1) è la stessa, cioè
 
\begin_inset Formula $Pr\{b_{i}=1\}=\frac{1}{2}$
\end_inset

 ovvero vi sia una ripartizione bilanciata per ogni posizione considerata.
\end_layout

\begin_layout Standard
Vediamo dunque l'uso dell'albero 
\emph on
trie
\emph default
.
 Il 
\emph on
trie
\emph default
 serve ad organizzare la ricerca ed ogni foglia indirizza i bucket dell'area
 dati.
 Per cercare (o inserire) un avolre di chiave 
\emph on
si segue, fino ad una foglia, il cammino del trie corrispondente alla pseudo
 chiave
\emph default
, cioè viene utilizzata la funzione Hash per generare la pseudo-chiave che
 mi porterà al bucket in cui la chiave dovrebbe essere presente.
\end_layout

\begin_layout Standard
Nell'esempio in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:dh01"

\end_inset

) il bucket 1 contiene tutti i valori di chiave la cui pseudo-chiave è del
 tipo 
\begin_inset Formula $0\ldots$
\end_inset

 (cioè che iniziano per 0) mentre il bucket 2 quelli la cui pseudo-chiave
 è del tipo 
\begin_inset Formula $1\ldots$
\end_inset

 (cioè che iniziano per 1).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:dh01"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename dynamichashing.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bisogna ovviamente gestire il caso di 
\emph on
overflow 
\emph default
di un bucket.
 L'espanzione dell'area primaria avviene aggiungendo 
\emph on
un bucket alla volta
\emph default
, 
\emph on
ridistribuendo 
\emph default
i record tra il bucket saturo e il suo 
\emph on
buddy
\emph default
 e 
\emph on
aggiungendo 
\emph default
un nodo al 
\emph on
trie.

\emph default
 L'esempio in figura (Fig.
 ) meglio potrà chiarire.
 Il bucket 2 dell'esempio precedente (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:dh01"

\end_inset

) è in overflow e deve subire il processo di split.
 La nuova situazione prevede che il bucket 2 ora contenga tutti i valori
 di chiave la cui pseudo-chiave è del tipo 
\begin_inset Formula $10\ldots$
\end_inset

 mentre il bucket 3 quelli la cui pseudo chiave è 
\begin_inset Formula $11\ldots$
\end_inset

 (mentre il bucket 1 è rimasto invariato e conterrà le chiavi il cui pseudo
 codice inizia per 
\begin_inset Formula $0\ldots$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:dh02"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename dynamichashing02.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si notri che se il 
\emph on
trie
\emph default
 è in memoria centrale basta un singolo accesso per recuperare un record,
 invece se il 
\emph on
trie
\emph default

\begin_inset space ~
\end_inset

non risulta stare in memoria centrale le prestazioni dipendono dal bilanciamento
 dell'albero stesso in termini di numero di nodi indice da dover recuperare.
 Le prestazioni nel caso peggiore non sono buone, infatti a seconda dell'insieme
 di pseudo-chiavi l'inserimento di un record può comportare più di uno split.
 Se dopo una cancellazione in un bucket il numero di recordo contentui nel
 bucket e nel suo buddy diventa minore o uguale alla capacità C, i bucket
 vengono fusi e si elimina una foglia dal 
\emph on
trie
\emph default
.
 Si noti che in media il fattore di utilizzazione dei bucket è di circa
 il 70%.
\end_layout

\begin_layout Standard
Esiste anche una variante al 
\emph on
dynamic hashing
\emph default
: invece di avere un solo grande albero 
\emph on
trie
\emph default
, vengono utilizzati più trie.
 Inizilamente si allocano un numero di bucket pari a P.
 Viene creata una funzione hash statica H
\begin_inset Formula $_{0}$
\end_inset

 e a seguito di un 
\emph on
overflow
\emph default
 vengono generati P 
\emph on
trie
\emph default
 le cui radici sono indirizzate da H
\begin_inset Formula $_{0}$
\end_inset

.
 In pratica la funzione H
\begin_inset Formula $_{0}$
\end_inset

 fa da vera funzione hash indirizzando la chiave ad un trie, una volta giunti
 nel trie si utilizza una nuova funzione hash che genera la pseudo-chiave
 cadendo nel caso precedentemente studiato.
 Si veda l'esempio in figura (Fig.
 ) in cui 
\begin_inset Formula $H_{0}(k)=k\%3$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph
Extendible hashing
\end_layout

\begin_layout Standard
Molto simile al 
\emph on
dynamic hashing
\emph default
, da cui si differenzia per la gestione della 
\emph on
directory, 
\emph default
l'
\emph on
extandible hashing 
\emph default
(Fagin, '79) ha la peculiarità di garantire non più di due accessi I/O.
 La 
\emph on
directory
\emph default
 è formata da 
\begin_inset Formula $2^{p}$
\end_inset

 celle di indirizzi compresi tra 
\begin_inset Formula $[0,\,2^{p}-1]$
\end_inset

.
 Il valore 
\begin_inset Formula $p\geq0$
\end_inset

 è detto 
\emph on
profondità della directory
\emph default
.
 Una funzione 
\emph on
hash
\emph default
 associa ad ogni chiave 
\emph on
k
\begin_inset Formula $_{i}$
\end_inset

 
\emph default
una 
\series bold
pseudo-chiave binaria
\series default
 (in sostanza 
\emph on
k
\emph default
 viene usato come seme di un Pseudo-Random Number Generator), cioè la funzione
 hash produce una sequenza binaria lunga almeno 
\emph on
p bit
\emph default
 
\begin_inset Formula $H(k_{i})=\ldots,b_{2},b_{1},b_{0}$
\end_inset

.
 Di questa sequenza si considerano i 
\emph on
p bit meno significativi
\emph default
: essi verranno utilizzati per accedere direttamente a una delle 
\begin_inset Formula $2^{p}$
\end_inset

 celle della 
\emph on
directory
\emph default
 stessa, ognuna contenente un puntatore a un bucket.
 Il numero dei bucket è sempre minore o uguale al numero di celle: se essi
 coincidono allora ogni cella della directory punta ad un bucket diverso,
 se minore indica che alcune celle puntano allo stesso bucket.
\end_layout

\begin_layout Standard
Ogni bucket ha una 
\emph on
profondità locale p'
\emph default
 con 
\begin_inset Formula $p'\leq p$
\end_inset

 (il valore di 
\emph on
p'
\emph default
 viene mantenuto nel bucket) che indica 
\emph on
il numero effettivo di bit 
\emph default
usati per allocare le chiavi nel bucket stesso.
 L'esempio (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempioexndiblehashing"

\end_inset

) può aiutare nella comprensione: il bucket contenente la chiave 258 (la
 cui funzione 
\emph on
hash
\emph default
 produce una sequenza binaria 
\begin_inset Formula $\ldots001$
\end_inset

) ha profondità locale 
\begin_inset Formula $p'=2$
\end_inset

, di conseguenza lo stesso bucket conterrà le chiavi le cui pseudo-chiavi
 (il risultato della funzione hash) risultino essere sia 
\begin_inset Formula $\ldots001$
\end_inset

 sia 
\begin_inset Formula $\ldots101$
\end_inset

 (poichè bastano i soli 2 bit meno significativi 01 per allocare le chiavi
 nel bucket).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempioexndiblehashing"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempioextandiblehashing.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Split di un bucket
\end_layout

\begin_layout Standard
Cosa succede se un bucket a profondità locale p' risulta essere in 
\emph on
overflow
\emph default
?
\end_layout

\begin_layout Standard
Bisogna distinguere due casi:
\end_layout

\begin_layout Itemize
\begin_inset Formula $p'<p$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $p'=p$
\end_inset


\end_layout

\begin_layout Standard
Nel primo caso (p'<p) viene generato (si alloca) un 
\emph on
nuovo bucket
\emph default
 e si distribuiscono le chiavi tra i due bucket utilizzando il bit 
\emph on
p'+1
\emph default
-esimo aggiuntivo della pseudo-chiave (in quanto prima era un 'bit' superfluo
 perchè più celle puntavano allo stesso bucket, ora invece questo bit in
 più permette l'identificazione del bucket appena creato da quello originario).
 Per i due bucket si modifica la loro 
\emph on
profondità locale
\emph default
 incrementandola di 1.
 Inoltre proprio perchè 
\emph on
p'<p
\emph default
 esiste sicuramente una cella che può indirizzare il nuovo bucket (poichè
 c'erano più celle che puntavano allo stesso bucket), pertanto si modifica
 il puntatore di questa cella al bucket appena generato.
 Si veda l'esempio in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempiopminorep"

\end_inset

) per una maggiore comprensione.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempiopminorep"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempiopminorep.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il secondo caso (
\emph on
p'=p
\emph default
) richiede alcuni accorgimenti ulteriori.
 Poichè 
\emph on
p'=p
\emph default
 vuol dire che non esiste alcuna cella che possa indirizzare il nuovo bucket
 (poichè il bucket originario è indirizzato da una sola cella) eventualmente
 ottenuto dallo split.
 Per risolvere il problema si 
\emph on
raddoppia 
\emph default
la 
\emph on
directory
\emph default
 e si incrementa il valore della profondità della directory p di 1, si copiano
 dunque i valori dei puntatori nelle nuove celle corrispondenti (avendo
 raddoppiato la directory son passato da 
\begin_inset Formula $2^{p}$
\end_inset

 celle a 
\begin_inset Formula $2^{p+1}$
\end_inset

, e le nuove 
\begin_inset Formula $2^{p}$
\end_inset

 celle dovranno puntare ai bucket esistenti).
 Infine si esegue lo 
\emph on
split
\emph default
 ricadendo nel caso precedente di 
\emph on
p'<p
\emph default
.
 Si veda l'esempio in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempiopugualep"

\end_inset

) per una maggiore comprensione.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempiopugualep"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempiopugualep.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rimane un problema irrisolto che andremo a illustrare attraverso l'esempio.
 Si provi ad immaginare che il bucket in 
\emph on
overflow 
\emph default
puntato dalla cella con indizzo 11 abbia al suo interno solo record le cui
 pseudo-chiavi terminino tutte per 111.
 Una volta raddoppiata la 
\emph on
directory
\emph default
 tutti questi record si porteranno nel bucket indirizzato dalla cella contenente
 111, portando ad avere il bucket ancora in 
\emph on
overflow
\emph default
 mentre il suo compagno 011 risulterebbe vuoto.
 A questo punto basta iterare il procedimento, esso dovrò convergere in
 quanto valutando sempre un bit in più della pseudochiave ci ritroveremo
 a diversificare i vari record e a rendere il bucket non più in overflow.
 Questo vuol dire che una volta raddoppiata la 
\emph on
directory
\emph default
 bisogna controllare che i bucket non siano ancora in overflow e in caso
 rieseguire il procedimento.
\end_layout

\begin_layout Subparagraph
Cancellazione
\end_layout

\begin_layout Standard
Anche in caso di cancellazione di un record bisogna procedere con cautela.
 Infatti, se si cancella un record in un bucket con profondità locale 
\emph on
p'
\emph default
 e la somma dei record contenuti nel bucket e nel bucket 
\emph on
buddy 
\emph default
(compagno) associato diventa 
\begin_inset Formula $\leq C$
\end_inset

 (Capacità del bucket), i due bucket vengono fusi e il 
\emph on
bucket 
\emph default
risultante avrà profondità locale 
\emph on
p'-1
\emph default
.
 Il bucket buddy di profondità locale p' di un determinato bucket di profondità
 locale p' (hanno stessa profondità) è quello che è identificato da una
 sequenza di 
\emph on
p'
\emph default
 bit di cui solo il bit più significativo (quello più a sinistra) risulta
 diverso (ad esempio bucket compagni sono (101,001), (111,011), (000,100),
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Se si fondono gli unici due bucket che hanno profondità locale 
\begin_inset Formula $p'=p$
\end_inset

 allora è possibile 
\emph on
contrarre 
\emph default
(
\emph on
dimezzare
\emph default
) 
\emph on
la directory
\emph default
.
 Poichè per verificare che non esistono più bucket a profondità p richiede,
 nel caso peggiore, di esaminare metà dei bucket, di conseguenza è conveniente
 utilizzare una tabella delle profondità locali che per ogni valore 
\begin_inset Formula $p'\leq p$
\end_inset

 mantiene il numero 
\begin_inset Formula $P(p')$
\end_inset

 di bucket a profondità 
\emph on
p'.
 
\emph default
Si veda l'esempio in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempioriduzionedirectory"

\end_inset

) per una maggiore comprensione.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempioriduzionedirectory"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempioriduzionedirectory.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Possiamo fare delle considerazioni finali: ogni raddoppio coinvolge tutta
 la 
\emph on
directory
\emph default
, si potrebbero avere dunque problemi in caso di concorrenza all'accesso
 all'indice.
 Una possibile soluzione prevede l'uso di una 
\emph on
directory
\emph default
 a più livelli e conseguentemente l'indice non risulta più necessariamente
 binario.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph
Linear Hashing
\end_layout

\begin_layout Standard
È la prima tecnica che guardiamo che non fa uso della 
\emph on
directory
\emph default
.
 Similmente all'
\emph on
extendible hashing,
\emph default
 il 
\emph on
linear hashing 
\emph default
espande la memoria linearmente, cioè aggiungendo un bucket alla volta, utilizzan
do ancora una volta la tecnica dello 
\emph on
split
\emph default
.
 A differenza però delle tecniche con 
\emph on
directory
\emph default
 bisogna ora utilizzare una tecnica più 
\begin_inset Quotes eld
\end_inset

semplice
\begin_inset Quotes erd
\end_inset

 per scegliere quale bucket andare a dividere.
 In breve il 
\emph on
linear hashing
\emph default
 è una tecnica ad 
\emph on
espansione lineare
\emph default
 che non essegue lo split del bucket in 
\emph on
overflow
\emph default
 ma bensì di un altro bucket scelto secondo un criterio specifico: ciò rende
 non necessaria una 
\emph on
directory
\emph default
, occorrerà ovviamente gestire ancora l'
\emph on
overflow
\emph default
 (siccome lo split del bucket non riguarda il bucket in overflow, bisognerà
 gestire l'
\emph on
overflow
\emph default
 con le tecniche inizialmente descritte: 
\emph on
open addressing
\emph default
 o 
\emph on
metodi a liste
\emph default
) e infine l'area primaria crescerà 
\begin_inset Quotes eld
\end_inset

linearmente
\begin_inset Quotes erd
\end_inset

.
 La semplice tecnica utilizzata per decidere quale bucket dividere è la
 seguente: 
\emph on
si divide il bucket successivo all'ultimo bucket diviso.
 
\emph default
Si noti che se il bucket su cui si esegue lo 
\emph on
split
\emph default
 era vuoto abbiamo diviso un bucket che non era necessario dividere: l'idea
 del 
\emph on
linear hashing
\emph default
 è di pensare che prima o poi, continuando ad eseguire lo split ogni volta
 che c'è overflow, arriverò a suddividere proprio il bucket in 
\emph on
overflow
\emph default
.
\end_layout

\begin_layout Standard
Indicato con P
\begin_inset Formula $_{0}$
\end_inset

 il numero dei bucket inizialmente allocati, si utilizza come funzione hash
 
\begin_inset Formula $H_{0}(k_{i})=k_{i}\%P_{0}$
\end_inset

 .
 Si mantiene anche un puntatore 
\series bold
SP
\series default
 (Split Pointer) al prossimo bucket che dovrà essere suddiviso (inizialmente
 dunque 
\begin_inset Formula $SP=0$
\end_inset

).
 Se si verifica un 
\emph on
overflow
\emph default
 si devono eseguire le seguenti operazioni:
\end_layout

\begin_layout Enumerate
Si aggiunge in coda un bucket di indirizzo 
\begin_inset Formula $P_{0}+SP$
\end_inset


\end_layout

\begin_layout Enumerate
Si riallocano i record del bucket SP (quello che è stato diviso), inclusi
 quelli eventualmenti presenti in area di overflow ad esso associati, utilizzand
o però una nuova funzione hash 
\begin_inset Formula $H_{1}(k)=k\%(2P_{0})$
\end_inset

 che suppone che la nostra area primaria sia raddoppiata.
 L'utilizzo temporaneo di questa nuova funzione hash è necessario per riuscire
 a raggiungere anche il nuovo bucket creato all'indirizzo 
\begin_inset Formula $P_{0}+SP$
\end_inset

.
\end_layout

\begin_layout Enumerate
Si incrementa SP di 1.
\end_layout

\begin_layout Standard
La cosa interessante riguarda l'utilizzo delle due funzioni: infatti se
 H
\begin_inset Formula $_{0}$
\end_inset

 dava come risultato 
\emph on
SP
\emph default
, allora H
\begin_inset Formula $_{1}$
\end_inset

 può dare come risultato solo o 
\emph on
SP
\emph default
 o 
\emph on
P
\begin_inset Formula $_{0}$
\end_inset

+SP
\emph default
.
 Un esempio potrà chiarire: si supponga inizialmente 
\begin_inset Formula $P_{0}=5$
\end_inset

, e si supponga che una chiave 
\begin_inset Formula $k_{i}$
\end_inset

 dia come risultato da 
\begin_inset Formula $H_{0}(k_{i})=k_{i}\%5=2$
\end_inset

, questo implica che la chiave 
\begin_inset Formula $k_{i}$
\end_inset

 doveva avere per forza come ultima cifra o 2 o 7, se applichiamo la stessa
 chiave a 
\begin_inset Formula $H_{1}(k_{i})=k_{i}\%(2\cdot5)=k_{i}\%10\rightarrow$
\end_inset

 allora essa potrà dare come risultato solo o 2 o 7, a seconda di quale
 fosse l'ultima cifra di 
\begin_inset Formula $k_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Si noti che dopo aver effettuato esattamente 
\begin_inset Formula $P_{0}$
\end_inset

 split (corrispondendi a P
\begin_inset Formula $_{0}$
\end_inset

 overflow), l'area di memoria è raddoppiata, in quanto il numero di bucket
 è ora pari a 
\begin_inset Formula $2P_{0}$
\end_inset

: bisogna dunque predisporre i parametri ad una nuova espansione ponendo
 
\begin_inset Formula $SP=0$
\end_inset

 (SP deve tornare all'inizio), imponendo 
\begin_inset Formula $H_{0}(k)=H_{1}(k)$
\end_inset

 (cioè modifico la funzione hash originale) e infine modificando anche 
\begin_inset Formula $H_{1}(k)=k\%(2^{2}\cdot P_{0})$
\end_inset

.
 In generale quando bisogna predisporsi alla 
\emph on
j
\emph default
-esima espansione le funzioni due funzioni hash H
\begin_inset Formula $_{0}$
\end_inset

 e H
\begin_inset Formula $_{1}$
\end_inset

 da utilizzare diventano 
\begin_inset Formula $H_{0}(k)=k\%(2^{j-1}\cdot P_{0})$
\end_inset

 e 
\begin_inset Formula $H_{1}(k)=k\%(2^{j}\cdot P_{0})$
\end_inset

.
\end_layout

\begin_layout Standard
Supponiamo ora di avere una chiave 
\emph on
k
\begin_inset Formula $_{i}$
\end_inset

 
\emph default
da dover inserire, come faccio a sapere quale funzione hash utilizzare?
 Il problema sorge poichè se utilizzassi sempre la funzione H
\begin_inset Formula $_{0}$
\end_inset

 avrei reso inutile l'allocazione del nuovo bucket all'indirizzo 
\emph on
SP+P
\begin_inset Formula $_{0}$
\end_inset

.
 
\emph default
Il problema si risolve in maniera molto semplice: se 
\begin_inset Formula $H_{0}(k_{i})\geq SP$
\end_inset

 allora effettivamente posso utilizzare la funzione H
\begin_inset Formula $_{0}$
\end_inset

 per allocare la chiave k
\begin_inset Formula $_{i}$
\end_inset

 al bucket indicato dal risultato della funzione H
\begin_inset Formula $_{0}$
\end_inset

, altrimenti sono costretto a calcolare 
\begin_inset Formula $H_{1}(k)$
\end_inset

 e utilizzare il risultato di questa seconda funzione hash.
\end_layout

\begin_layout Standard
Introduciamo un esempio (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempio1linear"

\end_inset

 e Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempio2linear"

\end_inset

) per maggiori chiarimenti.
\begin_inset Newline newline
\end_inset

Si immagini 
\begin_inset Formula $P_{0}=7$
\end_inset

, 
\begin_inset Formula $C=3$
\end_inset

, 
\begin_inset Formula $C_{OV}=2$
\end_inset

 e 
\begin_inset Formula $SP=2$
\end_inset

 (SP=2 vuol dire che ci sono stati già due 
\emph on
overflow
\emph default
 che ha portato lo split del bucket 0 e del bucket 1).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempio1linear"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempio1linear.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inserendo ora la chiave 
\begin_inset Formula $k_{i}=3820\rightarrow H_{0}(3820)=3820\%7=5$
\end_inset

 si genera un nuovo 
\emph on
overflow
\emph default
 nel bucket 5 (poichè pieno).
 Questo comporta ad allocare un nuovo 
\emph on
bucket
\emph default
 in posizione 7+2=9, a ridistribuire le chiavi presenti nel bucket SP=2
 cioè del terzo bucket (siamo in 0-based) e ad incrementare SP di uno risultando
 SP=3.
 Si noti come nella nuova ridistribuzione totale (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempio2linear"

\end_inset

) il bucket 5 andato in 
\emph on
overflow
\emph default
 ha dovuto gestire in modo autonomo il proprio 
\emph on
overflow
\emph default
, utilizzando, nell'esempio, un bucket in area di overflow.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempio2linear"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempio2linear.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'allocazione del bucket 9 ha causato l'eliminazione di un bucket di 
\emph on
overflow
\emph default
.
 Il prossimo 
\emph on
overflow
\emph default
 causerà lo split del bucket 3 (cioè il quarto).
 Dopo 7 split l'area primaria è raddoppiata e si impostano i valori di SP
 e delle funzioni hash in modo da essere pronti ad una nuova espansione.
\end_layout

\begin_layout Standard
L'assenza di una 
\emph on
directory
\emph default
 e la politica semplice degli split rendono di facile realizzazione l'intera
 struttura, inoltre la gestione dell'area primaria (sia per espansione che
 contrazione) è immediata, in quanto i bucket vengono sempre aggiunti (e
 rimossi) in coda.
 Di contro però l'utilizzazione della memoria allocata è decisamente bassa
 (varia tra 0.5 e 0.7), inoltre la gestione dell'area di 
\emph on
overflow
\emph default
 presenta problemi simili a quelli visti nella gestione dell'hashing statico
 ed infine le catene di 
\emph on
overflow
\emph default
 relative ai buket di indirizzo molto alto, non ancora suddivise, possono
 diventare molto lunghe.
\end_layout

\begin_layout Standard
Esiste una variante al modello presentato che prevede di non effettuare
 lo 
\emph on
split
\emph default
 di un bucket se questo non ha raggiunto un livello di utilizzazione minimo
 
\begin_inset Formula $u_{min}$
\end_inset

, tutto a beneficio di una migliore utilizzazione della memoria.
 All'aumentare dell'utilizzazione di memoria auemntano anche i costi di
 ricerca in quanto aumentano i record in 
\emph on
overflow
\emph default
.
 I minimi dei costi di accesso corrispondono ai massimi dell'utilizzazione
 di memoria.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename utilizzoeprestazioni.png
	scale 50

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Infine all'aumentare la capacità dei bucket in overflow 
\begin_inset Formula $C_{OV}$
\end_inset

 si riduce, ovviamente, la lunghezza delle catene di 
\emph on
overflow
\emph default
, di conseguenza si riduce il costo della ricerca.
 Oltre ad un certo limite però, si può notare che aumentando ulteriormente
 
\begin_inset Formula $C_{OV}$
\end_inset

 si ha solamente uno spreco di memoria.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename capacitàoverflow.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph
Linear Hashing Ricorsivo
\end_layout

\begin_layout Standard
È una implementazione del 
\emph on
linear hashing
\emph default
 anche per gestire l'area di 
\emph on
overflow
\emph default
: vengono utilizzate strutture 
\emph on
linear hashing
\emph default
 ognuna per ogni livello, cioè una per l'area 
\emph on
principale
\emph default
, una per il primo livello di area di overflow, una per il secondo livello
 di area di overflow, etc
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Paragraph
Spiral Hashing
\end_layout

\begin_layout Standard
Il problema del 
\emph on
linear hashing
\emph default
 è quello di andare a dividere un 
\emph on
bucket
\emph default
 che non ha problemi di 
\emph on
overflow
\emph default
: sarebbe bello dunque applicare una regola semplice come quella usata dal
 
\emph on
linear hashing
\emph default
 però al bucket che effettivamente va in 
\emph on
overflow
\emph default
.
 Lo 
\emph on
spiral hashing
\emph default
 utilizzando questa idea, tenta di avvicinarsi ad un ottimo connubio.
 Utilizzando una funzione 
\emph on
hash
\emph default
 non 
\emph on
equidistributiva
\emph default
, quindi con probabilità di allocare i record su di un bucket piuttosto
 che su di un altro, rende i 
\emph on
bucket
\emph default
 non equiprobabili all'
\emph on
overflow
\emph default
: nella specifica lo 
\emph on
spiral hashing
\emph default
 tenta di rendere fortemente probabile all'
\emph on
overflow 
\emph default
il primo bucket attraverso la funzione 
\emph on
hash
\emph default
 e conseguentemente di applicare lo split (qui la regola semplice sullo
 split) sempre al 
\emph on
primo 
\emph default
bucket.
 L'organizzazione deve il suo nome al fatto che lo spazio di memoria viene
 pensato come una spirale piuttosto che a una retta, in cui l'area primaria
 viene immaginata come una rivoluzione della spirale stessa, univocamente
 definita da un angolo 
\emph on
z
\emph default
 che la sottende.
 Dati molti vantaggi, lo 
\emph on
spiral hashing
\emph default
 richiede però molta cura nell'essere costruito: infatti fra i primi problemi
 c'è il disaccoppiamento tra gli indirizzi fisici e gli indirizzi logici
 dei bucket.
\end_layout

\end_body
\end_document
