#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part
Operatori relazionali
\end_layout

\begin_layout Section
Introduzione al query processing
\end_layout

\begin_layout Standard
Un sistema 
\emph on
dbms
\emph default
 commerciale deve saper gestire le query in maniera efficente ed efficace,
 quindi deve prima saper implementare la gestione delle query e successivamente
 effettuare un tuning, ovvero migliorarne le presetazioni.
\end_layout

\begin_layout Standard
Uno dei vantaggi dei 
\emph on
dbms
\emph default
 relazionali è che le interrogazioni sono composte da pochi operatori: un'implem
entazione efficiente di tali operatori permette quindi la risoluzione rapida
 delle query.
\end_layout

\begin_layout Standard
Esistono diverse alternative per la realizzazione dei vari operatori (cioè
 un operatore logico può essere implementato attraverso diversi operatori
 fisici) e raramente esiste un algortimo che è 
\begin_inset Quotes eld
\end_inset

sempre
\begin_inset Quotes erd
\end_inset

 migliore degli altri, infatti l'efficienza dipende da diversi fattori quali
 il numero di tuple, il numero di pagine, il buffer, la presenza di indici,
 ecc
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Gli 
\emph on
operatori relazionali
\emph default
 sono operatori che danno come risultato relazioni: si basano sull'algebra
 relazionale e si noti che non concidono perfettamente con gli operatori
 SQL, poichè, allo stesso modo in cui le relazioni non coincidono esattamente
 con le tabelle implementate, le tabelle relazionali non hanno ordinamento
 e possono presentare duplicati, cosa non possibile nelle relazioni poichè
 insiemi.
\end_layout

\begin_layout Standard
Notiamo che esiste una distinzione tra gli 
\series bold
operatori logici
\series default
 dagli 
\series bold
operatori fisici
\series default
 nei 
\emph on
dbms
\emph default
:
\end_layout

\begin_layout Itemize

\emph on
Operatori Logici
\emph default
: (es.
 JOIN) sono un'estensione di quelli dell'algebra relazionale, svogono una
 determinata funzione e producono un insieme di tuple con certe proprietà
\end_layout

\begin_layout Itemize

\emph on
Operatori Fisici
\emph default
: (es.
 JOIN NESTED-LOOPS) sono implementazioni specifiche di un operatore logico;
 in funzione di vari fattori è possibile associare ad ogni operatore fisico
 un costo di esecuzione in modo da poter confrontare ogni volta le implementazio
ni per ottenere la miglior performance.
 Quando una query viene eseguita utilizzerà effettivamente un operatore
 fisico
\end_layout

\begin_layout Standard
I modi alternativi per recuperare i record da una relazione si dicono 
\emph on
vie di accesso
\emph default
 (detti anche 
\emph on
metodi
\emph default
 o 
\emph on
cammini
\emph default
).
 Si noti che sul disco abbiamo la presenza sia dei dati (i dati veri del
 database) sia degli indici e dunque in generale le vie di accesso possibili
 sono a 
\emph on
scansione sequenziale
\emph default
 o ad 
\emph on
accesso ad un indice con un predicato di selezione 
\emph default
gestibile dall'indice stesso.
 Il costo di una via di accesso dipende da alcuni fatori, come ad esempio
 il tempo o in base al numero di operazioni di I/O (di nuovo considereremo
 trascurabile il costo di elaborazione in RAM, ma notiamo che non tutti
 i 
\emph on
dbms
\emph default
 effettivamente trascurano questo dato, si veda DB2 e il parametro TIMERON).
\end_layout

\begin_layout Standard
I modi alternativi per risolvere un'interrogazione si dicono 
\emph on
piani di accesso
\emph default
: sono simigli agli alberi dell'algebra relazionale.
 Ogni piano di accesso fa uso di metodi di accesso ai dati e operatori fisici.
 Si veda la figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pianidiaccesso"

\end_inset

) che risolve la query del codice sotto riportato che andremo in breve a
 commentare:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM Department, Employee
\end_layout

\begin_layout Plain Layout

WHERE WorkDept = DeptNo
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pianidiaccesso"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pianidiaccesso.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si noti che ogni nodo ha una sua rappresentazioni, ad esempio nelle foglie
 sono presenti i dati, al livello subito superiore invece sono presenti
 i 
\emph on
metodi di accesso
\emph default
, salendo ancora di un livello troviamo un
\emph on
 operatore fisico
\emph default
 e infine la risoluzione della query (il numero presente nei nodi rappresenta
 il tempo di esecuzione in RAM cioè il parametro TIMERON di DB2).
\end_layout

\begin_layout Section
Operatori relazionali
\end_layout

\begin_layout Standard
Di seguito una lista degli 
\emph on
operatori relazionali
\emph default
 di cui andremo a vedere il funzionamento:
\end_layout

\begin_layout Enumerate
Ordinamento
\end_layout

\begin_layout Enumerate
Selezione
\end_layout

\begin_layout Enumerate
Proiezione
\end_layout

\begin_layout Enumerate
Join
\end_layout

\begin_layout Enumerate
Operatori insiemistici (unione, differenza)
\end_layout

\begin_layout Enumerate
Group by
\end_layout

\begin_layout Enumerate
Operatori aggregati (avg, sum, count)
\end_layout

\begin_layout Enumerate
Operatori di modifica (update, delete, insert)
\end_layout

\begin_layout Standard
Assumiamo che il costo di produzione del risultato equivalga a zero, quindi
 lo ignoreremo: questo poichè in qualsiasi modo valutiamo la query, il risultato
 che essa produce è sempre lo stesso, quindi anche se cambiamo il piano
 di accesso (e quindi cambiamo il costo poichè ogni piano di accesso ha
 un costo diverso) il costo di produzione del risultato rimane invariato,
 dunque possiamo tranquillamente ignorarlo.
\end_layout

\begin_layout Standard
La 
\series bold
simbologia 
\series default
che utilizzeremo è la seguente:
\end_layout

\begin_layout Description
N(R) numero di record della relazione R
\end_layout

\begin_layout Description
P(R) numero di pagine della relazione R
\end_layout

\begin_layout Description
Len(R) lunghezza (in byte) di un record della relazione R
\end_layout

\begin_layout Description
NK(R.A) numero di valori distinti dell'attributo A della relazione R
\end_layout

\begin_layout Description
TP(R) numero di tuple per pagina: vale la seguente relazione 
\begin_inset Formula $P(R)=\left\lceil \frac{N(R)}{TP(R)}\right\rceil $
\end_inset


\end_layout

\begin_layout Description
B numero di pagine buffer
\end_layout

\begin_layout Description
L(IX) numero di pagine foglia dell'indice IX
\end_layout

\begin_layout Standard
Ometteremo R e IX se chiari dal contesto.
\end_layout

\begin_layout Standard
Lo 
\emph on
schema di riferimento
\emph default
 su cui ci baseremo è il seguente.
\end_layout

\begin_layout Standard

\family typewriter
Sommelier (
\bar under
sid: integer
\bar default
, snome: string, val: integer, età: integer)
\end_layout

\begin_layout Standard

\family typewriter
Vini (
\bar under
vid: integer
\bar default
, vnome: string, cantina: string)
\end_layout

\begin_layout Standard

\family typewriter
Recensioni (
\bar under
sid: integer, vid: integer, anno: integer
\bar default
, rivista string)
\end_layout

\begin_layout Standard
Gli attributi sottolineati sono gli attributi chiave della relazione associata.
 Indicheremo per semplicità con S la relazione Sommelier, V la relazione
 Vini e R la relazione Recensioni.
 I dati in nostro possesso sono
\end_layout

\begin_layout Itemize
Len(S)=50B - N(S)=40K - TP(S)=80 - P(S) = 
\begin_inset Formula $\left\lceil \frac{N}{TP}\right\rceil =500$
\end_inset


\end_layout

\begin_layout Itemize
Len(V)=40B - N(V)=10K - TP(V)=100 - P(V)=100
\end_layout

\begin_layout Itemize
Len(R)=40B - N(R)=100K - TP(R)=100 - P(R)=1K
\end_layout

\begin_layout Standard
Dove Len indica la lunghezza di un record in byte, N indica il numero di
 tuple nella relazione, TP il numero di tuple per pagina e infine P il numero
 di pagine per memorizzare tutti i record della relazione.
\end_layout

\begin_layout Subsubsection
Algebra Relazione
\end_layout

\begin_layout Standard
Rivediamo, in sintesi, i tre operatori più importanti dell'algebra relazionale:
 
\emph on
selezione
\emph default
, 
\emph on
proiezione
\emph default
 e 
\emph on
join
\emph default
 (e alter join).
\end_layout

\begin_layout Paragraph
SELEZIONE
\end_layout

\begin_layout Standard
Indicata con il simbolo 
\begin_inset Formula $\sigma$
\end_inset

, è un operatore 
\emph on
unario
\emph default
 che ha come dati di ingresso una 
\emph on
relazione R
\emph default
 e una 
\emph on
condizione booleana 
\emph default
(ricorda che una condizione booleana in SQL è un predicato che ha come possibili
 risultati 
\emph on
True False 
\emph default
o 
\emph on
Null
\emph default
) e che restituisce come risultato tutte e sole le tuple della relazione
 che soddisfano la condizione booleana.
 Esempio 
\begin_inset Formula $\sigma_{STUDENTI}(nome="pippo")$
\end_inset


\end_layout

\begin_layout Paragraph
PROIEZIONE
\end_layout

\begin_layout Standard
Indicata con il simbolo 
\begin_inset Formula $\pi$
\end_inset

, è un operatore 
\emph on
unario
\emph default
 che ha come dati di ingresso una 
\emph on
relazione R 
\emph default
e un'
\emph on
insieme di attributi
\emph default
 della relazione stessa e che restituisce una nuova relazione, sottoinsieme
 della relazione di input R, in cui sono presenti solo le colonne degli
 attributi indicati.
 Si noti che se nell'algebra lineare questo potrebbe portare ad eliminare
 alcune tuple che nella nuova relazione potrebbero risultare duplicate,
 in SQL questo non è vero (si usa la cluasola DISTINCT per l'eliminazione
 dei duplicati).
 Esempio 
\begin_inset Formula 
\[
\pi_{\sigma_{STUDENTI}(nome="pippo")}(matr,email)
\]

\end_inset


\end_layout

\begin_layout Standard
In alcuni casi questi operatori possono commutare fra loro, in altri no.
 L'esempio appena mostrato non è commutativo, infatti risulta diverso da
\begin_inset Formula 
\[
\sigma_{\pi_{STUDENTI}(matr,email)}(nome="pippo")
\]

\end_inset


\end_layout

\begin_layout Standard
tanto che questo esempio non è neanche più valido (faccio una ricerca su
 un attributo non più esistente).
\end_layout

\begin_layout Paragraph
JOIN
\end_layout

\begin_layout Standard
Indicato con il simbolo ><, l'operatore di 
\emph on
join 
\emph default
esiste in molte varianti, il più semplice è il 
\emph on
join naturale
\emph default
, cioè il join senza alcuna specifica, che applica un uguaglianza sugli
 attributi di ugual nome (è dunque un operatore binario).
 In caso tutti gli attributi abbiano nomi differenti, è possibile specificare
 esplicatamente gli attributi su cui fare join 
\begin_inset Formula $><_{matr=matrs}$
\end_inset

 e in questo caso si parla di 
\emph on
Theta-join
\emph default
.
\end_layout

\begin_layout Standard
L'
\series bold
alter-join
\series default
, il cui simbolo è 
\begin_inset Formula $=><$
\end_inset

 è diverso dal semplice join naturale, in quanto aggiunge anche tutte le
 tuple (chiamate 
\emph on
tuple dandling) 
\emph default
su cui non riesce a far 
\emph on
matching
\emph default
.
 Le tuple dandling vengono completate, per gli attributi che non fanno parte
 dello schema ovvero per attributi non presenti in una relazione ma presenti
 nell'altra, con valori NULL.
\end_layout

\begin_layout Paragraph
Estensioni
\end_layout

\begin_layout Standard
Si prenda come esempio la seguente query
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT CODC, COUNT(*)
\end_layout

\begin_layout Plain Layout

FROM ESAMI
\end_layout

\begin_layout Plain Layout

GROUP BY CODC
\end_layout

\begin_layout Plain Layout

HAVING COUNT(*)>50
\end_layout

\begin_layout Plain Layout

ORDER BY CONT(*) DESC
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Essa raggruppa (GROUP BY) tutti gli esami per codice corso (CODC), e per
 ogni gruppo ne valuta l'
\emph on
Having
\emph default
 (l'equivalente della clausola WHERE ma applicata ai gruppi): viene valutato
 per ogni codice corso quante tuple sono presenti, e se sono superiori a
 50 allora viene selezionato: di tutti i gruppi presi restituisco solo il
 codice corso e il numero di tuple ordinandolo (ORDER BY) in modo decrescente
 sul numero di tuple.
\end_layout

\begin_layout Standard
Di fatto abbiamo introdotto un gran numero di estensioni dell'algebra relazional
e.
 Andiamo in velocità ad elencare le estensioni che più vengono usate:
\end_layout

\begin_layout Itemize

\series bold
Estensioni dell'algebra:
\series default
 
\emph on
GROUP BY, ORDER BY, HAVING
\end_layout

\begin_layout Itemize

\series bold
Operatori insiemistici: 
\series default
\emph on
UNION, INTERSECT, EXEPT
\end_layout

\begin_layout Itemize

\series bold
Funzioni Aggregate:
\series default
 
\emph on
AVG, SUM, COUNT, MAX, MIN
\end_layout

\begin_layout Subsection
Ordinamento (sort)
\end_layout

\begin_layout Standard
Nonostante non sia un operatore vero e proprio (poichè l'algebra relazionale
 tratta insiemi e gli insiemi non sono ordinati), lo trattiamo poichè è
 un'operazione molto importante.
 Viene definito attraverso la 
\emph on
clausola 
\family typewriter
\emph default
ORDER BY.
 
\family default
Viene utilizzato nel 
\emph on
bulk-load
\emph default
 di un undice.
 Vedremo come elimina le copie di record (attraverso la clausola 
\family typewriter
DISTINCT
\family default
).
 Viene usato in diversi algoritmi di join e di group by.
\end_layout

\begin_layout Standard
Oltre al caso base che considereremo, esistono delle 
\emph on
varianti 
\emph default
all'operazione di ordinamento degne di nota: se richiesto, infatti, si possono
 eliminare i 
\emph on
duplicati
\emph default
 durante l'esecuzione del sort (codice di seguito) per una maggiore efficenza,
 oppure, se alcuni attributi in input non servono nell'output è possibile
 eliminarli durante l'esecuzione del sort stesso.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT DISTINCT LastName
\end_layout

\begin_layout Plain Layout

FROM Employee
\end_layout

\begin_layout Plain Layout

ORDER BY LastName
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vediamo subito un esempio (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempiordinamento"

\end_inset

) di ordinamento che risolve la seguente query
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT Cognome, Nome, Matricola
\end_layout

\begin_layout Plain Layout

FROM Studenti
\end_layout

\begin_layout Plain Layout

ORDER BY Cognome, Nome
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempiordinamento"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempioordinamento.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bisogna innanzitutto distinguere tra gli algoritmi di ordinamento possibili
 in 
\emph on
RAM
\emph default
 e quelli invece in 
\emph on
memoria secondaria.
\end_layout

\begin_layout Standard
Gli algoritmi di sort in RAM (Bubblie sort, Insertion sort, Shell sort,
 Merge sor, Heapsort, Quicksort, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

) hanno prestazioni generalmente molte buone, tipicamente 
\begin_inset Formula $O(nlogn),\, O(n^{2})$
\end_inset

 (ad esempio il 
\emph on
mergesort 
\emph default
ha sempre prestanzione 
\begin_inset Formula $n\cdot logn$
\end_inset

 mentre il 
\emph on
quicksort
\emph default
, in media 
\begin_inset Formula $n\cdot logn$
\end_inset

, in alcune istanze ha complessità n
\begin_inset Formula $^{2}$
\end_inset

).
 In genere richiedono che il dataset sia interamente contenuto in memoria
 (non è opportuno caricare tutto il data set in memoria virtuale poichè
 poi le pagine verrebbero allocate in modo casuale) eccetto per il 
\emph on
merge sort
\emph default
 che richiede la presenza di solo 2 elementi in memoria principale.
 Ecco dunque che ci viene possibile utilizzare l'algoritmo di 
\emph on
merge sort
\emph default
 in memoria secondaria: l'idea di base è che, siccome i dati non riescono
 a stare tutti in memoria, possiamo dividerli in sequenza, chiamate 
\emph on
run
\emph default
, più piccole, ordinare le sequenze una ad una e infine fondere le sequenze
 un elemento per volta.
 Di fatto ogni sequenza ha le dimensioni massime di una pagina (e ad ogni
 passo la grandezza della sequenza avrà dimensioni massime di 2 pagine,
 poi di 4 pagine, etc
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

).
 Il primo passo di ordinamento utilizza un algoritmo di sort in RAM (ad
 esempio il quicksort).
\end_layout

\begin_layout Standard
In figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:schemautilizzomergesort"

\end_inset

) viene mostrato lo schema di principio
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:schemautilizzomergesort"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename schemautilizzomergesort.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Facciamo un rapido esempio per ricordare il funzionamento del merge sort
 e applichiamolo ad un caso studio:
\begin_inset Newline newline
\end_inset

Ho 2 record per pagina.
 
\begin_inset Newline newline
\end_inset

L'input assegnato è: 3, 4, 6, 2, 9, 4, 8, 7, 5, 6, 3, 1, 2
\end_layout

\begin_layout Enumerate
passo: [3,4], [6,2], [9,4], [8,7], [5,6], [3,1], [2]
\end_layout

\begin_layout Enumerate
passo: [3,4], [2,6], [4,9], [7,8], [5,6], [1,3], [2]
\end_layout

\begin_layout Enumerate
passo: [2,3,4,6], [4,7,8,9], [1,3,5,6], [2]
\end_layout

\begin_layout Enumerate
passo: [2,3,4,4,6,7,8,9], [1,2,3,5,6]
\end_layout

\begin_layout Enumerate
passo: [1,2,2,3,3,4,4,5,6,6,7,8,9]
\end_layout

\begin_layout Standard
Analizziamo il costo del 
\emph on
Mergesort
\emph default
: sono usate solo 3 buffer, 2 per l'input e una per l'output: quando il
 buffer di output è pieno lo devo scrivere su disco.
 Si legge la prima pagina da ciascuna 
\emph on
run
\emph default
 e si può quindi determinare la prima pagina dell'
\emph on
output
\emph default
: quando tutti i record di una pagina di run sono stati consumati si legge
 un'altra pagina della run.
 Si veda in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:mergesortgestionebuffer"

\end_inset

) come il Merge-sort gestisce il buffer.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:mergesortgestionebuffer"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename mergesortgestionebuffer.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se il numero di pagine del file di input è 2
\begin_inset Formula $^{k}$
\end_inset

 allora:
\end_layout

\begin_layout Itemize
il primo passo produce 2
\begin_inset Formula $^{k}$
\end_inset

 
\emph on
run
\emph default
 di una pagina
\end_layout

\begin_layout Itemize
il secondo passo produce 2
\begin_inset Formula $^{k-1}$
\end_inset

 
\emph on
run
\emph default
 di 2 pagine
\end_layout

\begin_layout Itemize
il terzo passo produce 2
\begin_inset Formula $^{k-2}$
\end_inset

 
\emph on
run
\emph default
 di 4 pagine
\end_layout

\begin_layout Itemize
il k-esimo passo (l'ultimo) produce 1 
\emph on
run
\emph default
 di 2
\begin_inset Formula $^{k}$
\end_inset

 pagine
\end_layout

\begin_layout Standard
Il numero totale di passi è 
\begin_inset Formula $\left\lceil \log_{2}P\right\rceil +1$
\end_inset

 (dove il +1 è dovuto al primo passo di 
\emph on
sort 
\emph default
prima evidenziato) e dunque il costo è pari a 
\begin_inset Formula $P\cdot(\left\lceil \log_{2}P\right\rceil +1)$
\end_inset

 letture e 
\begin_inset Formula $P\cdot(\left\lceil \log_{2}P\right\rceil +1)$
\end_inset

 scritture (dove il +1 in entrambi i casi è dovuto per leggere e scrivere
 i primi run per il primo passo di sort).
 Notiamo che l'ultimo passo di scrittura è non necessario, infatti l'ultimo
 passo implica avere il risultato e non è necessario scriverlo su disco,
 ma semplicemente restituirlo a chi aveva demandato l'operazione di ordinamento.
\end_layout

\begin_layout Standard
Facciamo un esempio.
 Dato il numero di pagine P uguale a 
\begin_inset Formula $P=8192$
\end_inset

, applicando semplicemente le formule avrei un costo di 
\begin_inset Formula $8192\cdot(\log_{2}8192+1)\, letture+8192\cdot(\log_{2}8192+1)\, scritture=229376$
\end_inset

 operazioni di I/O: se ogni operazione I/O richiede 10ms l'ordinamento con
 merge-sort richiederebbe circa 38 minuti (impensabile).
 Un primo miglioramento si potrebbe ottenere ordinando 
\emph on
B pagine
\emph default
 alla volta invece che una, diminuendo il costo a 
\begin_inset Formula $2\cdot P\cdot(\left\lceil \log_{2}\frac{P}{B}\right\rceil +1)$
\end_inset

 operazioni.
 Applicando la nuova formula all'esempio precedente e imponendo 
\begin_inset Formula $B=11$
\end_inset

, l'operazione di ordinamento richiederebbe 30 minuti invece che 38 (ma
 è ancora troppo!).
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Guardiamo ora un altro algoritmo di ordinamento, il 
\emph on
sort-merge a Z vie
\emph default
.
 Notiamo che se anche il costo del 
\emph on
mergesort 
\emph default
è 
\begin_inset Formula $O(P\cdot\log P)$
\end_inset

 il buffer non viene utilizzato al meglio durante l'operazione di fusione:
 infatti l'operazione di fusione effettuata solo su due run alla volta è
 il fattore che più incide sul peggioramento delle prestazioni.
 Ecco allora l'idea base del sort-merge: supponenedo di avere B=Z+1 pagine
 nel buffer a disposizione, invece che fondere 2 pagine alla volta se ne
 possono fondere Z alla volta (serve sempre una pagina in più per l'output).
 Aumentando il 
\emph on
fan-in
\emph default
 del passo di 
\emph on
merge
\emph default
 si aumenta la base del logaritmo.
 Si veda la figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:mergesortzvieschema"

\end_inset

) per capire meglio l'idea di base.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:mergesortzvieschema"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename mergesortzvieschema.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vediamo come funziona l'algoritmo sort-merge a Z vie in pseudo codice.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

leggi il file B pagine alla volta
\end_layout

\begin_layout Plain Layout

ordina le pagine
\end_layout

\begin_layout Plain Layout

scrivi le pagine in un file ausiliario (run)
\end_layout

\begin_layout Plain Layout

while(numero di run>1)
\end_layout

\begin_layout Plain Layout

	while(ci sono ancora run da fondere)
\end_layout

\begin_layout Plain Layout

		seleziona Z run dal passo precedente
\end_layout

\begin_layout Plain Layout

		leggi le run in memoria una pagina per volta
\end_layout

\begin_layout Plain Layout

		fondi le run
\end_layout

\begin_layout Plain Layout

		scrivi sul buffer di output una pagina alla volta
\end_layout

\end_inset


\end_layout

\begin_layout Standard
e vediamolo dunque applicato ad un esempio.
\begin_inset Newline newline
\end_inset

B=Z+1=11 - P=8192
\end_layout

\begin_layout Enumerate
passo: produce 
\begin_inset Formula $\left\lceil \frac{8192}{11}\right\rceil =745$
\end_inset

 
\emph on
run
\emph default
 di 11 pagine ciascuna (i primi 744 run hanno 11 pagine
\begin_inset Formula $\rightarrow744\cdot11=8184$
\end_inset

), tranne l'ultimo di 8 pagine (per arrivare a 8192)
\end_layout

\begin_layout Enumerate
passo: 
\emph on
merge
\emph default
 a Z=10 vie che produce 
\begin_inset Formula $\left\lceil \frac{745}{10}\right\rceil =75$
\end_inset

 run di 110 pagine (i primi 74 run hanno 110 pagine
\begin_inset Formula $\rightarrow74\cdot110=8140$
\end_inset

), tranne l'ultimo di 52 pagine (per arrivare a 8192)
\end_layout

\begin_layout Enumerate
passo: 
\emph on
merge a 
\emph default
10 vie che produce 
\begin_inset Formula $\left\lceil \frac{75}{10}\right\rceil =8$
\end_inset

 run di cui di 1100 pagine (i primi 7 run hanno 1100 pagine
\begin_inset Formula $\rightarrow1100\cdot7=7700$
\end_inset

) tranne l'ultimo di 492 pagine (per arrivare a 8192)
\end_layout

\begin_layout Enumerate
passo: 
\emph on
merge a 
\emph default
8 vie (essendo Z=10 ma avendo solo 8 run so che è l'ultimo passo) che produce
 le 8192 pagine ordinate
\end_layout

\begin_layout Standard
Analizziamo il costo del 
\emph on
sortmerge a Z vie
\emph default
: nell'esempio appena descritto il costo è dato dalla 
\emph on
lettura
\emph default
 delle 8192 pagine in 4 passi 
\begin_inset Formula $\rightarrow8192\cdot4=32768$
\end_inset

 operazioni I/O più il costo dovuto alla 
\emph on
scrittura 
\emph default
delle 8192 pagine in 4 passi 
\begin_inset Formula $\rightarrow8192\cdot4=32768$
\end_inset

 operazioni I/O per un totale di 
\begin_inset Formula $32768+32768=65536$
\end_inset

 operazioni di I/O (circa 11 minuti).
 Più in generale il
\emph on
 numero di passi
\emph default
 è dato da 
\begin_inset Formula $\left\lceil \log_{Z}\left\lceil \frac{P}{Z+1}\right\rceil \right\rceil +1\thickapprox\left\lceil \log_{Z}P\right\rceil $
\end_inset

 e il costo è dato da P 
\emph on
letture
\emph default
 più P 
\emph on
scritture
\emph default
 per ogni singolo passo (quindi il costo è dato da 
\begin_inset Formula $2\cdot P\cdot numero\, di\, passi$
\end_inset

).
 Si veda la figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:mergesortzvie"

\end_inset

) che descrive il numero di passi da fare in funzione del numero di pagine
 P e del numero di vie Z.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:mergesortzvie"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename mergesortzvie.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alcune considerazioni: se Z risulta essere troppo grande, il 
\emph on
merge a Z vie
\emph default
 può essere costoso dal punto di vista della CPU e quindi, ad esempio, siccome
 il numero di passi tra Z=128 e Z=256 non varia è preferibile usare Z=128
 per diminuire il costo computazionale dato alla CPU.
 Altre ottimizzazioni sono possibili per evitare i tempi morti della CPU
 in attesa di una lettura, ad esempio il 
\emph on
double buffering 
\emph default
in cui si leggono 2 pagine per ogni 
\emph on
run 
\emph default
cioè terminata di leggere la prima si legge immediatamente la successiva.
\end_layout

\begin_layout Standard
Anche avendo molto spazio a disposizione in RAM (quindi un B grande) la
 soluzione migliore di merge potrebbe non essere scegliere Z=B-1: distinguendo
 tra le letture random e le letture sequenziali si perviene a scelte più
 accurate infatti finora abbiamo supposto che tutte le letture effettuate
 da disco siano letture 
\begin_inset Quotes eld
\end_inset

random
\begin_inset Quotes erd
\end_inset

 quindi con costo 1, ma di fatto se considero letture sequenziali il costo
 diminuisce.
 Denominato con Ts il tempo di seek, Tr il tempo di latenza e Tt il tempo
 di trasferimento di una pagina, il modello considera che il costo di X
 letture di pagine sequenziali (quindi ho X pagine) sia
\begin_inset Formula 
\[
Ts+Tr+X\cdot Tt=\left(\frac{Ts+Tr}{Tt}+X\right)\cdot Tt=(C+X)\cdot Tt
\]

\end_inset


\end_layout

\begin_layout Standard
dove 
\begin_inset Formula $C=\frac{Ts+Tr}{Tt}\thickapprox10\div50$
\end_inset

 e si nota che la lettura sequenziale di pagine è data da 
\begin_inset Formula $C+X$
\end_inset

.
 Nel caso di lettura Random il costo di X pagine è invece dato da
\begin_inset Formula 
\[
X\cdot(Ts+Tr+Tt)=X\cdot(\frac{Ts+Tr+Tt}{Tt})\cdot Tt=X\cdot(C+1)\cdot Tt=(X\cdot C+X)\cdot Tt
\]

\end_inset


\end_layout

\begin_layout Standard
quindi pago X volte il costo di seek.
\end_layout

\begin_layout Standard
Durante il 
\emph on
sort interno
\emph default
 si leggono e si scrivono B pagine alla volta (quindi sostituisco B a X).
 Il costo, usando Tt come unità di misura, si può stimare a circa 
\begin_inset Formula $2\cdot\frac{P}{B}\cdot(C+B)$
\end_inset

 in cui 
\begin_inset Formula $2\cdot\frac{P}{B}$
\end_inset

 rappresenta il numero di seek (si noti che la formula è approssimata se
 P non è multiplo di B).
 Si vede che ho ridotto il numero di seek di un fattore pari a B.
\end_layout

\begin_layout Standard
Se voglio sfruttare le letture sequenziali, anziche utilizzare Z buffer
 per ogni run, utilizzo Z frame per ciascun buffer e dunque per la fuzione
 si organizzano i B-1 buffer dedicati alla lettura in Z 
\begin_inset Quotes eld
\end_inset

frame
\begin_inset Quotes erd
\end_inset

 di FS pagine ciascuno (il che vuol dire che si leggeranno FS pagine alla
 volta).
\end_layout

\begin_layout Standard
Tentiamo di capire meglio: prendo un run e carico FS pagine alla volta (invece
 che una pagina alla volta) mettendole nel frame, ed essendo letture sequenziali
 non ho impatto nel costo.
 La run non la leggo una una pagina alla volta ma FS alla volta, riducendo
 di FS il tempo di seek.
\end_layout

\begin_layout Standard
Per ogni passo di fusioni si hanno i seguenti costi (le operazioni di scrittura
 rimangono tutte random): Lettura ha costo 
\begin_inset Formula $\frac{P}{FS}\cdot(C+FS)$
\end_inset

 e la scrittura ha ancora costo 
\begin_inset Formula $P\cdot(C+1)$
\end_inset

, complessivamente il costo, utilizzando Tt come unità di misura, diventa
\begin_inset Formula 
\[
2\cdot\frac{P}{B}\cdot(C+B)+\left(\frac{P}{FS}\cdot(C+FS)+P\cdot(C+1)\right)\cdot\left\lceil \log_{Z}\frac{P}{B}\right\rceil 
\]

\end_inset


\end_layout

\begin_layout Standard
Considerando solo la parte che varia con Z (cioè le letture in fase di fusione)
 e ricordando che 
\begin_inset Formula $FS=\frac{B-1}{Z}$
\end_inset

 si deve minimizzare 
\begin_inset Formula 
\[
\left(P\cdot C\cdot\frac{Z}{B-1}+P\cdot(C+2)\right)\left\lceil \log_{Z}\frac{P}{B}\right\rceil 
\]

\end_inset


\end_layout

\begin_layout Standard
Esempio.
 
\begin_inset Formula $C=10$
\end_inset

 e 
\begin_inset Formula $P=50000$
\end_inset

 al variare di B si ottengono i seguenti risultati (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:mergesortzvieesempiotabellare"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:mergesortzvieesempiotabellare"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename mergesortzvieesempiotabella.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Morale, anche avendo un modello più preciso ci si accorge che non ha senso
 per i 
\emph on
dbms
\emph default
 aumentare troppo Z, poichè, si veda la tabella, aumentando anche Z non
 si migliora il costo.
\end_layout

\begin_layout Standard
Quanto visto può ovviamente estendersi a considerare il caso in cui anche
 per le scritture si operi in maniera sequenziale.
 Si possono anche considerare gli effetti della cache.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

L'ultimo ordinamento che controlliamo è il 
\emph on
sorting con B
\begin_inset Formula $^{+}$
\end_inset

-tree.
 
\emph default
Se l'indice è 
\emph on
clustered
\emph default
 (ordinato come il file/relazione) allora le pagine del file sono ordinate
 (almeno logicamente), dunque il costo è dato da 
\begin_inset Formula $Costo=L+P$
\end_inset

 dove L corrisponde al numero delle foglie dell'albero, mentre P al numero
 di pagine del file, se l'indice oltre ad essere clustered è una struttura
 di memorizzazione primaria (cioè memorizza i record e non i PID/RID) allora
 il costo è dato solo da 
\begin_inset Formula $Costo=L$
\end_inset

.
 A differenza se l'indice è 
\emph on
unclustered 
\emph default
ogni record causa la lettura di una pagina e dunque il costo diventa 
\begin_inset Formula $Costo=L+N\thickapprox N$
\end_inset

 dove N equivale al numero dei record; se però tutti i campi che ci interessano
 sono all'interno dell'indice allora il costo si abbatte e diventa 
\begin_inset Formula $Costo=L$
\end_inset

.
\end_layout

\begin_layout Standard
Si noti un ulteriore osservazione.
 Prendiamo come esempio un indice costruito sull'attributo COGNOME della
 relazione STUDENTI, che però risulta essere 
\emph on
unclustered.
 
\emph default
La query che vogliamo risolvere è
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT cognome 
\end_layout

\begin_layout Plain Layout

FROM studenti
\end_layout

\begin_layout Plain Layout

ORDER by cognome
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nonostante l'indice risulta 
\emph on
unclestered
\emph default
 il fatto che come output io voglia solo l'ordinamento sull'attributo COGNOME,
 il costo è semplicemente 
\begin_inset Formula $Costo=L$
\end_inset

 poichè l'indice risulterà ordinato per conto suo (anche se unclustered
 con la relazione) e non dovendo fornire dati ulteriori se non il cognome
 stesso il costo si abbatte, nel risultato non dovrà neppure restituire
 i RID, perchè tanto non ha senso accedere ai dati poichè le informazioni
 su come ordinare l'attributo cognome sono reperibili dall'indice stesso
 (creato appunto sull'attributo cognome).
 Se volessi anche mantenere i 
\emph on
duplicati 
\emph default
nella richiesta, allora posso sempre utilizzare esclusivamente l'indice,
 in quanto nell'indice ricordiamo sono salvate informazioni <chiave,RID>
 ma in caso di duplicati il RID è una lista di RID: di conseguenza nel risultato
 di ordinamento genererà tante 
\begin_inset Quotes eld
\end_inset

chiavi
\begin_inset Quotes erd
\end_inset

 dello stesso tipo quanto è lunga la lista di RID.
\end_layout

\begin_layout Standard
Se ora volessi risolvere questa query
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT cognome, matr 
\end_layout

\begin_layout Plain Layout

FROM studenti
\end_layout

\begin_layout Plain Layout

ORDER BY cognome
\end_layout

\end_inset

 l'indice prima descritto non basterebbe (poichè non ho l'informazione su
 matr che devo reperire sui dati), e si ricadrebbe nuovamente nel caso di
 costo pari a 
\begin_inset Formula $Costo=L+N$
\end_inset

.
 Ecco che, in molti casi, i sistemi 
\emph on
dbms 
\emph default
includono negli indici non solo la chiave per la ricerca, ma aggiungono
 valori di uno o più attributi reputati significativi evitando così di accedere
 ai dati aumentando dunque la performance.
\end_layout

\begin_layout Subsection
Selezione
\end_layout

\begin_layout Standard
Si supponga di avere una query del tipo
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM Recensioni as R
\end_layout

\begin_layout Plain Layout

WHERE R.rivista="Sapore DiVino"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quale risulta il 
\emph on
percorso d'accesso 
\emph default
migliore per la sua risoluzione? La scelta dipende da molti fattori come
 ad esempio quanti record compongono il risultato o se esiste un indice
 in grado di gestire la query.
\end_layout

\begin_layout Standard
Effettivamente non si può sapere a priori quanti record compongono il risultato,
 quindi dobbiamo effettuare una stima equivalente a 
\begin_inset Formula $E=f\cdot N$
\end_inset

 dove 
\emph on
f
\emph default
 è detto 
\emph on
fattore di selettività 
\emph default
della query (si noti che più 
\emph on
f
\emph default
 risulta piccolo più la query è selettiva) mentre N è il numero di record
 della relazione che risulta essere un dato noto (grazie ai 
\emph on
cataloghi
\emph default
).
 Bisogna dunque valutare il 
\emph on
fattore di selettività f
\emph default
.
 Se si suppongono i valori dell'attributo coinvolto uniformemente distribuiti
 nel predicato di selezione allora 
\emph on
f
\emph default
 risulta essere 
\begin_inset Formula $f=\frac{E_{k}}{N_{k}}$
\end_inset

 dove E
\begin_inset Formula $_{k}$
\end_inset

 è il numero di valori attesi nel risultato (e nuovamente N
\begin_inset Formula $_{k}$
\end_inset

 è il numero di record del risultato).
\end_layout

\begin_layout Standard
Notiamo che il fattore di selettività cambia a seconda del 
\emph on
predicato 
\emph default
utilizzato come si vede nella seguente tabella (Tabella 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:fattoreselettivita"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:fattoreselettivita"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
resizebox{
\backslash
textwidth}{!}{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Predicato
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Fattore di selettività f
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f=\frac{1}{N_{k}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IN set
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f=\frac{|set|}{N_{k}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $<v$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f=\frac{(v-min)}{(max-min)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
between
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f=\frac{(high-low)}{(max-min)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attributo non numerico e 
\begin_inset Formula $<v$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f=\frac{1}{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attributo non numerico e 
\emph on
between
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f=\frac{1}{3}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P AND Q
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f=f_{P}\cdot f_{Q}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f=1-f_{P}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P or Q
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f=f_{P}+f_{Q}-f_{P}\cdot f_{Q}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notiamo che per gli attributi non numerici, si utilizzano i loro valori.
\end_layout

\begin_layout Standard
Analizziamo dunque i 
\emph on
costi
\emph default
 della Selezione: 
\end_layout

\begin_layout Itemize
Se 
\bar under
non
\bar default
 è presente alcun 
\emph on
indice
\emph default
 e il 
\emph on
file 
\emph default
è 
\emph on
disordinato
\emph default
 allora il costo è uguale al numero delle pagine 
\begin_inset Formula $Costo=P$
\end_inset


\end_layout

\begin_layout Itemize
Se 
\bar under
non
\bar default
 è presente alcun 
\emph on
indice
\emph default
 e il 
\emph on
file 
\emph default
è 
\emph on
ordinato 
\emph default
allora il costo è dovuto a una ricerca binaria 
\begin_inset Formula $Costo=\log_{2}P+f\cdot P$
\end_inset


\end_layout

\begin_layout Itemize
Indice attraverso B+tree allora il costo è dato da 
\begin_inset Formula $Costo=h+f\ldotp L+costo\, file\, dati$
\end_inset

 dove 
\emph on
h
\emph default
 è l'altezza del B+tree e
\end_layout

\begin_deeper
\begin_layout Itemize
Se indice 
\emph on
clustered
\emph default
 allora 
\begin_inset Formula $costo\, file\, dati=f\cdot P$
\end_inset


\end_layout

\begin_layout Itemize
Se indice 
\emph on
unclustered
\emph default
 allora 
\begin_inset Formula $costo\, file\, dati=E_{K}\cdot\phi(\frac{N}{N_{k}},P)$
\end_inset

 dove E
\begin_inset Formula $_{K}$
\end_inset

 è il numero dei valori attesi mentre la funzione 
\begin_inset Formula $\phi$
\end_inset

 è la stima di Cardennas o Yao di quante pagine bisogna accedere per la
 lettura di un record.
\end_layout

\begin_layout Itemize
Se l'interrogazione della selezione avviene attraverso il predicato IN occorres
 empre ripartire dalla radice per ogni valore, dunque è come se l'indice
 risultasse essere 
\emph on
unclustered
\end_layout

\end_deeper
\begin_layout Itemize
Indice attraverso struttura 
\emph on
hash 
\emph default
e con 
\emph on
predicato di uguaglianza
\emph default
 ('=') allora il costo è dato da 
\begin_inset Formula $Costo=1+costo\, file\, dati$
\end_inset


\end_layout

\begin_layout Standard
Notiamo che il costo di selezione finora descritto riguardava una condizione
 semplice, cioè se la condizione WHERE fa riferimento ad un solo attributo.
 Cosa succede in caso contrario? Bisogna attuare alcune tecniche: in primo
 luogo bisogna riscrivere la condizione in 
\emph on
forma normale congiuntiva
\emph default
 (CNF o nota come prodotto di somme, in cui ogni AND è una somma e ogni
 OR è un prodotto), quindi occorre valutare se esiste un indice in grado
 di gestire la condizione siffata (cioè in CNF).
 Nuovamente bisogna distinguere il caso di indici 
\emph on
hash
\emph default
 o indici B+tree.
\end_layout

\begin_layout Standard
Introduciamo prima degli esempi per poi spiegare in maniera più generale
 ciò che stiamo descrivendo.
\end_layout

\begin_layout Standard
Supponiamo di avere un indice sulla relazione R (Recensioni) applicato agli
 attributi 
\series bold
(R.sid, R.vid, R.rivista)
\series default
.
 
\begin_inset Newline newline
\end_inset

In caso di 
\emph on
indice hash
\emph default
 possiamo utilizzare l'indice stesso per condizioni come
\begin_inset Newline newline
\end_inset


\family typewriter
rivista='Sapore DiVino' AND sid=3 AND vid=5
\family default

\begin_inset Newline newline
\end_inset

ma non per
\begin_inset Newline newline
\end_inset


\family typewriter
rivista='Sapore DiVino' AND sid=3 OR anno=2005
\family default

\begin_inset Newline newline
\end_inset

poichè in questo ultimo caso non c'è modo di avere la risoluzione applicata
 all'attributo anno.
\begin_inset Newline newline
\end_inset

In caso di 
\emph on
indice b+tree
\emph default
 applicato agli stessi attributi, esso risolvere query con condizioni del
 tipo
\begin_inset Newline newline
\end_inset


\family typewriter
rivista='Sapore DiVino' AND sid=3 AND vid=5 OR sid=7 AND vid=12
\family default

\begin_inset Newline newline
\end_inset

ma non riesce con condizioni del tipo
\begin_inset Newline newline
\end_inset


\family typewriter
rivista='Sapore DiVino' AND sid=3 o anno=2005
\family default

\begin_inset Newline newline
\end_inset

per lo stesso problema indicato negli indici hash.
\end_layout

\begin_layout Standard
Proviamo ora a cambiare l'indice e ad applicarlo sempre alla relazione R
 (Riviste) ma sugli attributi 
\series bold
(R.sid, R.vid)
\series default
, in questo caso sia che l'indice sia hash sia che sia costrutito con un
 B+tree esso risolve query con condizioni del tipo
\begin_inset Newline newline
\end_inset

rivista='Sapore DiVino' AND sid=3 AND vid=5
\begin_inset Newline newline
\end_inset

con però un ulteriore passo necessario per eliminare dei risultati (poichè
 attraverso l'indice il risultato ha un insieme più grande di tuple, infatti
 non è possibile eliminare attraverso l'indice quelle che hanno sid diverso
 da 3, dunque è necessario in un passo successivo ignorarle).
\end_layout

\begin_layout Standard
In generale un 
\emph on
indice hash
\emph default
 può risolvere una condizione congiuntiva solo se essa contiene 
\emph on
un termine di uguaglianza per ogni attributo chiave dell'indice
\emph default
, mentre un 
\emph on
indice B+tree
\emph default
 puà risolvere una condizione congiuntiva solo se essa contiene 
\emph on
un termine per ogni attributo nel prefisso della chiave dell'indice 
\emph default
ed in uqesto caso non è necessario che il predicato risulti essere d'uguaglianza.
 I termini non risolubili di una condizione sono detti 
\series bold
termini residui
\series default
.
\end_layout

\begin_layout Standard
Se la selezione risulta essere priva di 
\emph on
disgiunzioni
\emph default
 è possibile operare per più vie: si può utilizzare il percorso di accesso
 più efficiente sui predicati risolubili e si valutano a posteriori i predicati
 residui e dunque il costo equivale a 
\begin_inset Formula $Costo=costo\, del\, percorso\, più\, efficiente$
\end_inset

; oppure, se esistono più predicato risolubili, si può pensare di usare
 più indici portando il costo a 
\begin_inset Formula $Costo=somma\, dei\, costi\, degli\, indici+costo\, dati$
\end_inset

 in cui il costo dati equivale a 
\begin_inset Formula $Costo\, dati=\phi(f_{1}\cdot f_{2}\cdot\ldots\cdot f_{Q}\cdot N,\, P)$
\end_inset

 in cui 
\begin_inset Formula $\phi$
\end_inset

 rappresenta la solita stima di Cardennas o Yao di quante pagine bisogna
 accedere per la lettura di un record e in cui il numero di risultati (NR)
 della query è dato da 
\begin_inset Formula $NR=f_{1}\cdot f_{2}\cdot\ldots\cdot f_{Q}\cdot N$
\end_inset

 dove ogni f
\begin_inset Formula $_{i}$
\end_inset

 equivale al fattore di selettività del predicato i-esimo ed N è il numero
 dei record della relazione.
 Si noti che il costo dati diminuisce all'aumentare del numero di indici.
\end_layout

\begin_layout Standard
Vediamo ora cosa succede se la selezione contiene delle 
\emph on
disgiunzioni
\emph default
.
 Se la condizione è una disgiunzione ed esiste anche una sola condizione
 non risolubile con l'indice occorre necessariamente scandire il file.
 Se invece esiste almeno una condizione che è in AND (cioè fa parte di un
 gruppo in cui è presente un AND) risolubile con indice si usa il percorso
 d'accesso più efficiente.
 Infine se tutte le condizioni in OR sono risolubili con indice, si risolvono
 tutte e se ne prende l'unione (eventualmente facendo l'unione delle RID).
\end_layout

\begin_layout Standard
Facciamo ora alcuni esemepi di query di selezione e vediamone le caratteristiche
\end_layout

\begin_layout Paragraph
Esempio 1
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM Recensioni as R
\end_layout

\begin_layout Plain Layout

WHERE R.sid=7
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $N(R)=100K,$
\end_inset

 
\begin_inset Formula $P(R)=\left\lceil \frac{N}{TP}\right\rceil =1K,$
\end_inset

 
\begin_inset Formula $NK(sid)=40K$
\end_inset


\end_layout

\begin_layout Itemize
Fattore di selettività f 
\begin_inset Formula $f=\frac{1}{40k}$
\end_inset


\end_layout

\begin_layout Itemize
Indice su attributo 
\emph on
sid
\emph default
: 
\begin_inset Formula $h=2$
\end_inset

, 
\begin_inset Formula $L=\left\lceil \frac{(40k\cdot2+100k\cdot4)}{4096\cdot0.69}\right\rceil =170$
\end_inset


\end_layout

\begin_layout Itemize
Numero di record nel risultato: 
\begin_inset Formula $\left\lceil \frac{100k}{40k}\right\rceil =3$
\end_inset


\end_layout

\begin_layout Itemize
Costo sequenziale
\begin_inset Formula $=1000$
\end_inset


\end_layout

\begin_layout Itemize
Costo su file ordinato
\begin_inset Formula $=\log_{2}1000=11$
\end_inset


\end_layout

\begin_layout Itemize
Numero di pagine lette del file: 
\begin_inset Formula $\Phi(3,\,1k)=3$
\end_inset


\end_layout

\begin_layout Itemize
Costo con indice B+tree clustere
\begin_inset Formula $=2+1+1$
\end_inset


\end_layout

\begin_layout Itemize
Costo con indice B+tree unclustered
\begin_inset Formula $=2+1+3$
\end_inset


\end_layout

\begin_layout Itemize
Costo con indice hash clustered
\begin_inset Formula $=1+1$
\end_inset


\end_layout

\begin_layout Itemize
Costo con indice hash unclustered
\begin_inset Formula $=1+3$
\end_inset


\end_layout

\begin_layout Paragraph
Esempio 2
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM Recensioni as R
\end_layout

\begin_layout Plain Layout

WHERE R.anno>2000 AND R.rivista="Sapori DiVino"
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $N(R)=100k,$
\end_inset

 
\begin_inset Formula $P(R)=\left\lceil \frac{N}{TP}\right\rceil =1k$
\end_inset

, 
\begin_inset Formula $N(S)=40k$
\end_inset


\end_layout

\begin_layout Itemize
Fattore di selettività f: 
\begin_inset Formula $f=\frac{1}{2}\cdot\frac{1}{50}=\frac{1}{100}$
\end_inset


\end_layout

\begin_layout Itemize
Indice su attributo 
\emph on
anno
\emph default
: 
\begin_inset Formula $h=2$
\end_inset

, 
\begin_inset Formula $L=\left\lceil \frac{(20\cdot2+100k\cdot4}{4096\cdot0.69}\right\rceil =142$
\end_inset


\end_layout

\begin_layout Itemize
Indice su attributo 
\emph on
rivista
\emph default
: 
\begin_inset Formula $h=2,$
\end_inset

 
\begin_inset Formula $L=\left\lceil \frac{(1k\cdot22+100k\cdot4}{4096\cdot0.69}\right\rceil =143$
\end_inset


\end_layout

\begin_layout Itemize
Numero di record nel risultato
\begin_inset Formula $=\left\lceil \frac{100k}{100}\right\rceil =1k$
\end_inset


\end_layout

\begin_layout Itemize
Costo sequenziale
\begin_inset Formula $=1000$
\end_inset


\end_layout

\begin_layout Itemize
Costo indice B+tree clustered su anno
\begin_inset Formula $=2+\frac{142}{2}+\frac{1000}{2}=573$
\end_inset


\end_layout

\begin_layout Itemize
Costo indice B+tree unclustered su rivista
\begin_inset Formula $=2+\frac{142}{50}+\Phi(2k,\,1k)=870$
\end_inset


\end_layout

\begin_layout Itemize
Costo indice B+tree clustered su rivista
\begin_inset Formula $=2+\frac{142}{50}+\frac{1000}{50}=25$
\end_inset


\end_layout

\begin_layout Itemize
Costo indice B+tree unclustered su anno
\begin_inset Formula $=2+\frac{142}{2}+\Phi(50k,\,1k)=1073$
\end_inset


\end_layout

\begin_layout Itemize
Costo indice B+tree clustered su (anno,rivista)
\begin_inset Formula $=2+\frac{143}{2}+\frac{1000}{100}=84$
\end_inset


\end_layout

\begin_layout Itemize
Costo indice B+tree clustere su (rivista,anno)
\begin_inset Formula $=2+\frac{143}{50}+\frac{1000}{100}=15$
\end_inset


\end_layout

\begin_layout Subsection
Proiezione
\end_layout

\end_body
\end_document
