#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part
Top-K Queries
\end_layout

\begin_layout Standard
L'obiettivo delle 
\emph on
Top-K Queries
\emph default
 è di trovare, da un insieme di risultati potenzialmente molto grande, solo
 le 
\emph on
k 
\emph default
(con 
\begin_inset Formula $k\geq1$
\end_inset

) migliori risposte.
 Per migliori risposte si può intendere più importanti, interessanti, rilevanti,
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 Il bisogno di avere query di questo tipo nasce dalla varietà dei moderni
 scenari come gli e-commerce, Database scientifici, ricerche web, sistemi
 multimediali, etc
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 La definizione di 
\emph on
top-k query
\emph default
 richiede un sistema capace di 
\begin_inset Quotes eld
\end_inset

classificare
\begin_inset Quotes erd
\end_inset

 gli oggetti (il primo dei migliori risultati, il secondo, il terzo, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

).
 Per 
\begin_inset Quotes eld
\end_inset

classificare
\begin_inset Quotes erd
\end_inset

 si intendere l'ordinamento degli oggetti del database basato sulla loro
 
\begin_inset Quotes eld
\end_inset

rilevanza
\begin_inset Quotes erd
\end_inset

 per la query.
\end_layout

\begin_layout Standard
Facciamo un esempio: si voglia prenotare un volo su un sito di una compagnia
 aerea, indicando da dove si vuole partire e dove si vuole arrivare, dando
 anche le date di partenza e di ritorno.
 Il sistema potrebbe non trovare alcun risultato con i valori immessi, ma
 attraverso le top-k queries potrebbe consigliare all'utente le migliori
 alternative disponibili, come ad esempio con un giorno di andata o ritorno
 differente, o un aereoporto di partenza diverso.
\end_layout

\begin_layout Standard
Un primo approccio ingenuo per la costruzione di top-k queries potrebbe
 essere il seguente: assumiamo che data una 
\emph on
query q
\emph default
 esista una 
\emph on
funzione di successo 
\emph default
(o di 
\emph on
scoring
\emph default
) 
\emph on
S
\emph default
 che assegna ad ogni tupla t un punteggio numerico in accordo a come le
 tuple sono classificate e successivamente ne fa ordinamento secondo S.
 Ad esempio se abbiamo la seguente relazione (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:primoesempiorelazione"

\end_inset

) possiamo immaginare la seguente funzione di succeso 
\begin_inset Formula $S(t)=t.Points+t.Rebounds$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:primoesempiorelazione"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename primoesempiorelazione.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'algoritmo 
\emph on
naive 
\emph default
ha dunque questa struttura:
\end_layout

\begin_layout Itemize

\series bold
Input:
\series default
 una query q, un set di record R
\end_layout

\begin_layout Itemize

\series bold
Output
\series default
: le 
\emph on
k
\emph default
 tuple con punteggio più alto rispetto alla funzione di successo S
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

begin.
\end_layout

\begin_layout Plain Layout

	for each t in R
\end_layout

\begin_layout Plain Layout

		compute S(t);
\end_layout

\begin_layout Plain Layout

	sort tuples on their scores;
\end_layout

\begin_layout Plain Layout

	return the first k highest-scored tuples;
\end_layout

\begin_layout Plain Layout

end.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Riuscire a computare la 
\emph on
top-k query
\emph default
 utilizzando l'algoritmo appena descritto risulta essere molto costosa per
 database di grandi dimensioni, poichè richiede di ordinare un grand numero
 di informazioni.
 Il problema risulta essere anche peggiore se l'input consiste in attributi
 appartenenti a più di una relazione: si veda l'esempio in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:primoesempiorelazione01"

\end_inset

) per maggiore chiarezza, in cui la funzione di successo S è rimasta invariata
 
\begin_inset Formula $S(t)=t.Points+t.Rebounds$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:primoesempiorelazione01"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename primoesempiorelazione01.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il problema si aggrava poichè ora dobbiamo anche effettuare il join fra
 tutte le tuple, il che richiede un ulteriore operazione di un certo costo.
 Si noti che nell'esempio precedente il join è 1:1, ma in generale può essere
 M:N (in cui cioè ogni tupla può fare il join con un numero arbitrario di
 tuple).
\end_layout

\begin_layout Section
Top-k Query in SQL
\end_layout

\begin_layout Standard
Esprimere una 
\emph on
top-k query 
\emph default
in SQL richiede la capacità di 
\series bold
ordinare
\series default
 le tuple in base al loro punteggio e 
\series bold
limitare
\series default
 la cardinalità dell'output alle sole k tuple.
 
\end_layout

\begin_layout Standard
Consideriamo ora un primo caso di query scritta con lo schema seguente,
 il quale utilizza lo 
\emph on
standard SQL
\emph default
 in cui è presente solo la possibilità di ordinamento (non è consentito
 limitare il risultato)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT  <some attributes>
\end_layout

\begin_layout Plain Layout

FROM	R
\end_layout

\begin_layout Plain Layout

WHERE   <Boolean conditions>
\end_layout

\begin_layout Plain Layout

ORDER BY S(...) [DESC]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
e facciamo dunque due esempi.
\end_layout

\begin_layout Standard

\series bold
Esempio A
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT  *
\end_layout

\begin_layout Plain Layout

FROM    UsedCarsTable
\end_layout

\begin_layout Plain Layout

WHERE   Vehicle='Audi/A4' AND Price <= 21000
\end_layout

\begin_layout Plain Layout

ORDER BY 0.8*Price + 0.2*Mileage
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Esempio B
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT  *
\end_layout

\begin_layout Plain Layout

FROM    UsedCarsTable
\end_layout

\begin_layout Plain Layout

WHERE   Vehicle='Audi/A4'
\end_layout

\begin_layout Plain Layout

ORDER BY 0.8*Price + 0.2*Mileage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I valori 0.8 e 0.2 presenti nell'ORDER BY, anche chiamati 
\emph on
pesi
\emph default
, sono un modo per normalizzare le nostre preferenze su Prezzo e Chilometraggio.
 La query A potrà perdere alcune risposte che potrebbero risultare rilevanti,
 e si parla in questo caso di 
\emph on
near-miss
\emph default
, come ad esempio una macchina con un prezzo di 21.500$ ma con basso chilometragg
io.
 La query B invece ritorna tutte le Audi/A4 presenti nel database, e in
 questo caso si parla di 
\emph on
information overload
\emph default
, e la situazione risulta anche peggiore se non specifichiamo alcun tipo
 di veicolo (quindi eliminando la clausola WHERE il quale restituirà tutte
 le tuple della relazione).
\end_layout

\begin_layout Standard
Prima di considerare altre soluzioni, diamo un occhiata più da vicino a
 come il 
\emph on
server dbms
\emph default
 manda i risultati di una query ad un'applicazione client.
 Da lato client si lavora 
\begin_inset Quotes eld
\end_inset

una tupla per volta
\begin_inset Quotes erd
\end_inset

 usando, ad esempio, un metodo specifico come 
\series bold
rs.next()
\series default
.
 Anche se potrebbe sembrare, questo non vuol dire che il risultato totale
 viene trasmesso una tupla per volta dal server al client.
 La maggior parte dei 
\emph on
dbms
\emph default
 implementa una caratteristica chiamata 
\emph on
row blocking
\emph default
 che ha lo scopo di ridurre l'
\emph on
overhead
\emph default
 di trasmissione.
\end_layout

\begin_layout Standard
Il 
\emph on
row blocking
\emph default
 funziona come descritto di seguito (si controlli la figura per una maggiore
 chiarezza):
\end_layout

\begin_layout Enumerate
Il 
\emph on
dbms
\emph default
 alloca alcuni buffer (un 
\begin_inset Quotes eld
\end_inset

blocco
\begin_inset Quotes erd
\end_inset

) da lato server
\end_layout

\begin_layout Enumerate
Riempe i buffer con le tuple risultanti dalla query
\end_layout

\begin_layout Enumerate
Invia l'intero 
\begin_inset Quotes eld
\end_inset

blocco
\begin_inset Quotes erd
\end_inset

 di tuple al client
\end_layout

\begin_layout Enumerate
Il client consuma (legge) le tuple nel blocco
\end_layout

\begin_layout Enumerate
Si ripete il passo 2 fino a che non vi sono più tuple (righe) disponibili
 nel risultato.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rowblockingesempio"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename rowblockingesempio.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Perchè il solo 
\emph on
row blocking 
\emph default
non è sufficiente? Cioè, perchè abbiamo bisogno del 
\begin_inset Quotes eld
\end_inset

k
\begin_inset Quotes erd
\end_inset

? Razionalmente si potrebbe pensare al 
\emph on
fetch 
\emph default
delle sole tuple di cui si ha bisogno.
 Vediamo un esempio in DB2.
 La grandezza del 
\begin_inset Quotes eld
\end_inset

blocco
\begin_inset Quotes erd
\end_inset

 è stabilita quando l'applicazione si connette al database (grandezza di
 default: 32Kb).
 Se il buffer può mantenere, diciamo, 1000 tuple ma l'applicazione controlla
 solo, diciamo, le prime dieci abbiamo uno spreco di risorse: infatti effettuiam
o il 
\emph on
fetch
\emph default
 da disco e processiamo troppe (1000) tuple, successivamente trasmettiamo
 troppi dati (sempre le 1000 tuple) sulla rete.
 Se riducessimo la grandezza del blocco, potremmo incorrere in un 
\emph on
overhead
\emph default
 in trasmissione per le query che hanno risultati con un set elevato.
 Si potrebbe pensare anche di connettersi più volte al database per modificare
 ad ogni connessione la grandezza del blocco di trasmissione a seconda se
 voglia processare top-k query o meno: purtroppo anche questo approccio
 non è scalabile, poichè la richiesta di connessione risulta essere più
 pesante che il calcolo stesso.
 Dobbiamo sempre ricordarci che non abbiamo solo una query, la nostra applicazio
ne potrebbe consistere in un insieme di query ognuna delle quali con delle
 specifiche differenti.
 Dobbiamo inoltre osservere che il 
\emph on
dbms
\emph default
 non sa nulla sulle intenzioni del client, cioè 
\emph on
ottimizza 
\emph default
e 
\emph on
calcola
\emph default
 la query come se dovesse trasmettere l'intero set del risultato.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Abbiamo visto finora le top-k query applicate a SQL standard.
 Ora le vedremo applicate a SQL extended, il quale permette di aggiungere
 predicati utili per la risoluzione delle query.
\end_layout

\begin_layout Standard
Il primo passo di sopporto alle 
\emph on
top-k
\emph default
 query è semplice: estendere SQL con una nuova clausola che esplicita la
 cardinalità limite del risultato.
 La sintassi proposta è la seguente
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT <some attributes>
\end_layout

\begin_layout Plain Layout

FROM <some relation(s)>
\end_layout

\begin_layout Plain Layout

WHERE <boolean conditions>
\end_layout

\begin_layout Plain Layout

[GROUP BY <some grouping attributes>]
\end_layout

\begin_layout Plain Layout

ORDER BY S(...) [DESC]
\end_layout

\begin_layout Plain Layout

STOP AFTER k
\end_layout

\end_inset


\end_layout

\begin_layout Standard
dove 
\emph on
k 
\emph default
è un intero positivo.
 Questa è la sintassi proposta in [CK97], ma la maggior parte dei 
\emph on
dbms
\emph default
 hanno estensioni equivalenti proprietarie, ad esempio 
\series bold
FETCH FIRST k ROWS ONLY 
\series default
in DB2, oppure 
\series bold
LIMT TO k ROWS
\series default
 in ORACLE, o ancora 
\series bold
LIMIT k
\series default
 in Postgres, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 [CK97] permette anche espressione numeriche, scorrelate con il resto della
 query, al posto del valore k.
\end_layout

\begin_layout Standard
Consideriamo una 
\emph on
top-k
\emph default
 query con la clausola 
\series bold
STOP AFTER k
\series default
.
 Concettualmente il resto della query è calcolata come al solito in accordo
 a una relazione T, successivamente 
\emph on
solo le prime k tuple di T 
\emph default
diventano parte del risultato.
 Se T contiene 
\emph on
k
\emph default
 o meno tuple, allora la clausola STOP AFTER k non ha alcun effetto; se
 invece contiene più di un set di tuple che soddisfano la clausola ORDER
 BY, allora ognuno di questo set risulta essere una risposta valida (e si
 parla di 
\bar under
semantica non-deterministica
\bar default
).
 Si veda la seguente figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:semanticanondeterministica"

\end_inset

) per una maggiore comprensione.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:semanticanondeterministica"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename semanticanondeterministica.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se infine non è presente la clausola ORDER BY, allora qualsiasi set di 
\emph on
k
\emph default
 tuple della tabella T è una soluzione valilda e corretta.
\end_layout

\begin_layout Standard
Mostriamo di seguito alcuni esempi di 
\emph on
top-k query
\emph default
.
\end_layout

\begin_layout Paragraph
Esempio 1
\end_layout

\begin_layout Standard
Il miglior giocatore di NBA (considerando canestri e rimbalzi)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM NBA
\end_layout

\begin_layout Plain Layout

ORDER BY Points + Rebounds DESC
\end_layout

\begin_layout Plain Layout

STOP AFTER 1
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Esempio 2
\end_layout

\begin_layout Standard
I due ristoranti cinesi più economici
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM RESTAURANTS
\end_layout

\begin_layout Plain Layout

WHERE Cuisine='chinese'
\end_layout

\begin_layout Plain Layout

ORDER BY Price
\end_layout

\begin_layout Plain Layout

STOP AFTER 2
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Esempio 3
\end_layout

\begin_layout Standard
Il 5% di impiegati più pagati (si vede in questo caso una top-k query con
 un'espressione numerica invece che un valore numerico di k)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT E.*
\end_layout

\begin_layout Plain Layout

FROM EMP AS E
\end_layout

\begin_layout Plain Layout

ORDER BY E.Salary DESC
\end_layout

\begin_layout Plain Layout

STOP AFTER (SELECT COUNT(*)/20 FROM EMP)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Esempio 4
\end_layout

\begin_layout Standard
Le 5 migliori Audi-A4 basate su prezzo e chilometraggio
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM USEDCARS
\end_layout

\begin_layout Plain Layout

WHERE Vehicles='Audi/A4'
\end_layout

\begin_layout Plain Layout

ORDER BY 0.8*Price + 0.2*Mileage
\end_layout

\begin_layout Plain Layout

STOP AFTER 5
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Esempio 5
\end_layout

\begin_layout Standard
I due hotel più vicini all'aeroporto di Bologna (si utilizza una 
\emph on
top-k
\emph default
 query con 
\emph on
distance
\emph default
 join in cui 
\emph on
Location
\emph default
 è un 
\begin_inset Quotes eld
\end_inset

punto
\begin_inset Quotes erd
\end_inset

 UDT, User-defined Data Type, e 
\emph on
distance
\emph default
 è un UDF, User-Defined Function)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT H.*
\end_layout

\begin_layout Plain Layout

FROM HOTELS AS H, AIRPORTS AS A
\end_layout

\begin_layout Plain Layout

WHERE A.Code = 'BLQ'
\end_layout

\begin_layout Plain Layout

ORDER BY distance(H.Location,A.Location)
\end_layout

\begin_layout Plain Layout

STOP AFTER 2
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operatore Top
\end_layout

\begin_layout Standard
Per ciò che riguarda il calcolo, ci sono due aspetti base da considerare:
\end_layout

\begin_layout Itemize
Il 
\series bold
tipo
\series default
 di query: a 1 relazione, su più relazioni, su risultati aggregati, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Il 
\series bold
metodo
\series default
 di accesso: senza indice, con indici su alcuni attributi di ranking, con
 indici su tutti gli attributi di ranking.
\end_layout

\begin_layout Standard
Il caso più semplice da analizzare è la 
\emph on
top-k selection query
\emph default
, dove è coinvolta una sola relazione, la quale possiede la seguente semantica
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT <some attributes>
\end_layout

\begin_layout Plain Layout

FROM R
\end_layout

\begin_layout Plain Layout

WHERE <Boolean conditions>
\end_layout

\begin_layout Plain Layout

ORDER BY S(...) [DESC]
\end_layout

\begin_layout Plain Layout

STOP AFTER k
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per ragionare in maniera concisa sulle strategie di valutazione alternative,
 dobbiamo per prima cosa estendere l'algebra relazionale.
 A tal fine introduciamo l'
\emph on
operatore logico TOP
\emph default
, denotato con 
\begin_inset Formula $\tau_{k,S}$
\end_inset

, che ritorna le 
\emph on
k
\emph default
 tuple con miglior risultato in accordo alla funzione di successo S.
 Se non diversamente specificato, assumiamo S come funzione massimizzatrice.
 Si veda l'esempio in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:topoperatore"

\end_inset

) in cui nel metodo di accesso viene utilizzato anche l'operatore logico
 
\emph on
top
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:topoperatore"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename topoperatore.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Più avanti introdurremo una rappresentazione più potente in cui il 
\emph on
ranking
\emph default
 non è un semplice 
\begin_inset Quotes eld
\end_inset

limiting
\begin_inset Quotes erd
\end_inset

 (cioè un limite alla cardinalità del risultato), ma un 
\begin_inset Quotes eld
\end_inset

cittadino di prima-classe
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Come possiamo implementare l'operatore logico top
\emph on
? 
\emph default
Come può essere calcolato? Ricordiamo che abbiamo bisogno di operatori fisici
 che implementino operatori logici.
 Esistono 2 casi rilevanti:
\end_layout

\begin_layout Enumerate

\series bold
Top-Scan: 
\series default
il flusso di tuple in input all'operatore Top è già ordinato secondo la
 funzione di successo S, in questo caso è sufficiente leggere (consumare)
 solo le prime k tuple dall'input.
 Il 
\emph on
Top-scan
\emph default
 può lavorare in 
\emph on
pipeline
\emph default
: può restituire una tupla appena la legge.
\end_layout

\begin_layout Enumerate

\series bold
Top-Sort:
\series default
 il flusso di tuple in input non è ordinato secondo la funzione di successo
 S.
 Risulta essere il caso tipico: piuttosto che ordinare l'intero input possiamo
 effettuare un 
\emph on
in-memory sort
\emph default
.
 Il 
\emph on
Top-Sort
\emph default
 non può lavorare in 
\emph on
pipeline
\emph default
: ha infatti bisogno di leggere l'intero input prima di poter restituire
 la prima tupla.
\end_layout

\begin_layout Subsubsection
Top-Sort
\end_layout

\begin_layout Standard
L'idea dietro il metodo 
\emph on
Top-Sort 
\emph default
è di mantenere in un buffer B della memoria principale solo le miglior k
 tuple viste fino a quel punto.
 La 
\emph on
ratio
\emph default
 dietro questo procedimento è che se una tupla t non si trova nelle top-k
 tuple viste finora, allora t non può far parte del risultato.
\end_layout

\begin_layout Standard
Il problema cruciale è come organizzare B in modo tale che le operazioni
 di ricerca, inserzione e rimozione possano essere effettuate efficientemente.
 Siccome il buffer B dovrebbe comportarsi come una 
\emph on
coda prioritaria
\emph default
 (in cui la priorità è data dal punteggio ottenuto dalla tupla), può essere
 implementata usando un 
\emph on
heap
\emph default
.
 
\end_layout

\begin_layout Standard
Per la realizzazione e la standardizzazione degli operatori fisici bisogna
 implementare i due metodi 
\emph on
open 
\emph default
e 
\emph on
next
\emph default
.
\end_layout

\begin_layout Paragraph
OPEN
\end_layout

\begin_layout Standard

\emph on
open
\end_layout

\begin_layout Itemize

\series bold
input: 
\series default
k valore intero, S funzione di successo
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1.
 create a priority queue B of size k; 
\end_layout

\begin_layout Plain Layout

	//B can hold at most k tuples
\end_layout

\begin_layout Plain Layout

	//B[i] is the current i-th best tuple,
\end_layout

\begin_layout Plain Layout

	and B[i].score is its score
\end_layout

\begin_layout Plain Layout

2.
 invoke open on the child node;
\end_layout

\begin_layout Plain Layout

3.
 return;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\emph on
open
\emph default
 crea un buffer B di grandezza 
\emph on
k
\emph default
 che potrà contenere le nostre k-tuple, si indica con 
\emph on
B[i]
\emph default
 la 
\emph on
i-
\emph default
esima miglior tupla e con B[i].score il suo punteggio.
\end_layout

\begin_layout Paragraph
NEXT
\end_layout

\begin_layout Standard

\emph on
next
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1.
 for i=1 to k	//fills B with first k tuples
\end_layout

\begin_layout Plain Layout

2.
   t:=input_node.get_next();
\end_layout

\begin_layout Plain Layout

     ENQUEUE(B,t) //insert t in B
\end_layout

\begin_layout Plain Layout

3.
 while(input_node.has_next()) do
\end_layout

\begin_layout Plain Layout

4.
   t:=input_node.next();
\end_layout

\begin_layout Plain Layout

     if S(t)>B[k].score then 
\end_layout

\begin_layout Plain Layout

	    DELETE(B,B[k]);
\end_layout

\begin_layout Plain Layout

        ENQUEUE(B,t);
\end_layout

\begin_layout Plain Layout

5.
 return DEQUEUE(B) //returns the best tuple in B
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\emph on
next
\emph default
 inizialmente riempe B con le prime k tuple (per semplicità il pseudocodice
 non considera il caso di input con meno di 
\emph on
k 
\emph default
tuple).
 Successivamente, per ogni nuova tupla letta t, la confronta con B[k], cioè
 la peggior tupla presente al momento in B.
\end_layout

\begin_layout Itemize
Se S(t)>B[k].score allora B[k] viene cancellata da B e viene inserita t
\end_layout

\begin_layout Itemize
Se S(t)<B[k].score allora t non può essere una delle 
\emph on
top-k
\emph default
 tuple e di conseguenza viene scartata
\end_layout

\begin_layout Itemize
Se S(t)=B[k].score allora è sicuro (
\begin_inset Quotes eld
\end_inset

safe
\begin_inset Quotes erd
\end_inset

) scartare la tupla t poichè Top ha una semantica non deterministica.
\end_layout

\begin_layout Standard
Un semplice esempio viene mostrato in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempioktopquery"

\end_inset

), in cui si ha k=2.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempioktopquery"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempioktopquery.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Top-K Query Multidimensionali
\end_layout

\begin_layout Standard
Nel caso generale, la funzione di successo S coinvolge più di un attributo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT * 
\end_layout

\begin_layout Plain Layout

FROM USEDCARS 
\end_layout

\begin_layout Plain Layout

WHERE Vehicle = ‘Audi/A4’ 
\end_layout

\begin_layout Plain Layout

ORDER BY 0.8*Price + 0.2*Mileage 
\end_layout

\begin_layout Plain Layout

STOP AFTER 5;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se nessun indice è disponibile non possiamo che applicare un operatore di
 
\emph on
Top-Sort
\emph default
 leggendo sequenzialmente tutte le tuple.
 Se invece è disponibile un indice sull'attributo Vehicle allora la situazione
 migliora, però ancora si ha dipendenza da quante Audi/A4 siano presenti
 nel Database (dipende dalla selettività della clausole), e sinfine se se
 non è presente alcuna clausola di WHERE (è come se non ci fosse l'indice)
 si torna al caso precedente di 
\emph on
Top-Sort
\emph default
.
\end_layout

\begin_layout Standard
Assumendo di avere l'
\emph on
indice
\emph default
 sugli attributi di 
\emph on
ranking
\emph default
 (ad esempio su 
\emph on
Price 
\emph default
e 
\emph on
Milage
\emph default
) come possiamo usarlo perr risolvere una 
\emph on
top-k query
\emph default
? Che tipo di indice dovremmo utilizzare? Per prima cosa dobbiamo capire
 meglio la 
\emph on
geometria
\emph default
 alla base del problema.
\end_layout

\begin_layout Standard
Consideriamo lo spazio degli attributi sotto una visione geometrica considerando
 uno spazio bi-dimensionale (2-dim) sugli attributi (Price, Milage).
 Uno spazio siffatto è rappresentato dalla seguente figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempiospazioattributi"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempiospazioattributi"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempiospazioattributi.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ogni tupla è rappresentata da un punto sulle due coordinate (p,m) in cui
 p è il valore di 
\emph on
price
\emph default
 e m il valore di 
\emph on
mileage.
 
\emph default
Intuitivamente cercare di minimizzare la funzione 
\begin_inset Formula $0.8*Price+0.2*Mileage$
\end_inset

 equivale a cercare un punto vicino 
\begin_inset Formula $(0,0)$
\end_inset

: idealmente l'origine è il nostro 
\begin_inset Quotes eld
\end_inset

valore obiettivo
\begin_inset Quotes erd
\end_inset

 (una macchina gratuita con 0km).
\end_layout

\begin_layout Standard
Che ruolo hanno i 
\begin_inset Quotes eld
\end_inset

pesi
\begin_inset Quotes erd
\end_inset

 (ovvero i parametri) che attribuiamo nella funzione di successo S? I nostri
 parametri (ad esempio 0.8 e 0.2) sono essenziali per determinare il risultato.
 Utilizzando la figura seguente (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:preferencesweights"

\end_inset

) facciamo alcune osservazioni.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:preferencesweights"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename preferencesweight.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consideriamo le varie rette 
\emph on
l 
\emph default
al variare del valore 
\emph on
v, 
\emph default
ovvero 
\emph on
l(v)
\emph default
: essa è rappresentata dall'equazione 
\begin_inset Formula $0.8\cdot Price+0.2\cdot Mileage=v$
\end_inset

 dove 
\emph on
v 
\emph default
risulta essere una costante.
 L'equazione può essere riscritta come 
\begin_inset Formula $Mileage=-4\cdot Price+5\cdot v$
\end_inset

 tramite il quale è possibile vedere la pendenza di ogni retta (
\begin_inset Formula $pendenza=-4$
\end_inset

).
 Per definizione tutti i punti che giaciono su una stessa retta 
\emph on
l(v) 
\emph default
sono egualmente 
\begin_inset Quotes eld
\end_inset

buoni
\begin_inset Quotes erd
\end_inset

.
 Con i nostri parametri (0.8,0.2) la miglior macchina è C6, la seconda miglior
 macchina è C5, etc
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Dati i punti 
\begin_inset Formula $(p_{1},m_{1})$
\end_inset

 e 
\begin_inset Formula $(p_{2},m_{2})$
\end_inset

, i parametri sono un buon modo per determinare quale fra i due si avvicina
 di più al punto obiettivo (0,0).
\end_layout

\begin_layout Standard
Chiaramente, cambiando i valori dei pesi si potrà avere un cambiamento del
 risultato.
 Se sostituiamo i pesi 
\begin_inset Formula $0.8\cdot Price+0.2\cdot Mileage$
\end_inset

 con 
\begin_inset Formula $0.5\cdot Price+0.5\cdot Mileage$
\end_inset

 le migliori macchine risulteranno C5 e C11: si veda la figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:preferenceweights01"

\end_inset

) per una maggiore comprensione.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:preferenceweights01"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename preferencesweight01.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
D'altra parte, se i pesi non cambiano di molto, i risultati delle due 
\emph on
top-k query
\emph default
 avranno probabilmente un alto grado di sovrapposizione.
\end_layout

\begin_layout Standard
L'
\emph on
obiettivo
\emph default
 di una query non è necessariamente il punto (0,0), può essere infatti un
 qualsiasi punto 
\begin_inset Formula $q=(q_{1},q_{2})$
\end_inset

 in cui 
\begin_inset Formula $q_{i}$
\end_inset

 è il valore della query per l'
\emph on
i
\emph default
-esimo attributo.
 Per esempio: supponendo di voler cercare una casa con un giardino di 1000m
\begin_inset Formula $^{2}$
\end_inset

 e 3 camere da letto, allora il punto obiettivo della query sarà (1000,3),
 in cui, come mostrato in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:preferencetarget"

\end_inset

) vengono rappresentati su un'asse i m
\begin_inset Formula $^{2}$
\end_inset

 del giardino e sull'altra il numero di camere da letto.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:preferencetarget"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename preferencetarget.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In generale, per determinare la migliore tupla 
\emph on
t
\emph default
 fra un'insieme di tuple, calcoliamo la sua distanza dal punto obiettivo
 
\emph on
q
\emph default
: minore è la distanza da q migliore sarà t.
 Bisogna notare che la distanza dei valori può essere sempre convertita
 in 
\emph on
bontà del punteggio
\emph default
, in modo che il punteggio maggiore significhi il miglior 
\emph on
match 
\emph default
(basta cambiare di segno e possibilmente aggiungere una costante), ovvero
 è sempre possibile passare dal calcolare il 
\begin_inset Quotes eld
\end_inset

punteggio
\begin_inset Quotes erd
\end_inset

 di una tupla, in cui punteggio maggiore implica tupla migliore, al calcolo
 della 
\begin_inset Quotes eld
\end_inset

distanza
\begin_inset Quotes erd
\end_inset

 della tupla rispetto all'obiettivo q, in cui distanza minore implica tupla
 migliore.
\end_layout

\begin_layout Subsubsection
K-Nearest Neighbors (k-NN)
\end_layout

\begin_layout Standard
Puntando ad avere una gestione omogenea del problema quando usiamo un indice,
 è utile considerare le 
\emph on
distanze
\emph default
 invece che i punteggi.
\end_layout

\begin_layout Standard
Il modello che ne possiamo derivare è il seguente:
\end_layout

\begin_layout Enumerate
Uno spazio di attributi 
\emph on
D
\emph default
-dimensionale (con 
\begin_inset Formula $D\geq1$
\end_inset

) 
\begin_inset Formula $A=(A_{1},A_{2},\ldots,A_{D})$
\end_inset

 fatto da 
\emph on
attributi di ranking
\end_layout

\begin_layout Enumerate
Una relazione 
\begin_inset Formula $R(A_{1},A_{2},\ldots,A_{D},B_{1},B_{2},\ldots)$
\end_inset

 dove 
\begin_inset Formula $B_{1},B_{2},\ldots$
\end_inset

 sono attributi 'superflui' della relazione
\end_layout

\begin_layout Enumerate
Un punto obiettivo della query 
\begin_inset Formula $q=(q_{1},q_{2},\ldots,q_{D})$
\end_inset

 con ovviamente 
\begin_inset Formula $q\epsilon A$
\end_inset

.
\end_layout

\begin_layout Enumerate
Una fuzione 
\begin_inset Formula $d:A\times A\rightarrow\mathbb{R}$
\end_inset

 che misura la distanza tra punti di A: ad esempio 
\begin_inset Formula $d(t,q)$
\end_inset

 è la distanza tra il punto t e il punto q.
\end_layout

\begin_layout Standard
Sotto questo modello, una 
\emph on
top-k query
\emph default
 è trasformata in quella che viene chiamata 
\series bold
k-Nearest Neighbors (k-NN)
\series default
: dato un punto 
\emph on
q
\emph default
, una relazione 
\emph on
R
\emph default
, un intero 
\begin_inset Formula $k\geq1$
\end_inset

 e una funzione distanza 
\emph on
d
\emph default
 determinare le 
\emph on
k 
\emph default
tuple in 
\emph on
R
\emph default
 più vicine a 
\emph on
q
\emph default
 secondo 
\emph on
d.
\end_layout

\begin_layout Standard
Le 
\emph on
distanze
\emph default
 più comuni che vengono utilizzate sono le funzioni 
\begin_inset Formula $norme-L_{p}$
\end_inset


\begin_inset Formula 
\[
L_{p}(t,q)=\left(\sum_{i=1}^{D}\left|t_{i}-q_{i}\right|^{p}\right)^{\frac{1}{p}}
\]

\end_inset


\end_layout

\begin_layout Standard
di cui i casi più rilevanti sono
\end_layout

\begin_layout Itemize

\emph on
Distanza Euclidea: 
\begin_inset Formula $L_{2}(t,q)=\sqrt{\sum_{i=1}^{D}\left|t_{i}-q_{i}\right|^{2}}$
\end_inset


\end_layout

\begin_layout Itemize

\emph on
Distanza di Manhattan: 
\begin_inset Formula $L_{1}(t,q)=\sum_{i=1}^{D}\left|t_{i}-q_{i}\right|$
\end_inset


\end_layout

\begin_layout Itemize

\emph on
Distanza di Chebyshev: 
\emph default

\begin_inset Formula $L_{\infty}(t,q)=max_{i}\left\{ \left|t_{i}-q_{i}\right|\right\} $
\end_inset


\end_layout

\begin_layout Standard
e se ne veda la rappresentazione grafica su un piano (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempiodistanze"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempiodistanze"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempiodistanze.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cambiare la funzione di distanza utilizzata conduce a un differente 'modello'
 degli spazi di attributi.
 Si vedano gli esempi in figura con funzioni 
\begin_inset Formula $L_{1}$
\end_inset

 e 
\begin_inset Formula $L_{2}$
\end_inset

 (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:shapingattributes"

\end_inset

) in cui ogni 
\begin_inset Quotes eld
\end_inset

striscia
\begin_inset Quotes erd
\end_inset

 colorata corrisponde al punto con distanza compresa tra 
\emph on
v
\emph default
 e 
\emph on
v+1
\emph default
 con 
\emph on
v 
\emph default
intero.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:shapingattributes"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename shapingattributes.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si noti che per due tuple 
\begin_inset Formula $t_{1}$
\end_inset

 e 
\begin_inset Formula $t_{2}$
\end_inset

 è possibile avere 
\begin_inset Formula $L_{1}(t_{1},q)<L_{1}(t_{2},q)$
\end_inset

 e 
\begin_inset Formula $L_{2}(t_{2},q)<L_{2}(t_{1},q)$
\end_inset

 il che spiega che a seconda della distanza usata potrebbe risultare migliore
 in un caso 
\begin_inset Formula $t_{1}$
\end_inset

 e nell'altro 
\begin_inset Formula $t_{2}$
\end_inset

: di conseguenza la scelta della funzione di distanza influisce sul ranking.
\end_layout

\begin_layout Standard
Non abbiamo però ancora introdotto il 
\begin_inset Quotes eld
\end_inset

peso
\begin_inset Quotes erd
\end_inset

 degli attributi nelle funzioni distanza: infatti il loro uso comporta un
 modello 
\begin_inset Quotes eld
\end_inset

schiacciato
\begin_inset Quotes erd
\end_inset

 su alcune coordinate.
 Si faccia riferimento alle seguenti funzioni distanza con introdotto anche
 il 
\begin_inset Quotes eld
\end_inset

peso
\begin_inset Quotes erd
\end_inset

 
\emph on
w
\begin_inset Formula $_{i}$
\end_inset


\emph default
:
\end_layout

\begin_layout Itemize
\begin_inset Formula $L_{2}(t,q;W)=\sqrt{\sum_{i=1}^{D}w_{i}\cdot\left|t_{i}-q_{i}\right|^{2}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $L_{1}(t,q;W)=\sum_{i=1}^{D}w_{i}\cdot\left|t_{i}-q_{i}\right|$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $L_{\infty}(t,q;W)=max_{i}\left\{ w_{i}\cdot\left|t_{i}-q_{i}\right|\right\} $
\end_inset


\end_layout

\begin_layout Standard
le quali hanno vengono rappresentate attraverso figure 
\begin_inset Quotes eld
\end_inset

schiacciate
\begin_inset Quotes erd
\end_inset

 (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:shapingattributeswithweights"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:shapingattributeswithweights"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename shapingattributeswithweights.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si noti che la nostra funzione 
\begin_inset Formula $0.8\cdot Price+0.2\cdot Mileage$
\end_inset

 è un caso particolare di distanza 
\begin_inset Formula $L_{1}$
\end_inset

 
\begin_inset Quotes eld
\end_inset

pesata
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
È ora possibile modellare lo spazio di attributi con i pesi e la seguetne
 figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:l1conpesi"

\end_inset

) mostra l'effetto di utilizzare la distanza 
\begin_inset Formula $L_{1}$
\end_inset

 pesata.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:l1conpesi"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename l1conpesi.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notiamo che se 
\begin_inset Formula $w_{2}>w_{1}$
\end_inset

 allora gli iper-rombi risultano più allungati lungo A1, cioè a parità di
 una eguale 
\begin_inset Quotes eld
\end_inset

differenza
\begin_inset Quotes erd
\end_inset

, essa inciderà molto di più su A2 che su A1, cioè se dati i punti ad esempio
 (3,0) e (0,5) che supponiamo essere su uno stesso iper-romboide, una differenza
 di 0,1 inciderà molto di più sull'attributo A1 che sull'attributo A2, cioè
 (2.9,0) risulterà essere sicuramente più vicino che (0,4.9).
\end_layout

\begin_layout Subsection
Top-K Query con Indici
\end_layout

\begin_layout Standard
Utilizzare indici per la risolzione di Top-K query è possibile ma con alcuni
 accorgimenti.
 Utilizzare un indice B+tree multi-attributo che organizza le tuple seguendo
 l'ordine lessicografico degli attributi 
\begin_inset Formula $A_{1},A_{2},\ldots,A_{D}$
\end_inset

 (con ad esempio 
\begin_inset Formula $A_{1}=Price$
\end_inset

 e 
\begin_inset Formula $A_{2}=Mileage$
\end_inset

) non risulterà avere una buona performance: infatti risulta avere gli stessi
 problemi visti per la risoluzione di 
\emph on
window query
\emph default
, cioè porta ad un pover clustering spaziale.
 Risulterà però possibile utilizzare D indici B+tree mono-attributo per
 risolvere delle 
\emph on
top-k join queries
\emph default
, metodo che controlleremo più avanti.
 Risulta invece molto più interessante e conveniente utilizzare indici spaziali,
 come ad esempio R-tree.
\end_layout

\begin_layout Standard
Ricordiamo in breve cosa è un R-tree: è un albero 
\emph on
dinamico
\emph default
, 
\emph on
perfettamente bilanciato 
\emph default
e 
\emph on
paginato
\emph default
 in cui ogni foglia contiene entry E nella forma 
\begin_inset Formula $E=(chiave,RID)$
\end_inset

 dove la 
\emph on
chiave
\emph default
 è una 
\begin_inset Quotes eld
\end_inset

chiave spaziale
\begin_inset Quotes erd
\end_inset

 (ovvero la posizione nello spazio) della tupla il cui indirizzo è dato
 da 
\emph on
RID
\emph default
, ed ogni nodo 
\emph on
interno
\emph default
 invece contiene entry E nella forma 
\begin_inset Formula $E=(MBR,PID)$
\end_inset

 dove 
\emph on
MBR
\emph default
 (si veda anche 
\emph on
MBB
\emph default
) è il 
\begin_inset Quotes eld
\end_inset


\emph on
Minimum Bounding Rectangle
\emph default

\begin_inset Quotes erd
\end_inset

 (si parla di rectangle e non di Box poichè stiamo introducendo anche i
 pesi nelle nostre funzioni che portano a 
\begin_inset Quotes eld
\end_inset

schiacciamento
\begin_inset Quotes erd
\end_inset

) di tutti i punti raggiungibili dal nodo il cui indirizzo è PID.
 Possiamo pensare di uniformare le entry usando il formato 
\begin_inset Formula $E=(key,ptr)$
\end_inset

 e diciamo che se N è il nodo puntato da E.ptr allora E.key è la 
\begin_inset Quotes eld
\end_inset

chiave spaziale
\begin_inset Quotes erd
\end_inset

 di N anche chiamata come Regione di N indicata con 
\emph on
Reg(N)
\emph default
.
\end_layout

\begin_layout Standard
Prima di vedere come risolvere una 
\emph on
k-NN query 
\emph default
(che ricordiamo essere equivalente a una top-k query ma con ragionamenti
 applicati ad uno spazio D-dimensionale in cui si vuole minimizzare la distanza
 attraverso un'opportuna funzione), iniziamo a capire come avviene la 
\emph on
ricerca
\emph default
 in una 
\emph on
range query
\emph default
.
\end_layout

\begin_layout Standard
Una 
\emph on
Range Query
\emph default
 è una query in cui: dati un punto 
\emph on
q
\emph default
, una relazione 
\emph on
R
\emph default
, un raggio di ricerca 
\begin_inset Formula $r\geq0$
\end_inset

 e una funzione di distanza 
\emph on
d
\emph default
 si vogliono determinatare tutti gli oggetti 
\emph on
t
\emph default
 della relazione 
\emph on
R
\emph default
 tali per cui 
\begin_inset Formula $d(t,q)\leq r$
\end_inset

.
 La regione dello spazio 
\begin_inset Formula $\mathbb{R^{D}}$
\end_inset

 definita come 
\begin_inset Formula $Reg(q)=\left\{ p\,:\, p\,\epsilon\mathbb{\, R^{D}},\, d(p,q)\leq r\right\} $
\end_inset

 è anche chiamata 
\emph on
regione 
\emph default
della query (
\begin_inset Quotes eld
\end_inset

region query
\begin_inset Quotes erd
\end_inset

), e quindi il risultato è sempre contentuto nella regione della query).
 Esistono diverse varianti alla 
\emph on
range query
\emph default
 come la 
\emph on
point query
\emph default
 che si ottiene per 
\begin_inset Formula $r=0$
\end_inset

 oppure la stessa 
\emph on
window query
\emph default
 che si ottiene utilizzando come funzione di distanza la 
\begin_inset Formula $L_{\infty}$
\end_inset

 
\begin_inset Quotes eld
\end_inset

pesata
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
L'algoritmo per la valutazione di una 
\emph on
range query
\emph default
 è estremamente semplice: 
\end_layout

\begin_layout Enumerate
Si parte dalla radice, per ogni entry E e il corrispondente nodo N, si controlla
 se 
\emph on
Reg(N)
\emph default
 interseca 
\emph on
Reg(q).
 
\end_layout

\begin_layout Enumerate
Se il nodo è una foglia, controlla per ogni entry E tale per cui 
\begin_inset Formula $E.key\,\epsilon\, Reg(q)$
\end_inset

 se 
\begin_inset Formula $d(E.key,q)\leq r$
\end_inset

.
\end_layout

\begin_layout Subsubsection
k-NN Query: Ricerca
\end_layout

\begin_layout Standard
Introduciamo ora il concetto di 
\emph on
distanza minima
\emph default
 che ci permetterà di calcolare la nostra k-NN 
\begin_inset Quotes eld
\end_inset

sbarazzandoci
\begin_inset Quotes erd
\end_inset

 del concetto di raggio di ricerca.
\end_layout

\begin_layout Standard
Dato un punto N sia 
\begin_inset Formula $d_{MIN}(q,Reg(N))=inf_{p}\{d(q,p)\,|\, p\,\epsilon\, Reg(N)\}$
\end_inset

 la più piccola distanza possibile fra il punto 
\emph on
q
\emph default
 e un punto della regione Reg(N).
 Notiamo che la distanza minima 
\begin_inset Formula $d_{MIN}(q,Reg(N))$
\end_inset

 è un 
\emph on
lower bound 
\emph default
sulla distanza tra q e un qualsiasi punto raggiungibile di N: intuitivamente
 la distanza minima di un fra un punto q e una regione N è sicuramente minore
 o uguale alla distanza minima tra il punto q e un qualsiasi punto appartenente
 alla regione stessa.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Esempio distanza minima
\begin_inset CommandInset label
LatexCommand label
name "fig:Esempio-distanza-minima"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename distanzaminima.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Possiamo fare ora la seguente osservazione:
\begin_inset Formula 
\[
Reg(q)\cap Reg(N)\neq\textrm{Ø}\Longleftrightarrow d_{MIN}(q,Reg(N))\leq r
\]

\end_inset


\end_layout

\begin_layout Standard
ovvero che la region query interseca la regione del punto N se e solo se
 la distanza minima fra il punto q e la regione N è minore o uguale al raggio
 di ricerca r.
 Nell'esempio mostrato in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esempio-distanza-minima"

\end_inset

 solo N2 ha intersezione non vuota con la region query.
\end_layout

\begin_layout Standard
Il calcolo della distanza minima fra il punto q di cordinate 
\begin_inset Formula $(q_{1},q_{2},\ldots,q_{D})$
\end_inset

 e la regione N in 
\begin_inset Formula $L_{p}$
\end_inset

 è molto semplice.
 Indichiamo con 
\begin_inset Formula 
\[
\triangle_{i}=\begin{cases}
l_{i}-q_{i} & if\, l_{i}<q_{i}\\
q_{i}-h_{i} & if\, q_{i}>h_{i}\\
0 & otherwise
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
in cui 
\emph on
l
\begin_inset Formula $_{i}$
\end_inset

 
\emph default
e 
\emph on
h
\begin_inset Formula $_{i}$
\end_inset

 
\emph default
indicano il valore minore e il valore maggiore della regione N nella 
\emph on
i-
\emph default
esima coordinata.
 Allora la distanza minima tra q e la Reg(N) è data da
\begin_inset Formula 
\[
d_{MIN}(q,Reg(N))=\sqrt[p]{\left(\sum_{i=1}^{D}\left(\triangle_{i}\right)^{p}\right)^{\frac{1}{p}}}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Algoritmo k-NNOptimal
\end_layout

\begin_layout Standard
Presentiamo ora un algoritmo chiamato 
\emph on
k-NNOptimal 
\emph default
[BBK+97] per la risoluzione di 
\emph on
k-NN
\emph default
 
\emph on
queries
\emph default
 che utilizzi un indice R-tree che risulta essere 
\emph on
ottimo
\emph default
 dal punto di vista di operazioni I/O: ovvero si legge il minor numero possibile
 di nodi dell'albero per la risoluzione della query.
 L'algoritmo può essere utilizzato anche per altre strutture indice come
 ad esempio l'M-tree.
\end_layout

\begin_layout Standard
Iniziamo con il caso base in cui 
\begin_inset Formula $k=1$
\end_inset

 per poi, più avanti estendere l'algoritmo.
\end_layout

\begin_layout Standard
Dato il punto 
\emph on
q
\emph default
 target della nostra query, indichiamo con 
\begin_inset Formula $t_{NN}(q)$
\end_inset

 il punto più vicino a 
\emph on
q
\emph default
 (ovvero il 
\begin_inset Formula $1-NN$
\end_inset

) in R, e indichiamo con 
\begin_inset Formula $r_{NN}=d(q,t_{NN}(q))$
\end_inset

 la sua distanza da 
\emph on
q
\emph default
 che risulterà dunque essere la distanza minima tra tutti i punti del dominio.
 Chiaramente 
\begin_inset Formula $r_{NN}$
\end_inset

 si conoscerà solo al termine dell'algoritmo (è ciò che stiamo cercando,
 insieme a 
\begin_inset Formula $t_{NN}$
\end_inset

).
\end_layout

\begin_layout Standard
Esiste il seguente 
\emph on
teorema
\emph default
: ogni algoritmo 
\emph on
corretto 
\emph default
per le 
\begin_inset Formula $1-NN$
\end_inset

 
\emph on
queries
\emph default
 deve visitare almeno tutti i nodi N la cui distanza minima è strettamente
 minore di 
\begin_inset Formula $r_{NN}$
\end_inset

 ovvero tutti i nodi N per cui 
\begin_inset Formula $d_{MIN}(q,Reg(N))<r_{NN}$
\end_inset

.
 La dimostrazione intuitiva è la seguente: supponiamo di avere un algoritmo
 che trovi 
\begin_inset Formula $t_{NN}$
\end_inset

 non considerando tutti i nodi N per cui la distanza rispetto a 
\emph on
q
\emph default
 risulti strettamente minore di 
\begin_inset Formula $r_{NN}$
\end_inset

, allora l'algoritmo non può essere corretto, perchè non visitando tutti
 i nodi non può certificare che dentro ad uno di questi nodi non esista
 la vera 
\begin_inset Formula $t_{NN}$
\end_inset

.
 Si veda la figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:knnrnntnn"

\end_inset

) per una maggiore comprensione.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:knnrnntnn"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename knnrnntnn.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'algoritmo 
\emph on
k-NNOptimal
\emph default
 usa una 
\emph on
coda prioritaria PQ
\emph default
 i cui elementi sono coppie del tipo 
\begin_inset Formula $[ptr(N),\, d_{MIN}(q,Reg(N))]$
\end_inset

.
 La coda PQ è ordinata secondo valori 
\emph on
crescenti 
\emph default
di 
\begin_inset Formula $d_{MIN}(q,Reg(N))$
\end_inset

 e le operazioni di inserimento funzionano come di seguito:
\end_layout

\begin_layout Itemize

\emph on
DEQUEUE(PQ) 
\emph default
estra da PQ la coppia con la minima 
\begin_inset Quotes eld
\end_inset

distanza minima
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\emph on
ENQUEUE(PQ, [ptr(N), d
\begin_inset Formula $_{MIN}$
\end_inset

(q,Reg(N))]) 
\emph default
inserisce la coppia nella coda PQ in maniera ordinata.
\end_layout

\begin_layout Standard
Il 
\emph on
pruning 
\emph default
dei nodi è basato sulla seguente osservazione: se ad un certo punto dell'esecuzi
one dell'algoritmo abbiamo trovato un un punto 
\emph on
t 
\emph default
tale che 
\begin_inset Formula $d(q,t)=r$
\end_inset

, allora tutti i nodi N con distanza minima 
\begin_inset Formula $d_{MIN}(q,Reg(N))\geq r$
\end_inset

 possono essere esclusi dalla ricerca poichè non possono portare a un migliorame
nto del risultato.
 Nella descrizione dell'algoritmo, il 
\emph on
pruning
\emph default
 delle coppie della coda PQ basata sul ragionamento appena descritto viene
 effettuata nell'
\emph on
UPDATE(PQ)
\emph default
.
 Con abuso di terminologia dire che 
\begin_inset Quotes eld
\end_inset

il nodo N è in PQ
\begin_inset Quotes erd
\end_inset

 significa che la corrispondente coppia [ptr(N), d
\begin_inset Formula $_{MIN}$
\end_inset

(q,Reg(N))] sta in PQ.
\end_layout

\begin_layout Standard
Intuitivamente 
\emph on
k-NNOptimal 
\emph default
compie una 
\emph on
ricerca per range
\emph default
 con un 
\emph on
raggio di ricerca
\emph default
 variabile che man mano si restringe fino a che non è possibile più soluzioni.
\end_layout

\begin_layout Standard
Di seguito illustriamo il pseudo-codice dell'algoritmo:
\end_layout

\begin_layout Itemize

\series bold
Input
\series default
: un 
\emph on
query point q
\emph default
, un indice ad albero con nodo 
\emph on
radice
\emph default
 
\emph on
RN
\end_layout

\begin_layout Itemize

\series bold
Output
\series default
: 
\begin_inset Formula $t_{NN}(q)$
\end_inset

, il punto più vicino a q, e 
\begin_inset Formula $r_{NN}=d(q,t_{NN}(q))$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-codice k-NNOptimal
\begin_inset CommandInset label
LatexCommand label
name "fig:Pseudo-codice-k-NNOptimal"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename knnoptimal.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
E vediamo il funzionamento di 
\emph on
k-NNOptimal
\emph default
 in azione con la seguente figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:knnoptimalinaction"

\end_inset

), in cui i nodi sono numerati seguendo l'ordine con il quale vi si accede,
 gli oggetti sono numerati come vengono scoperti per migliorare (e dunque
 ridurre) il raggio di ricerca e in cui le foglie a cui si accede sono colarate
 in grigio chiaro.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:knnoptimalinaction"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename knnoptimalinaction.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vediamo un ulteriore esempio (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:bestusedcar"

\end_inset

) applicato ancora una volta alla miglior macchina usata disponibile sul
 nostro database.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:bestusedcar"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename bestusedcard.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dimostriamo ora che l'algoritmo è sia 
\emph on
corretto
\emph default
 che 
\emph on
ottimale
\emph default
.
\end_layout

\begin_layout Standard
Per la 
\emph on
correttezza
\emph default
 dell'algoritmo la dimostrazione è ovvia: l'algoritmo non “scarta” nessun
 nodo a meno che non abbia una distanza minima maggiore rispetto al valore
 di raggio di ricerca corrente, il quale (il raggio di ricerca) è sicuramente
 maggiore o uguale a 
\begin_inset Formula $r_{NN}$
\end_inset

.
\end_layout

\begin_layout Standard
Per quanto riguarda l'
\emph on
ottimalità
\emph default
 dobbiamo dimostrare il seguente teorema: l'algoritmo 
\emph on
k-NNOptimal
\emph default
 per 
\emph on
1-NN queries
\emph default
 non legge mai un nodo N la cui distanza minima è strettamente maggiore
 di 
\begin_inset Formula $r_{NN}$
\end_inset

, cioè non legge mai un nodo tale per cui 
\begin_inset Formula $d_{MIN}(q,Reg(N))>r_{NN}$
\end_inset

.
\end_layout

\begin_layout Standard
La dimostrazione è la seguente:
\end_layout

\begin_layout Enumerate
Il nodo N (la cui distanza minima è strettamente maggiore di 
\begin_inset Formula $r_{NN}$
\end_inset

) viene letto solo se, ad un qualche passo dell'esecuzione, esso diventa
 il primo elemento della coda PQ
\end_layout

\begin_layout Enumerate
Sia N1 il nodo contente 
\begin_inset Formula $t_{NN}(q)$
\end_inset

 (ovvero il nodo che contiene la soluzione), e N2 il suo padre, e N3 il
 padre di N2 e così via fino a Nh=RN (con 
\begin_inset Formula $h=$
\end_inset

altezza dell'albero) in cui RN è la radice.
\end_layout

\begin_layout Enumerate
Osserviamo che, per definizione di distanza minima, si ha
\begin_inset Formula 
\[
r_{NN}\geq d_{MIN}(q,Reg(N1))\geq d_{MIN}(q,Reg(N2)\geq\ldots\geq d_{MIN}(q,Reg(Nh))
\]

\end_inset


\end_layout

\begin_layout Enumerate
Ad ogni passo precedente al ritrovamente di 
\begin_inset Formula $t_{NN}(q)$
\end_inset

, uno e solo uno dei nodi 
\begin_inset Formula $N1,N2,\ldots,Nh$
\end_inset

 è presente nella coda prioritaria
\end_layout

\begin_layout Enumerate
Segue che N non potrà mai diventare il primo elemento di PQ
\end_layout

\begin_layout Standard
Intuitivamente, un nodo che non fa parte della catena che lega il nodo N1
 a Nh non potrà mai essere visitato prima di qualsiasi nodo che ne fa parte.
\end_layout

\begin_layout Standard
Cosa succede se troviamo un nodo N la cui distanza sia esattamente 
\begin_inset Formula $r_{NN}$
\end_inset

? Il teorema di ottimalità non dice nulla a riguardo perchè non può dire
 nulla.
 Notiamo infatti regioni di questo genere sono casi di 
\emph on
parità 
\emph default
di cui non si può sapere l'ordine relativo con cui verranno inserite in
 PQ.
 I possibili casi sono due:
\end_layout

\begin_layout Enumerate
Il 
\emph on
Nearest Neighbor
\emph default
 è in un nodo la cui regione ha distanza minima strettamente minore di 
\begin_inset Formula $r_{NN}$
\end_inset

.
 In questo cosa 
\emph on
nessun nodo
\emph default
 con distanza 
\begin_inset Formula $d_{MIN}(q,Reg(N))=r_{NN}$
\end_inset

 verrà letto
\end_layout

\begin_layout Enumerate
Il 
\emph on
Nearest Neighbor 
\emph default
si trova in un nodo la cui regione ha distanza minima esatamente uguale
 a 
\begin_inset Formula $r_{NN}$
\end_inset

.
 In questo caso tutto dipende da come PQ gestisce i casi di parità: nel
 caso peggiore 
\emph on
tutti i nodi
\emph default
 con 
\begin_inset Formula $d_{MIN}(q,Reg(N))=r_{NN}$
\end_inset

 saranno letti.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Possiamo ora facilmente estendere l'algoritmo al caso in cui 
\begin_inset Formula $k\geq1$
\end_inset

 utilizzando:
\end_layout

\begin_layout Itemize
Una struttra dati, che chiamiamo 
\emph on
Res
\emph default
, nel quale manteniamo i 
\emph on
k 
\emph default
oggetti più vicini finora trovato con la loro distanza da q.
\end_layout

\begin_layout Itemize
Come 
\begin_inset Quotes eld
\end_inset

attuale raggio di ricerca
\begin_inset Quotes erd
\end_inset

 viene usata la distanza 
\begin_inset Formula $r_{k-NN}$
\end_inset

 dell'attuale 
\emph on
k-
\emph default
esimo 
\emph on
Nearest Neighbor
\emph default
 di 
\emph on
q
\emph default
, ovvero il 
\emph on
k-
\emph default
esimo elemento di 
\emph on
Res
\emph default
.
\end_layout

\begin_layout Standard
Si veda un semplice esempio di 
\emph on
Res
\emph default
 (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:res-example"

\end_inset

) con 
\begin_inset Formula $k=5$
\end_inset

 in cui nessun nodo con distanza minima 
\begin_inset Formula $\geq15$
\end_inset

 verrà letto.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:res-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename resexample.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tutto il resto dell'algoritmo rimane invariato.
 Di seguito vediamo dunque la sua implementazione in pseudo-codice.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
k-NNOptima con 
\begin_inset Formula $k\geq1$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename knnoptimalkmaggiore.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subsection
Distance Browsing
\end_layout

\begin_layout Standard
Ora sappiamo come risolvere le 
\emph on
top-k selection queries
\emph default
 usando un indice multi-dimensionale; ma che succede se la nostra query
 fosse
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM USEDCARS
\end_layout

\begin_layout Plain Layout

WHERE Vehicle = ‘Audi/A4’
\end_layout

\begin_layout Plain Layout

ORDER BY 0.8*Price + 0.2*Mileage
\end_layout

\begin_layout Plain Layout

STOP AFTER 5;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
e avessimo un R-tree su (Price,Mileage) costruito però su 
\emph on
tutte
\emph default
 le macchine? I migliori 
\begin_inset Formula $k=5$
\end_inset

 risultati ritornati dall'indice non saranno necessariamente Audi/A4.
\end_layout

\begin_layout Standard
Una prima idea potrebbe essere di avere degli indici chiamati 
\begin_inset Quotes eld
\end_inset

colorati
\begin_inset Quotes erd
\end_inset

, ovvero con informazioni aggiuntive, ad esempio un R-tree su (Price, Mileage)
 che contenga anche informazioni sul tipo di veicolo potrebbe risolvere
 completamente il problema poichè la query verrebbe risolta via INDEX ONLY.
 Il problema nasce comunque nella realtà, poichè è difficile pensare che
 un indice aggiunga 
\begin_inset Quotes eld
\end_inset

tutte
\begin_inset Quotes erd
\end_inset

 le informazioni aggiuntive non necessarie all'indice stesso.
\end_layout

\begin_layout Standard
Ecco che in casi come questo possiamo usare una variante del 
\emph on
k-NNOptimal 
\emph default
che supporta la così detta 
\emph on
distance browsing 
\emph default
[HS99] o 
\emph on
incremental NN queries.
\end_layout

\begin_layout Standard
Per il caso 
\begin_inset Formula $k=1$
\end_inset

 la logica globale per l'uso dell'indice è la seguente:
\end_layout

\begin_layout Itemize
ottenere dall'indice il primo 
\emph on
Nearest Neighbor
\end_layout

\begin_layout Itemize
se soddisfa le condizioni della query (ad esempio Audi/A4) allora fermati,
 altrimenti ottieni il secondo 
\emph on
Neareast Neighbor 
\emph default
e ripeti il passaggio fintato che non viene trovato il primo oggetto che
 soddisfa le clausole della query
\end_layout

\begin_layout Standard
Dal punto di vista dell'indice, a questo punto 
\emph on
k
\emph default
 non è più un parametro, ovvero l'indice non sa più quando effettivamente
 fermarsi nella restituzione del prossimo NN: ovvero, utilizzando sempre
 il caso 
\begin_inset Formula $k=1$
\end_inset

, per l'indice basterebbe restituire solo il primo NN, ma se che questo
 soddisfi o meno la clausola WHERE non è più compito suo saperlo.
 Si può dunque immaginare che esista un 
\begin_inset Quotes eld
\end_inset

client
\begin_inset Quotes erd
\end_inset

 (per client si può intendere anche un operatore a livello più alto) che
 utilizza un algoritmo, quale next_NN che vedremo a breve, fintanto che
 non raggiunge il numero di tuple che gli servono e a quel punto chiude
 la 
\begin_inset Quotes eld
\end_inset

connessione
\begin_inset Quotes erd
\end_inset

 rilasciando le risorse sull'indice attraverso il metodo 
\emph on
close()
\emph default
.
\end_layout

\begin_layout Subsubsection
L'algoritmo next_NN
\end_layout

\begin_layout Standard
In una coda prioritaria PQ ora manteniamo sia le 
\emph on
tuple
\emph default
 che i 
\emph on
nodi
\emph default
: se una Entry di PQ è una tupla 
\emph on
t
\emph default
 allora la sua distanza 
\begin_inset Formula $d(q,t)$
\end_inset

 è scritta come 
\begin_inset Formula $d_{MIN}(q,Reg(t))$
\end_inset

 (giusto per uniformità, in qui la distanza da q a t viene scritta sempre
 come distanza minima tra q e la regione t, regione che risulta essere puntuale).
 Notiamo che in questo caso non è possibile alcun 
\begin_inset Quotes eld
\end_inset

potamento
\begin_inset Quotes erd
\end_inset

 (
\emph on
pruning)
\emph default
 poichè non sappiamo quanti oggetti bisogna restituire prima di fermarsi,
 per il motivo prima discusso in cui il paramentro k non è più un parametro
 dell'indice.
 Prima di effettuare la prima chiamata all'algoritmo inizializziamo la coda
 PQ con [ptr(RN),0].
 Quando una tupla 
\emph on
t
\emph default
 diventa il primo elemento della coda l'algoritmo la restituisce.
\end_layout

\begin_layout Standard
Vediamo lo pseudo-codice del metodo next_NN:
\end_layout

\begin_layout Itemize

\series bold
Input:
\series default
 la 
\emph on
query point q
\emph default
, l'indice ad albero con nodo radince 
\emph on
RN
\end_layout

\begin_layout Itemize

\series bold
Output:
\series default
 il prossimo 
\emph on
Nearest Neighbor 
\emph default
di 
\emph on
q 
\emph default
insieme alla sua distanza
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-Codice next_NN
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename next_nn.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si vede che l'algoritmo, in caso abbia in testa alla lista un Nodo e successivam
ente una Tupla, deve esaminare per forza prima il Nodo poichè potrebbero
 esserci all'interno del Nodo delle tuple più vicine rispetto alla Tupla
 già presente.
 Se invece vi è una Tupla in testa, essa può essere restituita in quanto
 sicuramente è la tupla più vicina (in quel momento).
\end_layout

\begin_layout Standard
Vediamo l'algoritmo applicato ad un esempio (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:examplenextnn"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:examplenextnn"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename examplenextnn.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'algoritmo next_NN è solo un implementazione più generale del metodo 
\emph on
next
\emph default
 per gli indici che supportano le 
\emph on
k-NN queries incrementali
\emph default
.
 In pratica, lo specifico tipo di query (che sia 
\emph on
range
\emph default
, 
\emph on
k-NN
\emph default
, 
\emph on
k-NN incrementale, 
\emph default
etc
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

) è un parametro passato all'indice nel metodo 
\emph on
open
\emph default
 così che si possa rendere sufficiente il semplice metodo 
\emph on
next
\emph default
() che implementi il 
\begin_inset Quotes eld
\end_inset

next
\begin_inset Quotes erd
\end_inset

 voluto.
\end_layout

\begin_layout Subsection
Top-k join 1:1 queries
\end_layout

\begin_layout Standard
In una 
\emph on
top-k join query 
\emph default
abbiamo
\emph on
 
\begin_inset Formula $n>1$
\end_inset

 
\emph default
relazione di input e una funzione di 
\emph on
scoring
\emph default
 S definita sul risultato di join, ad esempio:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT <some attributes>
\end_layout

\begin_layout Plain Layout

FROM R1,R2,...,Rn
\end_layout

\begin_layout Plain Layout

WHERE <join and local conditions>
\end_layout

\begin_layout Plain Layout

ORDER BY S(p1,p2,...,pm) [DESC]
\end_layout

\begin_layout Plain Layout

STOP AFTER k
\end_layout

\end_inset


\end_layout

\begin_layout Standard
dove p1,p2,...,pm sono i criteri di 
\emph on
scoring
\emph default
 (le 
\begin_inset Quotes eld
\end_inset

preferenze
\begin_inset Quotes erd
\end_inset

).
 In questo caso il nostro criterio di bontà rappresentato dalla scoring
 function si compone da tanti 
\begin_inset Quotes eld
\end_inset

pezzi
\begin_inset Quotes erd
\end_inset

 presenti perl su relazioni diverse.
\end_layout

\begin_layout Standard
Vediamo subito alcuni esempi:
\end_layout

\begin_layout Itemize
Gli impiegati più pagati in rapporto al budget del dipartimento in cui lavorano
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT E.*
\end_layout

\begin_layout Plain Layout

FROM EMP E, DEPT D
\end_layout

\begin_layout Plain Layout

WHERE E.DNO = D.DNO
\end_layout

\begin_layout Plain Layout

ORDER BY E.Salary / D.Budget DESC
\end_layout

\begin_layout Plain Layout

STOP AFTER 1
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Le due combinazioni di ristoranti-hotel più economiche nella stessa città
 italiana
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM RESTAURANTS R, HOTELS H
\end_layout

\begin_layout Plain Layout

WHERE R.City = H.City
\end_layout

\begin_layout Plain Layout

AND R.Nation = ‘Italy’ AND H.Nation = ‘Italy’
\end_layout

\begin_layout Plain Layout

ORDER BY R.Price + H.Price
\end_layout

\begin_layout Plain Layout

STOP AFTER 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una 
\emph on
top-k selection query 
\emph default
multidimensionale basate sulla funzione di scoring S(p1,p2,...,pm) può anche
 essere vista come un 
\emph on
caso particolare di join query
\emph default
 nel quale la relazione di input R è virtualmente 
\begin_inset Quotes eld
\end_inset

partizionata
\begin_inset Quotes erd
\end_inset

 in 
\emph on
m
\emph default
 parti, dove la 
\emph on
j-
\emph default
esima parte 
\emph on
R
\begin_inset Formula $_{i}$
\end_inset

 
\emph default
consiste nell'oggetto id e nell'attributo necessario per computare 
\emph on
p
\begin_inset Formula $_{j}$
\end_inset

.
 
\emph default
Tentiamo di capire cosa si vuol dire con ciò: una top-k query effettuata
 su una singola relazione R ma che si basi su una scoring function S definita
 su più 
\begin_inset Quotes eld
\end_inset

preferenze
\begin_inset Quotes erd
\end_inset

 può essere vista come una top-k query con join 1:1 in cui ogni preferenza
 della scoring function appartiene a una relazione diversa.
\end_layout

\begin_layout Standard
Ad esempio se S è definita come 
\begin_inset Formula $S(t)=(t.Price+t.Milage)/(t.Year-1970)$
\end_inset

 possiamo 
\begin_inset Quotes eld
\end_inset

partizionare
\begin_inset Quotes erd
\end_inset

 la relazione USEDCARS come 
\begin_inset Formula $UC1(CarID,Price)$
\end_inset

, 
\begin_inset Formula $UC2(CarID,Mileage)$
\end_inset

, 
\begin_inset Formula $UC3(CarID,Year)$
\end_inset

.
 Una 
\emph on
top-k selection query 
\emph default
con la scoring function prima definita, potrebbe essere visualizzata dunque
 come una 
\emph on
top-k join 
\emph default
1:1 
\emph on
query 
\emph default
così scritta:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM USEDCARS UC1, USEDCARS UC2, USEDCARS UC3
\end_layout

\begin_layout Plain Layout

WHERE UC1.CarID = UC2.CarID AND UC2.CarID = UC3.CarID
\end_layout

\begin_layout Plain Layout

ORDER BY (UC1.Price + UC2.Mileage)/(UC3.Year-1970)
\end_layout

\begin_layout Plain Layout

STOP AFTER 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nel seguente caso il join è sempre 1:1 (PK-PK join).
 Altri casi di partizionamento possono presentarsi come ad esempio 
\begin_inset Formula $UC1(CarID,Price,Mileage),$
\end_inset

 
\begin_inset Formula $UC2(CarID,Year)$
\end_inset

.
\end_layout

\begin_layout Standard
Il caso in cui tutti i join sono su una stesso attributo di chiave è stato
 il primo caso che è stato largamente studiato.
 La sua rilevanza è dovuta al fatto che è il caso più semplice da trattare,
 la sua soluzione fornisce le basi per un caso più generale ed infine è
 il caso che più volte accade.
\end_layout

\begin_layout Standard
I due scenari in cui sono presenti join 1:1 che ha senso trattare sono i
 seguenti:
\end_layout

\begin_layout Enumerate
Per ogni 
\begin_inset Quotes eld
\end_inset

preferenza
\begin_inset Quotes erd
\end_inset

 p
\begin_inset Formula $_{j}$
\end_inset

 c'è un indice capace di trovare le tuple secondo l'attributo.
 Ovvero, se precedentemente avevamo detto che per riuscire a calcolare efficacem
ente una query top-k (o addirittura una window query, o ancora una range-query)
 attraverso indici su singoli attributi portava a grosse perdite di performance,
 tentiamo ora di riuscire ugualmente a gestire la situazione.
 Ovvero se effettivamente di una relazione R abbiamo due indici mono attributo
 (ad esempio un B+tree su 
\emph on
price
\emph default
 e uno su 
\emph on
mileage
\emph default
), come risulta possibile applicarli per riuscire a risolvere effettivamente
 la top-k query (si ricade al caso in cui una top-k selection query può
 essere partizionata, in cui in questo caso ogni partizione viene rappresentata
 effettivamente dalle informazioni che un singolo indice B+tree può fornire).
\end_layout

\begin_layout Enumerate
Le 
\begin_inset Quotes eld
\end_inset

partizioni
\begin_inset Quotes erd
\end_inset

 di R sono partizioni reali, in cui ogni partizione è situata in diversi
 siti, ognuno dei quali fornisce informazioni solo su una parte degli oggetti
\end_layout

\begin_layout Standard
Storicamente il secondo scenario, molto spesso chiamato 
\begin_inset Quotes eld
\end_inset

middleware scenario
\begin_inset Quotes erd
\end_inset

, è quello che ha motivato lo studio di 
\emph on
top-k 
\emph default
1:1
\emph on
 join query
\emph default
, il quale ha portato all'introduzione del primo algoritmo conosciuto, per
 altro per nulla banale.
\end_layout

\begin_layout Subsubsection
Middleware Scenario
\end_layout

\begin_layout Standard
Il 
\emph on
middleware scenario 
\emph default
può essere descritto in maniera approssimata come segue:
\end_layout

\begin_layout Enumerate
Abbiamo un numero di 
\begin_inset Quotes eld
\end_inset


\emph on
sorgenti di dati
\emph default

\begin_inset Quotes erd
\end_inset

 (data source)
\end_layout

\begin_layout Enumerate
Le nostre richieste (query) possono coinvolgere diverse sorgenti allo stesso
 tempo
\end_layout

\begin_layout Enumerate
Il risultato della nostra query è ottenuto combinando in qualche modo il
 risultato tornato dalle diverse sorgenti
\end_layout

\begin_layout Standard
Queste query sono chiamate 
\begin_inset Quotes eld
\end_inset


\emph on
middleware query
\emph default

\begin_inset Quotes erd
\end_inset

 dato che richiedono la presenza di 
\emph on
middleware
\emph default
 (ovvero degli intermediari), il cui ruolo è di fare da intermediario tra
 l'utente/client e i vari data source/server.
\end_layout

\begin_layout Standard
Vediamo un esempio semplificato.
 Assumiamo si voglia organizzare un sito web che integra l'informazioni
 di due sorgenti: la prima sorgente 
\begin_inset Quotes eld
\end_inset

esporta
\begin_inset Quotes erd
\end_inset

 il seguente schema 
\emph on
CarPrice
\emph default
s(
\emph on
\bar under
CarModel
\bar default
, Price
\emph default
), mentre il secondo esporta 
\emph on
CarSpec
\emph default
(
\emph on
\bar under
Make, Model
\bar default
, FuelConsumpion
\emph default
).
 Dopo una prima fase di 
\begin_inset Quotes eld
\end_inset

riconciliazione
\begin_inset Quotes erd
\end_inset

 in cui si trasforma il nostro CarModel=
\begin_inset Quotes erd
\end_inset

Audi/A4
\begin_inset Quotes erd
\end_inset

 come segue
\begin_inset Formula 
\[
CarModel='Audi/A4'\Leftrightarrow(Make,Model)=('Audi','A4')
\]

\end_inset


\end_layout

\begin_layout Standard
possiamo supportare ora query su entrambi gli attributi rimanenti 
\emph on
Price
\emph default
 e 
\emph on
FuelConsumption
\emph default
 come ad esempio trovare tutte le macchine il cui consumo è minore di 7
 litri ogni 100km e con un costo minimo di 15000$.
\end_layout

\begin_layout Standard
Come ci riusciamo?
\end_layout

\begin_layout Enumerate
Inviamo la (sub-)query su 
\emph on
Price
\emph default
 alla fonte 
\emph on
CarPrices
\end_layout

\begin_layout Enumerate
Inviamo la query sul consumo di carburante alla fonte 
\emph on
CarSpec
\end_layout

\begin_layout Enumerate
Eseguiamo il 
\emph on
join
\emph default
 dei risultati
\end_layout

\begin_layout Standard
Si guardi la figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:middlewarescenarioexample"

\end_inset

) per una maggiore comprensione
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:middlewarescenarioexample"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename middlewarescenarioexample.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Vediamo un altro esempio in cui si voglia costruire un sito che integra
 informazioni di siti di 
\emph on
m
\emph default
 rivenditori di auto.
 Ogni rivenditore di auto CD
\begin_inset Formula $_{j}$
\end_inset

 puà darci la seguente informazione 
\emph on
CarDealer
\begin_inset Formula $_{j}$
\end_inset


\emph default
(
\emph on
\bar under
CarID
\bar default
, Make, Model, Price
\emph default
) e il nostro obiettivo è di fornire ai nostri utenti le macchine più economiche
 disponibili, ossia di riuscire a supportare query del tipo: 
\begin_inset Quotes eld
\end_inset

Per ogni modello FIAT, quale ha un'offerta migliore?
\begin_inset Quotes erd
\end_inset

.
 Di nuovo come ci riusciamo?
\end_layout

\begin_layout Enumerate
Mandiamo la stessa (sub-)query a tutti i nostri data source
\end_layout

\begin_layout Enumerate
Facciamo l'unione dei risultati
\end_layout

\begin_layout Enumerate
Per ogni modello, prendiamo la miglior offerta e il corrispondente rivenditore
\end_layout

\begin_layout Standard
Per query di questo tipo, il mediatore è spesso chiamato 
\begin_inset Quotes eld
\end_inset

meta-broker
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

meta-search engine
\begin_inset Quotes erd
\end_inset

.
 Si veda di seguito lo schema di funzionamento (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:middlewarescenario02"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:middlewarescenario02"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename middlewarescenario02.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Le 
\emph on
top-k middleware query 
\emph default
è solo un altro nome per le 
\emph on
top-k 
\emph default
1:1 
\emph on
join query
\emph default
, che risulta appropriato quando i dati che necessitano di join 1:1 sono
 distribuiti.
 Sebbene lo scenario locale e quello distribuito abbiano proprietà differenti
 (ad esempio costi di comunicazione, disponibilità di risorse, etc
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

), per entrambe si possono applicare gli stessi principi (e algoritmi) per
 computare il risultato di una 
\emph on
query top-k
\emph default
.
 In particolare in entrambi gli scenari ragioniamo in termini di 
\begin_inset Quotes eld
\end_inset

input
\begin_inset Quotes erd
\end_inset

: 
\emph on
data source
\emph default
 nel caso di sistema distribuito, 
\emph on
relazioni
\emph default
 in caso di scenario locale.
\end_layout

\begin_layout Standard
Per ragioni che presto chiariremo, il 
\emph on
j
\emph default
-esimo input sarà indicato con 
\begin_inset Formula $L_{j}$
\end_inset

.
 Inoltre per semplificare la notazione ragioneremo in termini di 
\begin_inset Quotes eld
\end_inset

oggetti
\begin_inset Quotes erd
\end_inset

 invece che tuple per farne lo score globale: questo perchè è ragionevole
 dire che un oggetto 
\emph on
o
\emph default
 appartiene a due differenti input, mentre sarebbe sbagliato dire lo stesso
 per una tupla.
\end_layout

\begin_layout Standard
Se si vuole evitare di leggere tutti gli input, le seguenti assunzioni risultano
 essere abbastanza necessarie:
\end_layout

\begin_layout Enumerate
Ogni input 
\begin_inset Formula $L_{j}$
\end_inset

 supporta un'interfaccia ad 
\emph on
accesso
\emph default
 
\emph on
ordinat
\emph default
o (s.a):
\begin_inset Formula 
\[
getNext_{L_{j}}()\rightarrow(OID,Attributes,p_{j})
\]

\end_inset

 Un accesso ordinato ottiene l'
\emph on
id
\emph default
 del prossimo miglior oggetto (rappresentato dall'
\emph on
OID
\emph default
) secondo il suo score parziale 
\begin_inset Formula $p_{j}$
\end_inset

 (ovvero lo score che ottiene su quel determinato input seguendo una determinata
 scoring function parziale) assieme, possibilmente, ai restanti attributi
 richiesti dalla query.
 Per questo motivo 
\begin_inset Formula $L_{j}$
\end_inset

 risulta essere una 
\emph on
lista con priorità 
\emph default
(ranked list) il che giustifica il suo nome (
\begin_inset Quotes eld
\end_inset

L
\begin_inset Quotes erd
\end_inset

 sta per lista).
\end_layout

\begin_layout Enumerate
Ogni input 
\begin_inset Formula $L_{j}$
\end_inset

 supporta anche un'interfaccia ad 
\emph on
accesso casuale
\emph default
 (r.a):
\begin_inset Formula 
\[
getScore_{L_{j}}(OID)\rightarrow p_{j}
\]

\end_inset

 ovvero, dato l'id di un oggetto, si riesca ad avere il suo risultato parziale
 
\begin_inset Formula $p_{j}$
\end_inset

.
\end_layout

\begin_layout Enumerate
L'identificatore di un oggetto OID è un identificatore 
\emph on
globale
\emph default
: dato un oggetto esso ha lo stesso identificatore su tutti gli input
\end_layout

\begin_layout Enumerate
Ogni input comprende lo stesso set di oggetti, ovvero se un oggetto X è
 presente su un input j, deve essere presente anche su tutti i restanti
 (questo per evitare di dover trattare i valori nulli, in cui la situazione
 si complica).
\end_layout

\begin_layout Standard
L'assunzione 3 e 4 sono banalmente verificate se la top-k 1:1 join query
 è eseguita localmente poichè le liste di join sono semplici 
\emph on
ranking
\emph default
 diversi di una stessa relazione.
\end_layout

\begin_layout Standard
In un ambiente distribuito l'assunzione 3 è difficilmente verificata: la
 sfida dunque di riuscire ad 
\begin_inset Quotes eld
\end_inset

unificare
\begin_inset Quotes erd
\end_inset

 le descrizioni fornite dalle diverse data source.
 Se l'assunzione 4 non è verificata potrebbe verificarsi la perdita di alcuni
 risultati parziali (poichè non presente un determinato oggetto su un determinat
o input): la strategia da attuare dipende dalla specifica 
\emph on
scoring function 
\emph default
(ad esempio se Budget non è definito allora neanche Salary/Budget lo è).
 Per riuscire a supportare l'accesso ordinato è possibile utilizzare l'algoritmo
 
\emph on
next_NN
\emph default
, invece per supportare l'accesso casuale è richiesto un indice su chiave
 primaria.
\end_layout

\begin_layout Standard
Vediamo un esempio in cui si vogliano aggregare le recensioni di alcuni
 ristoranti (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exampletopkjoin11"

\end_inset

).
 Si nota che il vincitore globale non necessariamente è il migliore a livello
 locale.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:exampletopkjoin11"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename exampletopkjoin11.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Per riuscire ad ottenere un approccio univoco al problema considereremo:
\end_layout

\begin_layout Itemize
Una 
\emph on
top-k 
\emph default
1:1 
\emph on
join query 
\emph default

\begin_inset Formula $Q=(Q_{1},Q_{2},\ldots,Q_{m})$
\end_inset

 in cui ogni 
\begin_inset Formula $Q_{j}$
\end_inset

 è la sub-query richiesta alla 
\emph on
j-
\emph default
esima relazione/data source.
\end_layout

\begin_layout Itemize
Ogni oggetto 
\emph on
o
\emph default
 ritornato dall'input 
\begin_inset Formula $L_{j}$
\end_inset

 ha associato un punteggio locale/parziale 
\begin_inset Formula $p_{j}(o)\,\epsilon\,[0,1]$
\end_inset

 dipendente da 
\begin_inset Formula $Q_{j}$
\end_inset

 (ovvero dipendente dalla sub-query che viene richiesta al'input j-esimo)
\end_layout

\begin_deeper
\begin_layout Itemize
Per convenzione i punteggi sono normalizzati con il punteggio più alto che
 si ottiene
\end_layout

\begin_layout Itemize
Questo vincolo può essere facilmente rilassato: ciò che conta infatti è
 sapere il miglior e il peggior valore possibile di 
\begin_inset Formula $p_{j}$
\end_inset


\end_layout

\begin_layout Itemize
L'iper-cubo 
\begin_inset Formula $[0,1]^{m}$
\end_inset

 è chiamato 
\begin_inset Quotes eld
\end_inset

spazio dei punteggi
\begin_inset Quotes erd
\end_inset

 (
\emph on
score space
\emph default
)
\end_layout

\end_deeper
\begin_layout Itemize
Il punto 
\begin_inset Formula $p(o)=(p_{1}(o),p_{2}(o),\ldots,p_{m}(o))\,\epsilon\,[0,1]^{m}$
\end_inset

 rappresenta l'oggetto 
\emph on
o 
\emph default
nello spazio dei punteggi, in cui dunque un oggetto può essere rappresentanto
 il piano calcolando per ogni coordinata il suo punteggio parziale che ottiene
 su quella determinata coordinata, in cui la coordinata in questo caso rappresen
ta il valore di bontà di una determinata 
\begin_inset Quotes eld
\end_inset

preferenza
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Il punteggio totale/globale 
\emph on
S
\emph default
(
\emph on
o
\emph default
) dell'oggetto 
\emph on
o 
\emph default
è calcolato mediante una funzione di successo S (una 
\emph on
scoring function
\emph default
) che combina in qualche modo tutti i possibili punteggi locali di 
\emph on
o
\emph default
:
\begin_inset Formula 
\[
S\,:\,[0,1]^{m}\rightarrow\mathbb{R}
\]

\end_inset


\begin_inset Formula 
\[
S(o)\equiv S(p(o))=S(p_{1}(o),p_{2}(o),\ldots,p_{m}(o))
\]

\end_inset


\end_layout

\begin_layout Standard
Riprendiamo in esempio lo spazio degli attributi, considerando lo spazio
 a due dimensioni 
\begin_inset Formula $A=(Price,Mileage)$
\end_inset

.
 Sia Q1 la sub-query su 
\emph on
Price
\emph default
 e Q2 la sub-query su 
\emph on
Mileage
\emph default
.
 Possiamo impostare 
\begin_inset Formula $p_{1}(o)=1-\frac{o.Price}{MaxP}$
\end_inset

 e 
\begin_inset Formula $p_{2}(o)=1-\frac{o.Mileage}{MaxM}$
\end_inset

 in cui MaxP e MaxM sono rispettivamente il massimo prezzo (per esempio
 
\begin_inset Formula $MaxP=50000$
\end_inset

) e il massimo chilometraggio (ad esempio 
\begin_inset Formula $MaxM=80000$
\end_inset

).
 Gli oggetti in A (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fromattributetoscore"

\end_inset

 a sinitra) vengono mappati nello spazio dei punteggi (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fromattributetoscore"

\end_inset

 a destra).
 Gli ordini relativi su ogni coordinata (
\emph on
local ranking
\emph default
) rimane invariato
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fromattributetoscore"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename fromattributetoscore.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Alcune delle 
\emph on
scoring function
\emph default
 più comuni sono le seguenti:
\end_layout

\begin_layout Itemize
SUM (AVG): si sommano i valori delle 
\begin_inset Quotes eld
\end_inset

preferenze
\begin_inset Quotes erd
\end_inset

 (sarebbe quasi identico se ne calcolassimo la media).
\begin_inset Formula 
\[
SUM(o)\equiv SUM(p(o))=p_{1}(o)+p_{2}(o)+\ldots+p_{m}(o)
\]

\end_inset


\end_layout

\begin_layout Itemize
WSUM (Weighted sum): attribuendo pesi differenti sugli attributi di ranking
\begin_inset Formula 
\[
WSUM(o)\equiv WSUM(p(o))=w_{1}\cdot p_{1}(o)+\ldots+w_{m}\cdot p_{m}(o)
\]

\end_inset


\end_layout

\begin_layout Itemize
MIN (Minimum): considera semplicemente il peggior punteggio parziale
\begin_inset Formula 
\[
MIN(o)\equiv MIN(p(o))=min\left\{ p_{1}(o),p_{2}(o),\ldots,p_{m}(o)\right\} 
\]

\end_inset


\end_layout

\begin_layout Itemize
MAX (Maximum): considera semplicemente il miglior punteggio parziale
\begin_inset Formula 
\[
MAX(o)\equiv MAX(p(o))=max\left\{ p_{1}(o),p_{2}(o),\ldots,p_{m}(o)\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
Si ricordi, anche se utilizziamo la funzione MIN, che vogliamo sempre ottenere
 i 
\emph on
k
\emph default
 oggetti con il più alto punteggio globale.
\end_layout

\begin_layout Standard
Come abbiamo fatto nello spazio degli attributi in cui abbiamo definito
 curve equi-distanti, possiamo ugualmente definire nello spazio dei punteggi
 curve con lo stesso punteggio.
 Si guardi la figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:isoscoring"

\end_inset

) in cui vengono mostrate le curve delle funzioni MIN e MAX.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:isoscoring"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename iso-scoring.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Possiamo ora domandarci come riuscire a calcolare efficientemente il risultato
 di una 
\emph on
top-k 
\emph default
1:1 
\emph on
join query
\emph default
 usando una 
\emph on
scoring function S
\emph default
.
\end_layout

\begin_layout Standard
Nel caso particolare in cui 
\begin_inset Formula $S\equiv MAX$
\end_inset

 la soluzione è molto semplice [Fag96]: possiamo utilizzare l'algoritmo
 
\begin_inset Formula $B_{0}$
\end_inset

 che riesce ad ottenere la soluzione semplicemente calcolando i migliori
 
\emph on
k
\emph default
 oggetti da ogni risorsa.
 
\series bold
NB 
\series default

\begin_inset Formula $B_{0}$
\end_inset

 funziona solo in cui la 
\emph on
scoring function
\emph default
 è MAX, per tutte le altre funzioni di successo si richiede l'utilizzo di
 algoritmi più intelligenti e costosi.
\end_layout

\begin_layout Paragraph
Algoritmo B
\begin_inset Formula $_{0}$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Input
\series default
: 
\emph on
Ranked List 
\emph default

\begin_inset Formula $L_{j}$
\end_inset

 (
\begin_inset Formula $j=1,\ldots,m$
\end_inset

), un inter 
\begin_inset Formula $k\geq1$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Output
\series default
: i 
\emph on
top-k
\emph default
 oggetti in accordo alla funzione di successo MAX
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-codice Algoritmo B
\begin_inset Formula $_{0}$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Pseudo-codice-Algoritmo-B"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename b0algoritmo.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Predisponiamo in memoria un buffer B, e inizializziamo gli insiemi Obj(j),
 uno per ogni risorsa, vuoti.
 Per ogni input j, tento dunque di riempire l'insieme Obj(j) semplicemente
 usando il getNext (ovvero un next_NN) che restituisce il prossimo NN fino
 ad averne k: inoltre ogni volta che trovo un oggetto controllo se l'avevo
 già incontrato (e in caso aggiungo all'oggetto anche il risultato parziale
 appena trovato) oppure lo inserisco nel buffer B.
 Infine per ogni oggetto che ho visto almeno una volta, ovvero che ha almeno
 un risultato parziale, calcolo la 
\emph on
scoring function 
\emph default
MAX su di esso e infine restituisco i primi k oggetti.
\end_layout

\begin_layout Standard
L'algoritmo 
\begin_inset Formula $B_{0}$
\end_inset

 semplicemente adopera 
\emph on
k
\emph default
 accessi ordinati su ogni lista (
\emph on
k 
\emph default
s.a.
 
\begin_inset Quotes eld
\end_inset

round
\begin_inset Quotes erd
\end_inset

) e successivamente calcola il risultato senza il bisogno di ottenere i
 risultati parziali mancanti (cioè non è necessario alcun accesso casuale).
\end_layout

\begin_layout Standard
E vediamo l'algoritmo in azione su due esempi (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:b0esempi"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:b0esempi"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename b0esempio.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vediamo effettivamente perchè l'algoritmo 
\begin_inset Formula $B_{0}$
\end_inset

 riesca a lavorare grazie ad un intuizione grafica.
 Prendiamo come esempio la seguente figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:b0works"

\end_inset

).
 L'algoritmo 
\begin_inset Formula $B_{0}$
\end_inset

 adopera inizialmente un accesso ordinato secondo le varie preferenze, il
 che può essere visto attraverso le frecce presenti su L1 e L2, in cui viene
 restituito prima il valore più alto e man mano valori più bassi fino a
 trovare i primi 
\emph on
k
\emph default
.
 Seguendo prima L1, si vede che abbiamo trovato k oggetti con score parziale
 su S1
\begin_inset Formula $\geq0.6$
\end_inset

.
 Successivamente seguendo L2 si vede che si trovano k oggetti con score
 parziale su S2
\begin_inset Formula $\geq0.8$
\end_inset

.
 Poichè la stiamo trattando la scoring function MAX, vuol dire che lo score
 globale di un oggetto nel risultato sarà sicuramente 
\begin_inset Formula $\geq0.8$
\end_inset

 poichè appunto ho trovato k oggetti su S2 che rispettano questo vincolo.
 Dunque, ci saranno almeno 
\emph on
k
\emph default
 oggetti 
\emph on
o
\emph default
 tali per cui 
\begin_inset Formula $S(o)\geq0.8$
\end_inset

 e ciò accade perchè almeno una scansione ad accesso ordinato (nel nostro
 caso L2) si ferma dopo il ritrovamento, al 
\emph on
k-
\emph default
esimo 
\begin_inset Quotes eld
\end_inset

round
\begin_inset Quotes erd
\end_inset

 e quindi alla k-esima tupla che ci serve, di un oggetto con punteggio locale
 uguale a 0.8.
 Un oggetto 
\emph on
o' 
\emph default
che non è stato trovato lungo alcuna scansione ad accesso ordinato (e dunque
 
\begin_inset Formula $o'\notin Obj$
\end_inset

, ovvero l'insieme degli oggetti che hanno almeno uno score parziale) non
 può avere un punteggio globale migliore di 0.8 e quindi sicuramente non
 farà parte del risultato.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:b0works"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename b0works.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Riprendendo l'esempio dei ristoranti, dopo 3 accessi ordinati vi è la garanzia
 che ci siano almeno 3 ristornati 
\emph on
o 
\emph default
con 
\begin_inset Formula $S(o)\geq8.3$
\end_inset

 (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:b0worksrest"

\end_inset

).
 Un ristorante come 
\emph on
o'
\emph default
 non è stato trovato da alcuna scansione ad accesso ordinato (e dunque 
\begin_inset Formula $o'\notin Obj$
\end_inset

) non può avere un punteggio glovale maggiore di 8.3
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:b0worksrest"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename b0worksrest.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Diamo ora la prova che l'algoritmo 
\begin_inset Formula $B_{0}$
\end_inset

 sia 
\emph on
corretto.

\emph default
 Sia 
\emph on
Res
\emph default
 il risultato di 
\begin_inset Formula $B_{0}$
\end_inset

 (
\begin_inset Formula $Res\subseteq Obj$
\end_inset

).
 Il bisogno di avere una dimostrazione formale della correttezza è motivata
 dalla seguente affermazione: se 
\begin_inset Formula $o\in Obj-Res$
\end_inset

, allora non vi è garanzia sulla correttezza di 
\begin_inset Formula $S(o)$
\end_inset

.
 Dobbiamo dunque dimostrare che ciò non altera il risultato.
 D'altra parte se 
\begin_inset Formula $o\notin Obj$
\end_inset

 allora abbiamo appena dimostrato che 
\emph on
o 
\emph default
non può essere migliore di qualsiasi oggett in 
\emph on
Res
\emph default
.
\end_layout

\begin_layout Standard
Teorema: L'algoritmo 
\begin_inset Formula $B_{0}$
\end_inset

 determina correttamente i 
\emph on
top-k
\emph default
 oggetti e il loro punteggio globale.
\end_layout

\begin_layout Standard
Dividiamo la dimostrazione in due parti: prima dimostriamo che se 
\begin_inset Formula $o\in Res$
\end_inset

 allora 
\begin_inset Formula $S(o)$
\end_inset

 è 
\emph on
corretto
\emph default
, poi dimostreremo che se 
\begin_inset Formula $o\in Obj-Res$
\end_inset

 allora anche se il suo risultato globale non è corretto, l'algoritmo determina
 comunque correttamente i 
\emph on
top-k
\emph default
 oggetti.
\end_layout

\begin_layout Paragraph
Passo 1
\end_layout

\begin_layout Standard
Sia 
\begin_inset Formula $SB_{0}(o)$
\end_inset

 il punteggio globale così come lo calcola 
\begin_inset Formula $B_{0}$
\end_inset

 per un determinato oggetto 
\begin_inset Formula $o\in Obj$
\end_inset

.
 Per definizione di MAX allora 
\begin_inset Formula $SB_{0}(o)\leq S(o)$
\end_inset

.
 Sia 
\begin_inset Formula $o1\in Res$
\end_inset

 e assumiamo per contraddizione che 
\begin_inset Formula $SB_{0}(o1)<S(o1)$
\end_inset

.
 Questo implica dire che esiste una 
\begin_inset Formula $L_{j}$
\end_inset

 tale che 
\begin_inset Formula $o1\notin Obj(j)$
\end_inset

 e che 
\begin_inset Formula $S(o1)=p_{j}(o1)$
\end_inset

.
 A sua volta questo implica che ci sono 
\emph on
k
\emph default
 oggetti 
\begin_inset Formula $o\in Obj(j)$
\end_inset

 tali che
\begin_inset Formula 
\[
SB_{0}(o1)<S(o1)=p_{j}(o1)\leq p_{j}(o)\leq SB_{0}(o)\leq S(o)\,\,\forall o\in Obj(j)
\]

\end_inset


\end_layout

\begin_layout Standard
E dunque 
\emph on
o1 
\emph default
non può appartenere a 
\emph on
Res.
 
\emph default
Si ha una contraddizione.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename step01ob0.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Passo 2
\end_layout

\begin_layout Standard
Consideriamo un oggetto 
\begin_inset Formula $o1\in Obj-Res$
\end_inset

.
 Se 
\begin_inset Formula $SB_{0}(o1)=S(o1)$
\end_inset

 non vi è nulla da dimostrare.
 Altrimenti assumiamo che almeno un punteggio parziale di o1, 
\begin_inset Formula $p_{j}(o1)$
\end_inset

, non sia disponibile e che 
\begin_inset Formula $SB_{0}(o1)<S(o1)=p_{j}(o1)$
\end_inset

.
 Allora
\begin_inset Formula 
\[
SB_{0}(o1)<S(o1)=p_{j}(o1)\leq p_{j}(o)\leq SB_{0}(o)\leq S(o)\,\,\forall o\in Obj(j)
\]

\end_inset

 Poichè ogni oggetto in 
\emph on
Res
\emph default
 ha un punteggio globale almeno pari al peggior punteggio visto su 
\begin_inset Formula $L_{j}$
\end_inset

, segue che è impossibile avere 
\begin_inset Formula $S(o1)>S(o)$
\end_inset

 se 
\begin_inset Formula $o\in Res$
\end_inset

 .
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename step02b0.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Una domanda interessante che possiamo porci è se è possibile calcolare il
 risultato corretto tilizzando meno di 
\emph on
k 
\emph default
round di accessi ordinati.
 Si veda il seguente esempio (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esempiomenok"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:esempiomenok"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename esempiomenok.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se:
\end_layout

\begin_layout Itemize
\begin_inset Formula $k=1$
\end_inset

 serve necessariamente almeno un round: potremmo al più risparmiare un accesso
 ordinato se avessimo il 
\emph on
fetch
\emph default
 dell'oggetto con il maggior punteggio.
\end_layout

\begin_layout Itemize
\begin_inset Formula $k=2$
\end_inset

 servono necessariamente due round: potremmo salvare un accesso ordinato
 se prima accedessimo alla relazione MangiarBene
\end_layout

\begin_layout Itemize
\begin_inset Formula $k=3$
\end_inset

 potremmo fermarci dopo soli due round
\end_layout

\begin_layout Itemize
\begin_inset Formula $k=4$
\end_inset

 potremmo fermarci al terzo round.
\end_layout

\begin_layout Standard
Esiste dunque una regola generale per riuscire a capire se possiamo usare
 meno di k round?
\end_layout

\begin_layout Standard
Per ogni lista 
\begin_inset Formula $L_{j}$
\end_inset

, assumiamo che 
\begin_inset Formula $\underline{p}_{j}$
\end_inset

 denoti il 
\emph on
peggior 
\emph default
punteggio visto finora sulla deermina lista.
 Assumiamo che 
\emph on
Res
\emph default
 denoti l'insieme dei top-k oggetti, ordinati secondo il loro attuale valore
 MAX; allora Res[k].score è il peggiore di essi.
 La seguente condizione di stop è sempre verificata dopo 
\emph on
k round 
\emph default
di accesso ordinato, ma potrebbe verificarsi anche prima.
\end_layout

\begin_layout Standard

\bar under
Teorema
\bar default
: Un algoritmo per 
\emph on
top-k 
\emph default
1:1 
\emph on
join queries
\emph default
 che usi MAX come 
\emph on
scoring function
\emph default
 può fermarsi se e solo se 
\begin_inset Formula $Res[k].score\geq max_{j}\{\underline{p_{j}}\}$
\end_inset

.
\end_layout

\begin_layout Standard
Dimostrazione della 
\emph on
sufficienza
\emph default
: Siccome ogni 
\begin_inset Formula $L_{j}$
\end_inset

 è ordinata secondo valori non crescenti di 
\emph on
p
\begin_inset Formula $_{j}$
\end_inset

, 
\emph default
nessun oggetto che non è stato incontrato su 
\begin_inset Formula $L_{j}$
\end_inset

 può avere un punteggio parziale più alto di 
\begin_inset Formula $\underline{p}_{j}$
\end_inset

.
 Perciò nessun oggetto non incontrato può avere un valore più alto fra 
\begin_inset Formula $max_{j}\{\underline{p}_{j}\}$
\end_inset

.
 Segue che 
\emph on
Res
\emph default
 è corretta e che i punteggi degli oggetti in 
\emph on
Res
\emph default
 sono anch'essi corretti.
\end_layout

\begin_layout Standard
Dimostrazione della necessità: Assumiamo che l'algoritmo si fermi quando
 
\begin_inset Formula $Res[k].score<max_{j}\{\underline{p_{j}}\}$
\end_inset

.
 Allora una lista 
\begin_inset Formula $L_{j}$
\end_inset

 con un 
\begin_inset Formula $\underline{p_{j}}>Res[k].score$
\end_inset

 potrebbe contenere un oggetto 
\emph on
o 
\emph default
tale che 
\begin_inset Formula $p_{j}(o)>Res[k].score$
\end_inset

.
\end_layout

\begin_layout Standard
Si può pensare anche di creare un algoritmo che invece che minimizzare il
 numero di 
\emph on
round
\emph default
 minimizzi il numero degli accessi ordinati effettivi.
 Per far ciò l'esecuzione degli accessi ordinati sulle liste non deve eseguire
 uno schema 
\emph on
round robin 
\emph default
e quindi la profondità su ogni lista potrebbe essere diverso e potremmo
 trovarci in una situazione come la seguente (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:maxoptimal01"

\end_inset

)
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:maxoptimal01"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename maxoptimal01.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'algoritmo che utilizza questo approccio, denominato 
\series bold
MaxOptimal
\series default
, utilizza gli stessi princi di k-NNOptimal, ovvero si prosegue l'accesso
 casuale sulla lista più 
\begin_inset Quotes eld
\end_inset

ottimistica
\begin_inset Quotes erd
\end_inset

.
 Ad ogni passo effettua un accesso ordinato sulla lista più promettente
 
\begin_inset Formula $L_{j}*$
\end_inset

, per il quale cioè 
\begin_inset Formula $\underline{p_{j}}*$
\end_inset

 risulti massimo: 
\begin_inset Formula $j*=argmax_{j}\{\underline{p_{j}}\}$
\end_inset

.
 L'algoritmo mantiene in memoria solo i 
\emph on
k
\emph default
 migliori oggetti visti finora.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-Codice MaxOptimal
\begin_inset CommandInset label
LatexCommand label
name "fig:Pseudo-Codice-MaxOptimal"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename maxoptimalpseudo.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La condizione di stop è effettivamente quella vista prima, e l'algoritmo
 se trova un oggetto migliore fra quelle presenti in Res (controllando solo
 Res[k]), allora aggiorna Res con questa nuovo oggetto (o modificando un
 valore già esistente se l'oggetto faceva già parte di Res, o eliminando
 Res[k] e aggiungendo nella giusta posizione il nuovo oggetto).
\end_layout

\begin_layout Standard
Si veda il seguente esempio (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:maxoptimalexample"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:maxoptimalexample"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename maxoptimalexample.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La dimostrazione dell'ottimalità di MaxOptimal si basa sulla stessa di k-NNOptim
al, ovvero se non controllassimo la lista con valore peggiore 
\begin_inset Quotes eld
\end_inset

più alto
\begin_inset Quotes erd
\end_inset

 per prima, saremmo comunque costretti a controllarla successivamente poichè
 nulla potrebbe escluderci che nella lista più promettente ci sia effettivamente
 un risultato migliore.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Ci si potrebbe chiedere se l'algoritmo 
\begin_inset Formula $B_{0}$
\end_inset

 funzioni anche utilizzando 
\emph on
scoring function 
\emph default
diverse rispetto al MAX.
 Vediamo subito un esempio (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:b0sumin"

\end_inset

) in cui utilizziamo la 
\emph on
scoring function 
\emph default
MIN e con 
\begin_inset Formula $k=1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:b0sumin"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename b0sumin.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si vede il risultato è sbagliato, infatti controllando solo il primo
 NN su ogni input, si ottengono solo i valori per o2 e o7 (di cui di o7
 prendiamo il valore minimo), e dell'insieme Obj restituiamo solo la prima
 tupla, ovvero o2.
 Il risultato è sbagliato in quanto controllando i restanti risultati parziali
 di o2 (ovvero anche 0.6 e 0.8) il valore della scoring function MIN applicato
 a o2 sarebbe 
\begin_inset Formula $S(o2)=0.6$
\end_inset

 e non 0.95.
 Potrebbe venire il dubbio che il problema sia proprio questo, ovvero il
 non vedere tutti i risultati parziali degli oggetti.
\end_layout

\begin_layout Standard
Calcolando dunque tutti i risultati parziali degli oggetti in Obj (
\begin_inset Formula $Obj=\{o2,o7\}$
\end_inset

) attraverso degli 
\emph on
accessi casuali
\emph default
 come, 
\begin_inset Formula 
\[
getScore_{L_{1}}(o2),\, getScore_{L_{3}}(o2),\, getScore_{L_{2}}(o7)
\]

\end_inset

 si otterebbe dunque il seguente risultato (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:b0sumin02"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:b0sumin02"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename b0sumin02.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
il quale risulterebbe ancora sbagliato poichè in realtà, il primo NN della
 nostra query sarebbe in realtà o3 (si veda come i punteggi parziali di
 o3 sono 
\begin_inset Formula $\{0.65,0.7,0.7\}$
\end_inset

 di cui il risultato globale, ovvero il minimo, è 0.65 che risulta essere
 migliore del risultato globale di o2 ovvero 0.6).
\end_layout

\begin_layout Standard
Perchè dunque 
\begin_inset Formula $B_{0}$
\end_inset

 non funziona con 
\emph on
scoring function 
\emph default
diverse da MAX.
 Ancora una volta un intuizione grafica potrebbe aiutarci.
 Utilizziamo di nuovo come 
\emph on
scoring funcion 
\emph default
MIN e 
\begin_inset Formula $k=1$
\end_inset

.
 Quando la scansione ad accesso ordinata termina, non abbiamo in realtà
 alcun 
\emph on
lower bound
\emph default
 sul risultato globale degli oggetti finora visti (il quale potrebbe essere
 anche uguale a 0).
 Un oggetto 
\emph on
o'
\emph default
 che non è stato incontrato su alcun accesso ordinato potrebbe essere in
 realtà il vero vincitore ovvero potrebbe dominare sugli oggetti trovati
 in Obj.
 Lo stesso problema si potrebbe avere anche in caso di funzione SUM.
 Si veda la figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:b0suminwhynot"

\end_inset

) per una maggiore comprensione.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:b0suminwhynot"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename b0suminwhynot.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
E dunque? Esiste soluzione?
\end_layout

\begin_layout Subsubsection
Algoritmo FA
\end_layout

\begin_layout Standard
L'algoritmo FA (o 
\begin_inset Formula $A_{0}$
\end_inset

) [Fag96] può essere utilizzato per risolovere 
\emph on
top-k 
\emph default
1:1 
\emph on
join queries 
\emph default
che utilizzino una qualsiasi 
\emph on
scoring function 
\emph default
S 
\emph on
\bar under
monotona
\emph default
\bar default
.
 Definizione di 
\emph on
scoring function monotona
\emph default
: data una 
\emph on
scoring function
\emph default
 S n-aria, essa è monotona se
\begin_inset Formula 
\[
x_{1}\leq y_{1},\, x_{2}\leq y_{2},\,\ldots,\, x_{n}\leq y_{n}\Rightarrow S(x_{1},x_{2},\ldots,x_{n})\leq S(y_{1},y_{2},\ldots,y_{n})
\]

\end_inset


\end_layout

\begin_layout Standard
ovvero una funzione di scoring è monotona se dati due punti 
\emph on
x
\emph default
 e 
\emph on
y
\emph default
, se ogni cordinata di 
\emph on
x
\emph default
 risulta minore o uguale a ogni coordinata di 
\emph on
y 
\emph default
allora la scoring function calcolata su x è minore o uguale alla scoring
 function calcolata su y.
\end_layout

\begin_layout Standard
Perchè introdurre funzioni monotone? Perchè nella realtà è ciò che ci potrebbe
 aspettare, ovvero migliorando la bontà di una determinata caratteristica,
 ci si aspetta che la bontà globale non risulti peggiore, ovvero sarebbe
 strano che migliorando un criterio la valutazione globale cali.
 
\end_layout

\begin_layout Standard
L'algoritmo 
\emph on
FA
\emph default
 sfrutta la proprietà di monotonicità per sapere quando la scansione ad
 accesso ordinato può fermarsi.
 Si veda infatti la seguente figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:faexploit"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:faexploit"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename faexploit.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nessun oggetto racchiuso all'interno dell'iper-rettangolo definito dall'oggetto
 
\emph on
o
\emph default
, indipendentemente dalla scoring function utilizzata (importante è che
 sia monotona), potrà avere uno punteggio globale maggiore o uguale dell'oggetto
 
\emph on
o 
\emph default
stesso.
\end_layout

\begin_layout Paragraph
Algoritmo FA
\end_layout

\begin_layout Itemize

\series bold
Input
\series default
: Ranked List 
\begin_inset Formula $L_{j}$
\end_inset

 (
\begin_inset Formula $j=1,\ldots,m)$
\end_inset

, un intero 
\begin_inset Formula $k\geq1$
\end_inset

, una 
\emph on
scoring function 
\emph default
S
\emph on
 monotona
\end_layout

\begin_layout Itemize

\series bold
Output
\series default
: i 
\emph on
top-k 
\emph default
oggetti in accordo a S
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-Codice Algoritmo FA
\begin_inset CommandInset label
LatexCommand label
name "fig:Pseudo-Codice-Algoritmo-FA"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename fapseudo.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'algoritmo accede (prima fase) alle varie liste in modalità 
\emph on
round robin
\emph default
 e colleziona in un insieme M gli oggetti che ho trovato in tutte le liste
 (ovvero gli oggetti per cui ho effettivamente tutti gli score parziali)
 e proseguo fintanto che l'insieme M non raggiunge cardinalità 
\emph on
k
\emph default
.
 Per questi oggetti 
\emph on
k
\emph default
 conosco effettivamente tutti i loro valori, ma non è detto che siano loro
 il risultato della mia top-k join query: infatti, per ogni oggetto (seconda
 fase) che ho incontrato almeno una volta, non presente in M, cioè per cui
 ho almeno un risultato parziale (ma non tutti i risultati parziali), trovo
 i rimanenti risultati parziali attraverso degli accessi casuali.
 Infine (terza fase) per ogni oggetto 
\emph on
o
\emph default
 di cui ho appena trovato tutti i risultati parziali, ne calcolo la 
\emph on
scoring function S
\emph default
 e infine restituisco i 
\emph on
k 
\emph default
oggetti con il risultato migliore.
\end_layout

\begin_layout Standard
Notiamo che la condizione di stop sugli accessi ordinati, non dipende in
 alcun modo dalla 
\emph on
scoring function
\emph default
 
\emph on
S 
\emph default
applicata, la quale entra in gioco solo al terzo passo: ovvero il numero
 degli accessi ordinati risulta sempre lo stesso al variare anche di S.
\end_layout

\begin_layout Standard
Vediamo come FA funziona applicandolo ad un esempio in cui 
\begin_inset Formula $k=1$
\end_inset

 (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:faexample01"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:faexample01"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename faexample01.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Applicando FA ai dati mostrati, dopo aver effettuato accessi ordinati otteniamo
 
\begin_inset Formula $M=\{o2\}$
\end_inset

 e 
\begin_inset Formula $Obj=\{o2,o3,o4,o7\}$
\end_inset

.
 Dopo aver effettuato gli accessi casuali necessari per avere i restanti
 risultati parziali otteniamo i seguenti risultati (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:faexample02"

\end_inset

), entrambi corretti.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:faexample02"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename faexample02.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Perchè l'algoritmo FA è corretto?
\end_layout

\begin_layout Standard
Vale il seguente teorema: L'algoritmo FA è corretto per qualsiasi 
\emph on
scoring function 
\emph default
S 
\emph on
monotona.
\end_layout

\begin_layout Standard
Dimostrazione: Sia 
\emph on
Res
\emph default
 l'insieme degli oggetti ritornati dall'algoritmo FA.
 È sufficiente mostrare che se 
\begin_inset Formula $o'\notin Obj$
\end_inset

 (ovvero all'insieme degli oggetti di cui conosco almeno un risultato parziale,
 ovvero 
\emph on
o' 
\emph default
è un oggetto che non ho mai incontrato), allora 
\emph on
o'
\emph default
 non può essere migliore di qualsiasi oggetto 
\begin_inset Formula $o\in Res$
\end_inset

.
 Indichiamo con 
\emph on
o 
\emph default
un qualsiasi oggetto in 
\emph on
Res
\emph default
.
 Allora, esiste almeno un oggetto 
\begin_inset Formula $o''\in M$
\end_inset

 (potrebbe coincidere con 
\emph on
o
\emph default
 stesso) tale che 
\begin_inset Formula $S(o)\geq S(o'')$
\end_inset

, altrimenti 
\emph on
o
\emph default
 non sarebbe in 
\emph on
Res
\emph default
.
 Siccome 
\begin_inset Formula $o'\notin Obj$
\end_inset

, per ogni 
\begin_inset Formula $L_{j}$
\end_inset

 accade che 
\begin_inset Formula $p_{j}(o')\leq p(o'')$
\end_inset

 (poichè o' non è stato mai incontrato) e dall'assunzione di monotonicità
 della 
\emph on
scoring function 
\emph default
S si ha che 
\begin_inset Formula $S(o')\leq S(o'')$
\end_inset

.
 Ne segue che 
\begin_inset Formula $S(o')\leq S(o)$
\end_inset

.
\end_layout

\begin_layout Standard
L'algoritmo, dunque, individua un sottoinsieme di oggetti che potrebbero
 risultare fra il risultato della query e si ferma quando questo sotto insieme
 riesce ad escludere tutti gli oggetti, non ancora visti, per il quale il
 risultato non può essere effettivamente migliorato.
 Utilizzando la seguente figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fagraphic"

\end_inset

), possiamo intuire graficamente che FA si ferma quando la regione colorata
 in grigio contiene almeno 
\emph on
k
\emph default
 punti, e data la monotonicità di S accade che ognuno di questi punti non
 può essere peggiore di punto all'interno della regione tratteggiata.
 L'algoritmo si ferma quando la cardinalità di M è maggiore o uguale a K,
 ed essendo la funzione monotona, ogni oggetti presente nell'area grigia
 ha un punteggio maggiore o uguale al vertice di intersezione con l'area
 tratteggiata, il quale avrà sicuramente un punteggio maggiore o uguale
 a tutti gli oggetti presenti nel rettangolo inesplorato (quello tratteggiato).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fagraphic"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename fagraphic.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vediamone ora le 
\emph on
performance.
 
\emph default
Quando le 
\emph on
sub-query 
\emph default
sono indipendenti (ovvero ogni 
\emph on
rank
\emph default
 locale è indipendente dall'altro) si può provare che il costo di FA (ovvero
 il numero di accessi ordinati e casuali) per un Database di N oggetti è,
 con grande probabilità, assumendo 
\emph on
m
\emph default
 costante
\begin_inset Formula 
\[
O\left(N^{\frac{m-1}{m}}\cdot k^{\frac{1}{m}}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
Siccome FA esegue gli accessi ordinati utilizzando una strategia 
\emph on
round robin
\emph default
, su ogni lista si arriva a profondità diciamo X.
 Non facendo alcuna ipotesi sull'ordinamento degli oggetti in ogni lista
 e supponendo che gli ordinamenti siano indipendenti da una lista all'altra,
 ci interessa sapere la cardinalità di M, ovvero 
\begin_inset Quotes eld
\end_inset

la cardinalità dell'intersezione di 
\emph on
m
\emph default
 sotto-insiemi casuali di cardinalità X
\begin_inset Quotes erd
\end_inset

.
 La probabilità che un oggetto 
\begin_inset Formula $o_{j}$
\end_inset

 appartenga a una lista 
\emph on
L 
\emph default
di N oggetti tra cui ne dobbiamo scegliere X è 
\begin_inset Formula $\frac{X}{N}$
\end_inset

.
 Essendo le probabilità indipendenti, la probabilità che un oggetto 
\begin_inset Formula $o_{j}$
\end_inset

 appartanga a tutte le 
\emph on
m
\emph default
 liste è 
\begin_inset Formula $\left(\frac{X}{N}\right)^{m}$
\end_inset

.
 Se moltiplichiamo questo risultato per il numero di oggetti 
\emph on
N
\emph default
 otteniamo il numero medio di oggetti presenti nell'insieme 
\emph on
M.

\emph default
 Dovendo eguagliare la dimensione di M a 
\emph on
k
\emph default
 (poichè è la condizione di stop) ottengo
\begin_inset Formula 
\[
k=N\cdot\left(\frac{X}{N}\right)^{m}\rightarrow\frac{k}{N}=\left(\frac{X}{N}\right)^{m}\rightarrow\left(\frac{k}{N}\right)^{\frac{1}{m}}=\frac{X}{N}
\]

\end_inset

 ovvero
\begin_inset Formula 
\[
X=N\cdot\left(\frac{k}{N}\right)^{\frac{1}{m}}=\left(\frac{N^{m}\cdot k}{N}\right)^{\frac{1}{m}}=N^{\frac{m-1}{m}}\cdot k^{\frac{1}{m}}
\]

\end_inset


\end_layout

\begin_layout Standard
Il risultato segue osservando che il numero di accessi ordinati è dato da
 
\begin_inset Formula $m\cdot X$
\end_inset

 e il numero di accessi casuali è al più 
\begin_inset Formula $(m\cdot X-m\cdot k)\cdot(m-1)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Il maggior inconveniente dell'algoritmo è che non sfrutta al massimo la
 specifica 
\emph on
scoring function S
\emph default
.
 In particolare poichè S è usata solo al terzo passo (quando vengono calcolati
 i punteggi globali), per un dato database il costo di accessi ordinati
 e casuali di FA è indipendente da S.
 In più, la memoria richiesta da FA potrebbe diventare proibitiva poichè
 FA richiede di bufferizzare tutti gli oggetti man mano che li incontra
 fra gli accessi ordinati.
 Alcuni miglioramenti sono possibili come ad esempio l'interleaving tra
 gli accessi casuali e il calcolo del punteggio che può far evitare alcuni
 accessi casuali stessi, ma il maggior miglioramento è possibile solo se
 si cambia la condizione di stop utilizzata: infatti FA utilizza una condizione
 di stop basata solo sui 
\emph on
ranking 
\emph default
locali degli oggetti.
 
\end_layout

\begin_layout Standard
Notiamo infine che se FA mantiene in buffer gli insiemi 
\emph on
M
\emph default
 e 
\emph on
Obj
\emph default
, si potrebbe cambiare al volo la funzione S e si riuscirebbe ad ottenere
 immediatamente il risultato, proprio perchè la funzione S viene applicata
 solo all'ultimo passo.
 
\end_layout

\begin_layout Subsubsection
Algoritmo TA
\end_layout

\begin_layout Standard
L'algoritmo TA (Threshold Algorithm) [FLN01, FLN03] differisce da FA in
 quanto alterna accessi ordinati e casuali e si basa su una regola di stop
 numerica.
 In particolare TA utilizza una 
\bar under
soglia 
\emph on
T
\emph default
 la quale fa da 
\emph on
upper bound 
\emph default
a tutti i punteggi degli oggetti non ancora visitati
\bar default
.
 Ricordiamo un concetto fondamentale: un valore 
\begin_inset Formula $\underline{p_{j}}$
\end_inset

 per una lista 
\begin_inset Formula $L_{j}$
\end_inset

 indica il peggior valore sulla lista finora incontrato.
 Nell'algoritmo viene introdotto il concetto di soglia 
\emph on
T
\emph default
 siffatta 
\begin_inset Formula $T=S(\underline{p_{1}},\underline{p_{2}},\ldots,\underline{p_{m}})$
\end_inset

 ovvero il valore della scoring function applicato al punto 
\begin_inset Quotes eld
\end_inset

virtuale
\begin_inset Quotes erd
\end_inset

 (non necessariamente appartanente al database) di coordinate 
\begin_inset Formula $(\underline{p_{1}},\underline{p_{2}},\ldots,\underline{p_{m}})$
\end_inset

 che ricordiamo essere gli ultimi valori incontrati su ogni lista 
\begin_inset Formula $L_{j}$
\end_inset

 durante gli accessi ordinati.
\end_layout

\begin_layout Paragraph
Algoritmo TA
\end_layout

\begin_layout Itemize

\series bold
Input
\series default
: Ranked List 
\begin_inset Formula $L_{j}$
\end_inset

 (
\begin_inset Formula $j=1,\ldots,m$
\end_inset

), un intero 
\begin_inset Formula $k\geq1$
\end_inset

, una 
\emph on
scoring function S monotona
\end_layout

\begin_layout Itemize

\series bold
Output
\series default
: i 
\emph on
top-k 
\emph default
oggetti in accordo a S
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-Codice Algoritmo TA
\begin_inset CommandInset label
LatexCommand label
name "fig:Pseudo-Codice-Algoritmo-TA"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename tapseudo.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'algoritmo inizializza tutti i 
\begin_inset Formula $\underline{p_{j}}$
\end_inset

 a 1 (se normalizzato) e il risultato 
\emph on
Res
\emph default
 con valori di score 0: man mano che incontra un nuovo oggetto in una delle
 liste 
\begin_inset Formula $L_{j}$
\end_inset

 calcola gli score parziali mancanti attraverso accessi casuali e controlla
 se il nuovo oggetto può modificare il risultato ovvero se il suo score
 è migliore dello score del 
\emph on
k
\emph default
-esimo oggetto in 
\emph on
Res.
 
\emph default
Quando lo score del 
\emph on
k-
\emph default
esimo oggetto in 
\emph on
Res 
\emph default
risulta maggiore del valore di soglia 
\emph on
T
\emph default
 l'algoritmo può fermarsi, poichè tutti gli oggetti successivi saranno,
 non ancora visti, data la monotonicità della scoring function S saranno
 non migliori della soglia 
\emph on
T 
\emph default
e quindi non migliori degli oggetti in 
\emph on
Res
\emph default
.
\end_layout

\begin_layout Standard
Perchè l'algoritmo TA è corretto?
\end_layout

\begin_layout Standard
Vale il seguente 
\emph on
teorema
\emph default
: L'algoritmo TA è corretto per qualsiasi 
\emph on
scoring
\emph default
 
\emph on
function
\emph default
 S 
\emph on
monotona
\emph default
.
\end_layout

\begin_layout Standard
Dimostrazione: Consideriamo un oggetto 
\emph on
o'
\emph default
 che non è stato visto da nessuna scansione ad accesso ordinato.
 Dunque per ogni 
\emph on
j 
\emph default
si ha 
\begin_inset Formula $p_{j}(o')\leq\underline{p_{j}}$
\end_inset

.
 Data la monotonicità di S, questo implica che 
\begin_inset Formula $S(o')\leq T$
\end_inset

.
 Per definizione di 
\emph on
Res
\emph default
 per ogni oggetto 
\begin_inset Formula $o\in Res$
\end_inset

 si ha 
\begin_inset Formula $S(o)\geq T$
\end_inset

, cioè 
\begin_inset Formula $S(o')\leq S(o)$
\end_inset

.
\end_layout

\begin_layout Standard
Utilizzando la seguente figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TAgraph"

\end_inset

), possiamo intuire graficamente che TA si ferma quando la regione colorata
 in grigio contiene almeno k punti buoni almeno quanto T, e data la monotonicità
 di S accade che nessun punto nella regione tratteggiata può essere migliore
 di T.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:TAgraph"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename TAgraph.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vediamo di seguito come TA lavora attraverso due esempi (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:taexample"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:taexample"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename TAexample.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
E vedamo di seguito anche un approccio geometrico all'algoritmo in cui si
 ha 
\begin_inset Formula $S\equiv SUM$
\end_inset

 e 
\begin_inset Formula $k=2$
\end_inset

 (Fig.
 ).
 Come si vede dalla figura, quando si arriva a trovare l'oggetto o1 ci si
 ferma.
 Si noti che 
\begin_inset Formula $S(o3)>S(o1)\geq T$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:tageometricview"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename tageometricview.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In generale TA funziona molto meglio di FA poichè riesce ad 
\begin_inset Quotes eld
\end_inset

adattarsi
\begin_inset Quotes erd
\end_inset

 alla specifica 
\emph on
scoring function S
\emph default
.
 Sicuramente è più efficiente dell'algoritmo FA poichè la condizione di
 stop di FA implica quella di TA, ovvero se la condizione di stop di FA
 risulta vera allora ancora la condizione di stop di TA è vera.
\end_layout

\begin_layout Standard
Per riuscire a caratterizzare le performace di TA dobbiamo considerare il
 cosiddetto costo 
\begin_inset Quotes eld
\end_inset

middleware
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Formula $cost=SA\cdot c_{SA}+RA\cdot c_{RA}$
\end_inset

 dove:
\end_layout

\begin_layout Itemize
SA (RA) è il numero totale di accessi ordinati (casuali)
\end_layout

\begin_layout Itemize
\begin_inset Formula $c_{SA}$
\end_inset

 (
\begin_inset Formula $c_{RA}$
\end_inset

) è il costo unitario (base) di ogni accesso ordinato (casuale).
\end_layout

\begin_layout Standard
e dunque il costo è dato dalla somma degli accessi ordinati e casuali moltiplica
to per il costo unitario rispettivo.
\end_layout

\begin_layout Standard
Nelle impostazioni base si ha che 
\begin_inset Formula $c_{SA}=c_{RA}$
\end_inset

(
\begin_inset Formula $=1$
\end_inset

 per semplicità).
 In altri casi il costo base potrebbe differire, ad esempio per risorse
 web solitamente si ha 
\begin_inset Formula $c_{RA}\gg c_{SA}$
\end_inset

, fino al limite in cui 
\begin_inset Formula $c_{RA}=\infty$
\end_inset

 nei cui casi gli accessi casuali sono impossibili.
 In maniera opposta, alcune risorse potrebbero non supportare l'accesso
 ordinato nei cui casi si ha 
\begin_inset Formula $c_{SA}=\infty$
\end_inset

, ad esempio per istanze in cui non abbiamo un indice per eseguire 
\begin_inset Formula $p_{j}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Un concetto fondamentale necessario per capire in che senso TA 
\begin_inset Quotes eld
\end_inset

funziona bene
\begin_inset Quotes erd
\end_inset

 è il concetto di 
\emph on
ottimalità d'istanza.
\end_layout

\begin_layout Standard
Per introdurre il concetto facciamo un esempio: immaginiamo di avere un
 array ordinato di N elementi a cui vogliamo applicare la ricerca.
 Come ben noto le ricerca binaria ha costo nel caso medio e costo nel caso
 peggiore uguale a 
\begin_inset Formula $\lg_{2}N$
\end_inset

 , mentre la ricerca sequenziale nel caso medio ha costo 
\begin_inset Formula $\frac{N}{2}$
\end_inset

 e le caso peggiore 
\begin_inset Formula $N$
\end_inset

.
 Supponiamo di voler mettere a confronto i due algoritmi per ogni istanza
 del problema, ovvero quando si cerca il primo elemento, il secondo elemento,
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

, e l'ultimo elemento.
 Indicando con la coppia (X,Y) i costi della ricerca binaria (X) e ricerca
 sequenziale (Y) vediamo cosa accade:
\end_layout

\begin_layout Enumerate
Si cerca il primo elemento.
 Costi 
\begin_inset Formula $(\log_{2}N,1)$
\end_inset


\end_layout

\begin_layout Enumerate
Si cerca il secondo elemento.
 Costi 
\begin_inset Formula $(\log_{2}N,2)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Si cerca l'N-1-esimo elemento.
 Costi 
\begin_inset Formula $(\log_{2}N,N-1)$
\end_inset


\end_layout

\begin_layout Enumerate
Si cerca l'N-esimo elemento.
 Costi 
\begin_inset Formula $(\log_{2}N,N)$
\end_inset


\end_layout

\begin_layout Standard
All'aumentare di N (
\begin_inset Formula $N\rightarrow\infty$
\end_inset

) il rapporto fra 
\begin_inset Formula $\log_{2}N$
\end_inset

 e 1 (i costi della prima istanza) tende ad infinito, ovvero la ricerca
 binaria non è 
\emph on
ottimale per le istanze, 
\emph default
ovvero esistono istanze in cui la ricerca sequenziale non è 
\begin_inset Quotes eld
\end_inset

migliore
\begin_inset Quotes erd
\end_inset

 della ricerca sequenziale, dove per 
\begin_inset Quotes eld
\end_inset

migliore
\begin_inset Quotes erd
\end_inset

 significa il cui rapporto non tende a infinito.
\end_layout

\begin_layout Standard
Data una classe di algoritmi 
\series bold
A 
\series default
e una classe 
\series bold
D 
\series default
di database (ovvero gli input degli algoritmi), un algoritmo 
\begin_inset Formula $A'\in A$
\end_inset

 è 
\emph on
ottimo per le istanze 
\emph default
su 
\series bold
A 
\series default
e 
\series bold
D
\series default
 per un dato costo misurato, se per ogni 
\begin_inset Formula $B\in A$
\end_inset

 e ogni 
\begin_inset Formula $DB\in D$
\end_inset

 si ha
\begin_inset Formula 
\[
cost(A',DB)=O(cost(B,DB))
\]

\end_inset


\end_layout

\begin_layout Standard
Ciò è equivalente a dire che esistono due costanti 
\emph on
c 
\emph default
e 
\emph on
c' 
\emph default
tale che
\begin_inset Formula 
\[
cost(A',DB)\leq c\cdot cost(B,DB)+c'
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Se A è 
\emph on
ottimale per le istante
\emph default
, allora qualsiasi algoritmo può essere migliore di A per solo un fattore
 costante 
\emph on
c
\emph default
, il quale viene chiamato il 
\emph on
rapporto ottimale 
\emph default
di A.
\end_layout

\begin_layout Standard
Osserviamo che 
\emph on
l'ottimalità d'istanza 
\emph default
è una nozione molto più forte di ottimalità di caso peggiore o migliore
 (ad esempio la ricerca binaria è ottima nel caso peggiore, ma non è ottima
 per le istanze).
\end_layout

\begin_layout Standard
TA è 
\emph on
ottimale per le istanze 
\emph default
su tutti i Database e su tutti gli algoritmi che non facciano 
\begin_inset Quotes eld
\end_inset

scelte casuali
\begin_inset Quotes erd
\end_inset

, e il suo 
\emph on
rapporto ottimale
\emph default
 è 
\emph on
m 
\emph default
quando 
\begin_inset Formula $c_{RA}=0$
\end_inset

 (ovvero TA è ottimale per le istanze se consideriamo solo gli accessi ordinati).
 Un algoritmo A fa scelte casuali se effettua un accesso casuale all'oggetto
 
\emph on
o
\emph default
 senza aver mai visto prima l'oggetto attraverso un accesso ordinato.
 Si noti che questo tipi di algoritmi 
\begin_inset Quotes eld
\end_inset

jolly
\begin_inset Quotes erd
\end_inset

 sono d'interesse solo dal punto di visto teorico.
\end_layout

\begin_layout Standard
Dimostrazione: Assumiamo che TA si fermi dopo aver eseguito X round di accessi
 ordinati (alla 
\begin_inset Quotes eld
\end_inset

profondità X
\begin_inset Quotes erd
\end_inset

), cioè ha eseguito 
\begin_inset Formula $m\cdot X$
\end_inset

 accessi ordinati.
 Consideriamo un qualsiasi algoritmo 
\emph on
corretto
\emph default
 B e assumiamo che su ogni lista B esegue un numero di accessi ordinati
 sulla lista 
\begin_inset Formula $L_{j}$
\end_inset

 in numero pari alla profondità, indicata con 
\begin_inset Formula $Depth(B,j)$
\end_inset

, che raggiunge sulla lista j.
 Indicando con 
\begin_inset Formula $MaxDepth(B)=max_{j}\{Depth(B,j)\}$
\end_inset

 ovvero la massima profondità che raggiunge su una lista, se 
\begin_inset Formula $MaxDepth(B)\geq X$
\end_inset

 abbiamo allora concluso, in quanto TA risulta migliore di B effettuando
 un numero minore di accessi ordinati.
 Se invece B effettua un numero strettamente minore di X di accessi ordinati
 su ogni lista 
\begin_inset Formula $L_{j}$
\end_inset

, cioè sulla lista 
\begin_inset Formula $L_{j}$
\end_inset

 si raggiunge la profondità 
\begin_inset Formula $Depth(B,j)<X$
\end_inset

 e di conseguenza 
\begin_inset Formula $MaxDepth(B)=max_{j}\{Depth(B,j)\}<X$
\end_inset

 ovvero l'altezza massima di B è strettamente minore all'altezza massima
 trovata in TA bisogna dimostrare che B non è 
\emph on
corretto
\emph default
.
 Consideriamo ora l'esecuzione di TA per 
\begin_inset Formula $MaxDepth(B)$
\end_inset

 round.
 Poichè i round includono tutti gli accessi ordinati (e i corrispondenti
 accessi casuali) fatti da B, e B è corretto per ipotesi, allora TA potrebbe
 fermarsi all'altezza 
\begin_inset Formula $MaxDepth(B)<X$
\end_inset

, una contradizione: ovvero siccome l'esecuzione di TA per 
\begin_inset Formula $MaxDepth(B)$
\end_inset

 effettua tanti accessi almeno quanti ne ha fatti l'algoritmo B (poichè
 B su ogni lista potrebbe avere profondità diverse, invece TA ogni lista
 ha stessa profondità poichè utilizza una tecnica 
\emph on
round robin
\emph default
) allora TA potrebbe fermarsi a 
\begin_inset Formula $MaxDepth(B)$
\end_inset

 invece che scendere in profondità fino a X, poichè se B è corretto per
 ipotesi, e sappiamo che TA lo è, allora il risultato di B deve coincidere
 con quello di TA, ma TA si è dovuta fermare a profondità X per riuscire
 a trovare il risultato (non poteva fermarsi prima, altrimenti lo avrebbe
 fatto), dunque B è un algoritmo non corretto.
 Ne segue che ogni algoritmo corretto B deve avere 
\begin_inset Formula $MaxDepth(B)\geq X$
\end_inset

 e quindi il suo costo deve essere maggiore o uguale a X, cioè per ogni
 Database si ha
\begin_inset Formula 
\[
cost(TA,DB)=m\cdot X\leq m\cdot cost(B,DB)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Quando 
\begin_inset Formula $c_{RA}>0$
\end_inset

 (caso reale, ricordiamo che finora avevamo assunto 
\begin_inset Formula $c_{RA}=0$
\end_inset

 per anche la dimostrazione di ottimalità) il costo d'arresto di TA è al
 massimo
\begin_inset Formula 
\[
cost(TA,DB)=m\cdot X\cdot c_{SA}+m\cdot X\cdot(m-1)\cdot c_{RA}
\]

\end_inset

 poichè nel caso peggiore TA ritrova 
\begin_inset Formula $m\cdot X$
\end_inset

 oggetti distinti, e per ognuon di essi esegue 
\begin_inset Formula $m-1$
\end_inset

 acessi casuali.
\end_layout

\begin_layout Standard
Come abbiamo visto, ogni altro algoritmo B dovrà pagare almeno un costo
 di 
\begin_inset Formula 
\[
cost(B,DB)\geq X\cdot c_{SA}
\]

\end_inset


\end_layout

\begin_layout Standard
Dunque, il 
\emph on
rapporto ottimale 
\emph default
divinete ora
\begin_inset Formula 
\[
\frac{m\cdot X\cdot c_{SA}+m\cdot(m-1)\cdot X\cdot c_{RA}}{X\cdot c_{SA}}=m+m\cdot(m-1)\cdot\frac{c_{RA}}{c_{SA}}
\]

\end_inset


\end_layout

\begin_layout Standard
il quale diventa abbastanza pessimo quando 
\begin_inset Formula $c_{RA}>(\gg)c_{SA}$
\end_inset

 poichè il costo degli accessi casuali prevale: ad esempio con 
\begin_inset Formula $\frac{c_{RA}}{c_{SA}}=10$
\end_inset

 e 
\begin_inset Formula $m=3$
\end_inset

 il 
\emph on
rapporto ottimale 
\emph default
è 63.
\end_layout

\begin_layout Subsubsection
Algoritmo NRA
\end_layout

\begin_layout Standard
L'algoritmo 
\emph on
NRA
\emph default
 (No Random Access Algorithm) [FLN01, FLN03] è un algoritmo applicabile
 quando non è possibile eseguire accessi casuali (o se il loro costo è proibitiv
o).
 L'algoritmo ritorna i 
\emph on
top-k 
\emph default
oggetti, ma il loro punteggio potrebbe essere sbagliato, questo per limitare
 il costo dell'algoritmo stesso.
 L'idea dietro NRA è di mantenere per ogni oggetto 
\emph on
o
\emph default
 incontrato durante un accesso ordinato, un 
\emph on
lower bound 
\emph default
(
\emph on
lbscore
\emph default
) 
\begin_inset Formula $S^{-}(o)$
\end_inset

 e un 
\emph on
upper bound
\emph default
 (
\emph on
upscore
\emph default
) 
\begin_inset Formula $S^{+}(o)$
\end_inset

 sul loro punteggio.
\end_layout

\begin_layout Itemize
\begin_inset Formula $S^{-}(o)$
\end_inset

 (da ora in poi 
\begin_inset Formula $S-(o)$
\end_inset

 per semplicità) è ottenuto imponendo 
\begin_inset Formula $p_{j}(o)=0$
\end_inset

 (o il minimo valore possibile di 
\begin_inset Formula $p_{j}$
\end_inset

) se l'oggetto 
\emph on
o
\emph default
 non è stato visto sull'input 
\begin_inset Formula $L_{j}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S^{+}(o)$
\end_inset

 (da ora in poi 
\begin_inset Formula $S+(o)$
\end_inset

 per semplicità) è ottenuto imponendo 
\begin_inset Formula $p_{j}(o)=\underline{p_{j}}$
\end_inset

 se l'oggetto 
\emph on
o 
\emph default
non è stato visto sull'input 
\begin_inset Formula $L_{j}$
\end_inset


\end_layout

\begin_layout Standard
NRA usa un buffer 
\emph on
B 
\emph default
di capacità illimitata, il quale è mantenuto ordinato secondo valori 
\emph on
decrescenti 
\emph default
di 
\emph on
lbscore
\emph default
.
 Si veda la figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:NRAexample"

\end_inset

), in cui 
\begin_inset Formula $S\equiv SUM$
\end_inset

 per una maggiore comprensione.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:NRAexample"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename nraexample0.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vediamo dunque l'algoritmo NRA.
 Chiamiamo 
\emph on
Res
\emph default
 le prime 
\emph on
k 
\emph default
posizioni del buffer 
\emph on
B
\emph default
, cioè 
\begin_inset Formula $Res=\{B[1],B[2],\ldots,B[k]\}$
\end_inset

.
 L'idea dell'algoritmo è di fermarsi quando nessun oggetto 
\begin_inset Formula $o'\notin Res$
\end_inset

 può essere 
\begin_inset Quotes eld
\end_inset

migliore
\begin_inset Quotes erd
\end_inset

 di qualsiasi oggetto appartenente a Res, cioè quando
\begin_inset Formula 
\[
S^{+}(o')\le S^{-}(o)\,\forall o'\notin Res,\, o\in Res
\]

\end_inset

 ovvero quando l'upper bound di un oggetto non presente nel risultato risulta
 minore o uguale al lower bound del 
\emph on
k-
\emph default
esimo oggetto in Res (poichè Res è ordinata per lower bound non crescenti).
 L'idea, in pratica, è di fermare l'algoritmo quando nessun oggetto che
 non è tra i primi 
\emph on
k-
\emph default
oggetti (quindi quelli appartenenti a Res) possa modificarmi il risultato
 Res.
\end_layout

\begin_layout Standard
Per verificare questa condizione è sufficiente considerare il massimo valore
 di 
\begin_inset Formula $S+(o')$
\end_inset

 fra gli oggetti in 
\begin_inset Formula $B-Res$
\end_inset

 (gli oggetti che sono nel buffer ma non in Res) e la soglia, la quale fornisce
 un limite superiore agli oggetti non ancora incontrati.
\end_layout

\begin_layout Paragraph
Algoritmo NRA
\end_layout

\begin_layout Itemize

\series bold
Input
\series default
: Ranked List 
\begin_inset Formula $L_{j}$
\end_inset

 (
\begin_inset Formula $j=1,\ldots,m$
\end_inset

), un intero 
\begin_inset Formula $k\geq1$
\end_inset

, una 
\emph on
function score S monotona
\end_layout

\begin_layout Itemize

\series bold
Output
\series default
: I 
\emph on
top-k 
\emph default
oggetti in accordo a S
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-Codice Algoritmo NRA
\begin_inset CommandInset label
LatexCommand label
name "fig:Pseudo-Codice-Algoritmo-NRA"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename nrapseudo.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
E vediamo subito due un esempio (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:nraexample02"

\end_inset

) in cui 
\begin_inset Formula $S\equiv SUM$
\end_inset

 e 
\begin_inset Formula $k=2$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:nraexample02"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename nraexample02.png
	scale 60

\end_inset


\end_layout

\end_inset

Un interessante osservazione riguardo NRA è che il suo costo non cresce
 monotonicamente con 
\emph on
k
\emph default
, cioè potrebbe richiedere un costo inferiore per i 
\emph on
top-k 
\emph default
oggetti rispetto che ai 
\emph on
top-
\emph default
(
\emph on
k-1
\emph default
)
\emph on
.
\end_layout

\begin_layout Standard
Si veda il seguente esempio (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:nraexample03"

\end_inset

) in cui 
\begin_inset Formula $S\equiv SUM$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:nraexample03"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename nraexample03.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In caso si abbia 
\begin_inset Formula $k=1$
\end_inset

 il vincitore è o2 (
\begin_inset Formula $S(o2)=1.2$
\end_inset

), poichè il punteggio di o1 è 
\begin_inset Formula $S(o1)=1.0$
\end_inset

 e il punteggio di tutti gli altri oggetti è 0.6.
 In questo caso NRA deve raggiungere la profondità 
\begin_inset Formula $N-1$
\end_inset

 per potersi fermare.
 Nel caso invece di 
\begin_inset Formula $k=2$
\end_inset

 per trovare i 
\emph on
top-2 
\emph default
oggetti che sono o1 e o2 sono sufficienti solo 3 rounds.
\end_layout

\begin_layout Standard
Per quanto riguarda l'
\emph on
ottimalità per le istanze
\emph default
, si può dimostrare che 
\emph on
NRA
\emph default
 è 
\emph on
ottimo per le istanze 
\emph default
su tutti i Database e su tutti gli algoritmi che non eseguono accessi casuali,
 e il suo 
\emph on
rapporto di ottimalità 
\emph default
è 
\emph on
m
\emph default
 (cioè se NRA si ferma a profondità X, allora qualsiasi altro algoritmo
 B deve leggere X oggetti da almeno una lista).
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Se risulta necessario avere i punteggi 
\emph on
esatti
\emph default
 dei top-k oggetti, allora l'algoritmo, che viene chiamato 
\emph on
NRA*
\emph default
, lavora come di seguito:
\end_layout

\begin_layout Enumerate
Esegui l'algoritmo 
\emph on
NRA 
\emph default
fino a che i 
\emph on
top-k
\emph default
 non sono determinati (ovvero 
\emph on
Res
\emph default
 è stabile)
\end_layout

\begin_layout Enumerate
Esegui tanti accessi ordinati quanti necessari fino a trovare tutti i punteggi
 parziali per gli oggetti che sono stati trovati in 
\emph on
Res
\end_layout

\begin_layout Standard
Si noti che l'algoritmo NRA* esegue almeno tanti round di accessi ordinati
 quanti l'algoritmo FA (possibilmente anche di più), infatti FA si ferma
 a profondità X dopo aver visto 
\emph on
k
\emph default
 oggetti in tutte le liste (gli oggetti che stanno in M), mentre NRA* non
 può fermarsi a profondità 
\begin_inset Formula $<X$
\end_inset

 poichè per almeno un oggetto in 
\emph on
Res
\emph default
 non si conosce il punteggio esatto, inoltre non vi è alcuna garanzia che
 gli oggetti in M siano anche in 
\emph on
Res.
\end_layout

\begin_layout Standard
Si può facilmente dimostrare che NRA* è 
\emph on
ottimale per le istanze 
\emph default
su tutti i Database e su tutti gli algoritmi che calcolano il punteggio
 esatto e non eseguono accessi casuali, e il suo 
\emph on
rapporto di ottimalità 
\emph default
risulta 
\emph on
m
\emph default
.
\end_layout

\begin_layout Subsubsection
Algoritmo CA
\end_layout

\begin_layout Standard
L'algoritmo 
\emph on
CA 
\emph default
(Combine Algoithm) [FLN01, FLN03] è un tentativo di ridurre l'influenza
 negativa degli alti costi degli accessi casuali.
 L'idea dietro CA è semplice: piuttosto che eseguire accessi casuali ad
 ogni round, vengono esguiti ogni 
\begin_inset Formula $\frac{c_{RA}}{c_{SA}}$
\end_inset

 round (più precisamente ogni 
\begin_inset Formula $\left\lfloor \frac{c_{RA}}{c_{SA}}\right\rfloor $
\end_inset

).
 In pratica CA si comporta come NRA, e come NRA mantiene 
\emph on
lower 
\emph default
e 
\emph on
upper bound
\emph default
 sui punteggi degli oggetti, ma ogni 
\begin_inset Formula $\left\lfloor \frac{c_{RA}}{c_{SA}}\right\rfloor $
\end_inset

 round di accessi ordinati esegue un accesso casuale.
 Il punto chiave è capire per quali oggetti bisogna richiedere un accesso
 casuale.
 Non sorprende che questi oggetti siano gli oggetti 
\emph on
o 
\emph default
per i quali mancano alcuni risultati parziali e per i quali 
\begin_inset Formula $S^{+}(o)$
\end_inset

 è massima (poichè per il solito concetto, se lo facessi per un altro oggetto
 questo non escluderebbe il dover eseguire successivamente il calcolo per
 l'oggetto con upper bound massimo).
\end_layout

\begin_layout Standard
Comparando CA all'algoritmo TA, CA esegui più accessi ordinati ma meno accessi
 casuali.
 Si può provare che CA è 
\emph on
ottimale per le istanze
\emph default
 con un 
\emph on
rapporto di ottimalità 
\emph default
indipendente da 
\begin_inset Formula $\frac{c_{RA}}{c_{SA}}$
\end_inset

 ma solo se
\end_layout

\begin_layout Enumerate
su ogni lista i punteggi sono tutti distinti (ovvero non ci sono casi di
 parità su 
\begin_inset Formula $p_{j}$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $S\equiv MIN$
\end_inset

 o 
\emph on
S
\emph default
 è 
\emph on
strettamente
\emph default
 monotona per ogni argomento: ogni volta che 
\begin_inset Formula $p_{j}$
\end_inset

 è incrementato e gli altri argomenti rimangono invariati, allora anche
 il valore di S si incrementa (ad esempio per scoring function SUM questo
 accade).
\end_layout

\begin_layout Subsubsection
Riassunto
\end_layout

\begin_layout Standard
Si veda la seguente tabella (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:topksummary"

\end_inset

) per avere una visione generale di tutti gli algoritmi che si possono utilizzar
e per risolvere una 
\emph on
top-k join 
\emph default
1:1 
\emph on
query.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:topksummary"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename topksummary.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esistono molti altri algoritmi per calcolare una 
\emph on
top-k join 
\emph default
1:1 
\emph on
query
\emph default
, ed ognuno di questi si basa sull'assunzione che la 
\emph on
scoring function S
\emph default
 sia 
\emph on
monotona.
 
\emph default
Il caso più semplice si ha quando 
\begin_inset Formula $S\equiv MAX$
\end_inset

: l'algoritmo base 
\begin_inset Formula $B_{0}$
\end_inset

 di Fagin può esere migliorato (
\emph on
MaxOptimal
\emph default
) sfruttando principi simili a quelli applicati per la ricerca k-NN.
 L'algoritmo FA è l'unico la cui condizione di stop considera semplicemente
 il 
\emph on
ranking
\emph default
 locale degli oggetti piuttosto che il loro punteggio parziale.
 La condizione di stop di TA si basa su una soglia T la quale fornisce un
 
\emph on
upper bound
\emph default
 ai punteggi di tutti gli oggetti non incontrati.
 TA è 
\emph on
ottimale per le istanze
\emph default
 anche se il suo 
\emph on
rapporto di ottimalità 
\emph default
dipende da 
\begin_inset Formula $\frac{c_{RA}}{c_{SA}}$
\end_inset

, ovvero il rapporto tra il costo di accesso casuale e il costo di accesso
 ordinato.
 L'algoritmo NRA invece non esegue alcun accesso casuale.
 Infine l'algoritmo CA è una combinazione di TA e NRA, risulta essere 
\emph on
ottimale per le istanze 
\emph default
con un 
\emph on
rapporto di ottimalità 
\emph default
indipendente da 
\begin_inset Formula $\frac{c_{RA}}{c_{SA}}$
\end_inset

 solo per un sotto insieme di 
\emph on
scoring function 
\emph default
S e un sottoinsieme di Database.
\end_layout

\begin_layout Subsection
Top-k Join Queries
\end_layout

\begin_layout Standard
Il caso generale di una 
\emph on
top-k join queries 
\emph default
in cui abbiamo 
\begin_inset Formula $n>1$
\end_inset

 relazioni di input e una 
\emph on
scoring function S
\emph default
 definita sul risultato di join può essere espressa dalla seguente semantica
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT <some attributes>
\end_layout

\begin_layout Plain Layout

FROM R1, R2, ..., Rn
\end_layout

\begin_layout Plain Layout

WHERE <join and local conditions>
\end_layout

\begin_layout Plain Layout

ORDER BY S(p1,p2,...,pm) [Desc]
\end_layout

\begin_layout Plain Layout

STOP AFTER k
\end_layout

\end_inset


\end_layout

\begin_layout Standard
dove p1,p2,...,pm sono i criteri di 
\emph on
score
\emph default
 (le nostre 
\begin_inset Quotes eld
\end_inset

preferenze
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
Consideriamo ora il caso generale in cui il 
\emph on
join
\emph default
 avviene 
\emph on
molti a molti
\emph default
, ovvero un join M:N, come ad esempio
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM RESTAURANTS AS R, HOTELS AS H
\end_layout

\begin_layout Plain Layout

WHERE R.City=H.City
\end_layout

\begin_layout Plain Layout

	AND R.Nation='Italy'
\end_layout

\begin_layout Plain Layout

	AND H.Nation='Italy'
\end_layout

\begin_layout Plain Layout

ORDER BY R.Price+H.Price
\end_layout

\begin_layout Plain Layout

STOP AFTER 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notiamo che il join non avviene più sugli attributi chiave delle relazioni.
\end_layout

\begin_layout Standard
Vediamo in figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:topkgeneralcase"

\end_inset

) l'esempio della query appena scritta applicata a dei dati, in cui 
\begin_inset Formula $k=5$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:topkgeneralcase"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename topkgeneralcase.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nei casi più favorevoli possiamo accedere a tutti gli input utilizzando
 
\emph on
indici
\emph default
 sugli attributi di join (ad esempio su 
\emph on
city
\emph default
).
\end_layout

\begin_layout Standard
In questo caso l'algoritmo risultante è molto simile all'algoritmo TA:
\end_layout

\begin_layout Enumerate
Esegui un round di accessi ordinati
\end_layout

\begin_layout Enumerate
Per ogni tupla recuperata:
\end_layout

\begin_deeper
\begin_layout Enumerate
usando l'indice sugli attributi di join, effettua un accesso casuale per
 ritrovare tutti i match sui restanti input
\end_layout

\begin_layout Enumerate
mantieni solo i migliori 
\emph on
k
\emph default
 risultati tra le combinazioni di join
\end_layout

\begin_layout Enumerate
se uno queste nuove combinazioni di join è fra le combinazioni 
\emph on
top-k 
\emph default
viste finora allora tienila, altrimenti scartala
\end_layout

\end_deeper
\begin_layout Enumerate
Ripeti il passo 1 fintanto che la condizione di soglia non è verificata
 (cioè quando nessuna combinazione di join non ancora vista può essere migliore
 dell'attuale risultato 
\emph on
top-k
\emph default
).
 La soglia 
\emph on
T
\emph default
 viene identificata alla stessa modo dell'algoritmo TA.
\end_layout

\begin_layout Standard
Vediamo dunque un esempio in cui l'algoritmo viene applicato (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:topkgeneralcase02"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:topkgeneralcase02"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename topkgeneralcase02.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subsubsection
Algoritmo Rank-Join
\end_layout

\begin_layout Standard
In caso invece non siano presenti indici sugli attributi di join, l'unica
 alternativa è di calcolare il risultato utilizzando solo gli accessi ordinati,
 sulla scia dell'algoritmo di NRA*.
\end_layout

\begin_layout Standard
L'algoritmo base per questo scenario è chiamato 
\emph on
Rank-Join
\emph default
 [IAE03], e la sua descrizione richiedere di aggiungere alcune notazioni:
\end_layout

\begin_layout Itemize
Per ogni ranked list 
\begin_inset Formula $L_{j}$
\end_inset

, indichiamo con 
\begin_inset Formula $pj^{max}$
\end_inset

il primo (più alto) punteggio visto su 
\begin_inset Formula $L_{j}$
\end_inset


\end_layout

\begin_layout Itemize
Indichiamo con 
\emph on
T 
\emph default
il massimo fra i seguenti 
\emph on
m 
\emph default
valori
\begin_inset Formula 
\[
S(\underline{p1},p2^{max},\ldots,pm^{max}),\, S(p1^{max},\underline{p2},\ldots,pm^{max}),\,\ldots,\, S(p1^{max},p2^{max},\ldots,\underline{pm})
\]

\end_inset

 il quale viene anche chiamato il 
\emph on
corner bound.
 
\emph default
Si noti il significato di un singolo termine: si calcola per ogni coordinata
 la scoring function utilizzando il valore più basso incontrato sulla coordinata
 insieme ai valori massimi di tutte le altre.
\end_layout

\begin_layout Itemize
Indichiamo con 
\emph on
j 
\emph default
una generica combinazione di join,cioè 
\begin_inset Formula $j=(t1,t2,\ldots,tm)$
\end_inset


\end_layout

\begin_layout Standard
L'osservazione ovvia è che ci si può fermare quando ci sono 
\emph on
k
\emph default
 combinazioni di join 
\emph on
j 
\emph default
tali che 
\begin_inset Formula $S(j)\geq T$
\end_inset

.
 Gli accessi ordinati possono essere eseguiti seguendo una strategia 
\emph on
round-robin
\emph default
 oppure accedendo alla lista per cui si ha 
\begin_inset Formula $\underline{pj}$
\end_inset

 massimo.
\end_layout

\begin_layout Standard
Tentiamo di visualizzare il 
\emph on
corner bound
\emph default
 in uno spazio grafico.
 Per semplicità assumiamo che 
\begin_inset Formula $p1^{max}=p2^{max}=1$
\end_inset

 e che 
\begin_inset Formula $S\equiv SUM$
\end_inset

.
 Nella figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rankjoingraphic"

\end_inset

) si ha che 
\begin_inset Formula $\underline{p1}=0.4$
\end_inset

 e 
\begin_inset Formula $\underline{p2}=0.6$
\end_inset

 e dunque 
\begin_inset Formula $T=max\{(0.4+1),(1+0.6)\}=1.6$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rankjoingraphic"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename rankjoingraphic.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il 
\emph on
Rank-join
\emph default
 si ferma quando l'attuale risultato 
\emph on
top-k
\emph default
 giace sulla regione delimitata da 
\emph on
T
\emph default
.
 Nessuna combinazione di join può avere un punteggio migliore di 
\emph on
T
\emph default
, poichè nel miglior caso una tupla non incontrata su L2 farà il match con
 una tupla di L1 con punteggio uguale a 1.
\end_layout

\begin_layout Standard
Quando 
\begin_inset Formula $m=2$
\end_inset

 (il numero di predicati di join) si può provare che il 
\emph on
Rank-join 
\emph default
è 
\emph on
ottimo per le istanze
\emph default
, cioè il 
\emph on
corner bound 
\emph default
è stretto (potrebbe esserci una combinazione di join 
\emph on
j 
\emph default
tale che 
\begin_inset Formula $S(j)=T$
\end_inset

).
 D'altro canto quando 
\begin_inset Formula $m>2$
\end_inset

 l'analisi diventa molto più complessa, e l'
\emph on
ottimalità per le istanze
\emph default
 è garantita solo se le condizioni di join sono considerate come una 
\begin_inset Quotes eld
\end_inset

black box
\begin_inset Quotes erd
\end_inset

, cioè gli argomenti per dimostare l'
\emph on
ottimalità di istanze
\emph default
 non considerano le vere condizioni di join.
 Quando, invece, i predicati di join sono presi effettivamente in considerazione
, nessun algoritmo basato sul 
\emph on
corner bound
\emph default
 è 
\emph on
ottimale per le istanze
\emph default
 [SP08].
 Lo stesso risultato negativo lo si ottiene anche se gli input 
\begin_inset Formula $n$
\end_inset

 sono solamente due ma in cui almeno uno degli input ha 2 risultati parziali
 per ogni tupla (ovvero 
\begin_inset Formula $n<m$
\end_inset

).
\end_layout

\begin_layout Standard
Vediamo un esempio di non ottimalità del 
\emph on
Rank-Join
\emph default
.
\end_layout

\begin_layout Standard
Prendiamo la seguente query
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM R1, R2, R3
\end_layout

\begin_layout Plain Layout

WHERE R1.A=R2.A AND R1.A=R3.A
\end_layout

\begin_layout Plain Layout

ORDER BY p1+p2+p3 DESC
\end_layout

\begin_layout Plain Layout

STOP AFTER 1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in cui abbiamo 
\begin_inset Formula $S\equiv SUM$
\end_inset

.
 Il risultato è dato dalla seguente figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rankjoinexample"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rankjoinexample"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename rankjoinexample.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dopo i primi 3 round di accessi ordinati, il 
\emph on
corner bound 
\emph default
prodotto 
\begin_inset Formula $T=0.9+1+1=2.9$
\end_inset

.
 Tutta via, le tuple non incontrate da L1 possono portare a una combinazione
 di join 
\emph on
j 
\emph default
con 
\begin_inset Formula $S(j)>2.5$
\end_inset

, cioè potremmo fermarci qui, con solo 9 accessi ordinati.
\end_layout

\begin_layout Standard
D'altro canto, su questa istanza il 
\emph on
Rank-Join 
\emph default
potrebbe incorrere in un costo arbitrariamente alto, dipende da come sono
 distribuiti i punteggi.
 Si noti che il numero di tuple in L1 fra 
\begin_inset Formula $(x,0.9)$
\end_inset

 e 
\begin_inset Formula $(w,0.5)$
\end_inset

 non è limitato.
\end_layout

\begin_layout Standard
Oltre che mostrare i limiti e le mancanze del 
\emph on
Rank-Join
\emph default
, [SP08] ha inoltre introdotto uno schema di 
\emph on
bounding
\emph default
 più stretto che garantisce l'
\emph on
ottimalità per le istanze
\emph default
.
 Il metodo, qui non descritto, ha come maggiori caratteristiche di avere
 
\emph on
complessità polinomiale
\emph default
 sui dati, ovvero di funzionare in tempo polinomiale sul numero delle tuple
 trovate dalle 
\emph on
ranked list
\emph default
.
 È però un problema NP-hard se si considera la complessità della query,
 ovvero il suo tempo di calcolo cresce esponenzialmente con il numero di
 input.
 È interessante notare che si basa sul concetto di 
\begin_inset Quotes eld
\end_inset

dominazione
\begin_inset Quotes erd
\end_inset

 delle tuple, il quale è il cuore principale delle 
\emph on
query skyline.
\end_layout

\begin_layout Subsection
Ranking come prima classe
\end_layout

\begin_layout Standard
Una sfida interessante riguardante le 
\emph on
top-k queries 
\emph default
è come incorporare le tecniche basate su ranking in un 
\emph on
dbms
\emph default
 relazionale.
 Ciò è necessario per migliorare le performance per una 
\emph on
top-k query
\emph default
 del tutto generale.
 Il progetto RankDB ha fornito contributi fondamentali sulla soluzione a
 questo problema, proponendo un sistema prototipo, chiamato 
\emph on
RankSQL 
\emph default
[LCl+05], in cui il 
\emph on
ranking
\emph default
 è trattato come oggetto di 
\begin_inset Quotes eld
\end_inset

prima classe
\begin_inset Quotes erd
\end_inset

.
 Illustreremo i concetti base di RankSQL, in particolare:
\end_layout

\begin_layout Itemize
I requisiti di 
\emph on
splitting 
\emph default
e 
\emph on
interleaving
\end_layout

\begin_layout Itemize
Il concetto di 
\emph on
rank-relation 
\emph default
e il 
\emph on
ranking principle
\end_layout

\begin_layout Itemize
L'algebra di rank per 
\emph on
rank-relation
\end_layout

\begin_layout Subsubsection
Splitting e Interleaving
\end_layout

\begin_layout Standard
Consideriamo la seguente query SQL
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM RESTAURANTS AS R, HOTELS AS H
\end_layout

\begin_layout Plain Layout

WHERE R.Area=H.Area
\end_layout

\begin_layout Plain Layout

	AND H.stars=3
\end_layout

\begin_layout Plain Layout

	AND R.Cuisine='chinese'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un possibile piano di accesso P1 per la query è il seguente (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rankfirstexample"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rankfirstexample"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename rankfirstexample.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
P1 è un piano d'accesso decisamente migliore del seguente 
\begin_inset Quotes eld
\end_inset

monolitico
\begin_inset Quotes erd
\end_inset

 piano P2 in cui 
\begin_inset Formula $\times$
\end_inset

 denota il prodotto cartesiano (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rankfirstexample02"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rankfirstexample02"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename rankfirstexample02.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ecco come funziona dunque lo 
\emph on
splitting 
\emph default
e l'
\emph on
interleaving
\emph default
: possiamo traformare P2 in P1 semplicemente effettuando lo 
\emph on
splitting
\emph default
 dei predicato booleani in 
\emph on
join
\emph default
 e 
\emph on
selezioni
\emph default
 e farne successivamente l'
\emph on
interleaving
\emph default
.
 Lo stesso dovrebbe essere fatto per le funzioni di 
\emph on
ranking
\emph default
.
\end_layout

\begin_layout Subsubsection
Rank-Relations e Ranking Principle
\end_layout

\begin_layout Standard
Per rendere un 
\emph on
ottimizzatore 
\emph default
di query 
\begin_inset Quotes eld
\end_inset

conscio
\begin_inset Quotes erd
\end_inset

 del 
\emph on
ranking
\emph default
 risulta necessario introdurre il concetto di 
\emph on
rank-relation
\emph default
, cioè una relazione composta da tuple con punteggio.
 La definizione è strettamente legata al 
\emph on
ranking principle
\emph default
 il quale formalizza l'ormai ben noto fatto che la tupla più promettente
 dovrebbe essere processata per prima.
\end_layout

\begin_layout Standard
Diamo la definizione di 
\series bold
Rank-Relation
\series default
: data una relazione R e una 
\emph on
scoring function monotona 
\emph default

\begin_inset Formula $S(p1,p2,\ldots,pm)$
\end_inset

, la 
\emph on
rank-relation 
\begin_inset Formula $R_{P}$
\end_inset

, 
\emph default
con 
\begin_inset Formula $P\subseteq\{p1,p2,\ldots,pm\}$
\end_inset

, è una relazione R aumentata con un 
\emph on
ranking
\emph default
 così come segue:
\end_layout

\begin_layout Itemize
Il 
\emph on
punteggio 
\emph default
di una tupla 
\emph on
t 
\emph default
in 
\begin_inset Formula $R_{P}$
\end_inset

 è il punteggio massimo possibile, denotato con 
\begin_inset Formula $S_{P}^{+}(t)$
\end_inset

, in accordo alla funzione 
\emph on
S
\emph default
, dove 
\begin_inset Formula $S_{P}^{+}(t)$
\end_inset

 è calcolata sostituendo in S il valore di 
\begin_inset Formula $p_{j}(t)$
\end_inset

 se 
\begin_inset Formula $p_{j}\in P$
\end_inset

, 1 altrimenti (o il valore massimo possibile per 
\begin_inset Formula $p_{j}$
\end_inset

)
\end_layout

\begin_layout Itemize
Le tuple in 
\begin_inset Formula $R_{P}$
\end_inset

 sono 
\begin_inset Quotes eld
\end_inset

ordinate
\begin_inset Quotes erd
\end_inset

 per valori decrescenti di 
\begin_inset Formula $S_{P}^{+}(t)$
\end_inset

 (
\emph on
ranking principle
\emph default
)
\end_layout

\begin_layout Standard
Si noti che 
\begin_inset Formula $S_{P}^{+}(t)=S(t)$
\end_inset

 quando 
\begin_inset Formula $P=\{p1,p2,\ldots,pm\}$
\end_inset

, e si noti che 
\begin_inset Formula $R_{\textrm{Ø}}\equiv R$
\end_inset

.
\end_layout

\begin_layout Subsubsection
L'algebra RankSQL
\end_layout

\begin_layout Standard
L'algebra RankSQL estende la semantica di RA alle 
\emph on
rank-relations
\emph default
.
 Essa introduce un nuove operatore di ranking 
\begin_inset Formula $\mu$
\end_inset

, il quale applica alla 
\emph on
rank-relation 
\begin_inset Formula $R_{P}$
\end_inset

 
\emph default
una 
\begin_inset Quotes eld
\end_inset

preferenza
\begin_inset Quotes erd
\end_inset

 non ancora calcolata 
\emph on
p 
\emph default
(ovvero 
\begin_inset Formula $p\notin P$
\end_inset

), ottentendo la nuova 
\emph on
rank-relation 
\begin_inset Formula $R_{P\cup\{p\}}$
\end_inset

.
\end_layout

\begin_layout Standard
L'operatore 
\begin_inset Formula $\mu$
\end_inset

 è la base per lo 
\emph on
split
\emph default
 della 
\emph on
scoring function 
\begin_inset Formula $S(p1,p2,\ldots,pm)$
\end_inset

 
\emph default
poichè
\begin_inset Formula 
\[
R_{\{p1,p2,\ldots,pm\}}=\mu_{p1}(\mu_{p2}(\ldots(\mu_{pm}(R))))
\]

\end_inset

 ovvero il 
\emph on
ranking
\emph default
 finale può essere ottenuto applicando le 
\begin_inset Quotes eld
\end_inset

preferenze
\begin_inset Quotes erd
\end_inset

 una alla volta.
 Qualsiasi ordine di valutazione è ammissibile poichè 
\begin_inset Formula $\mu_{p1}(\mu_{p2}(R))=\mu_{p2}(\mu_{p1}(R))$
\end_inset

.
\end_layout

\begin_layout Standard
L'
\emph on
interleaving
\emph default
 con le selezioni e i join è ora possibile, ad esempio, per la selezione
 vale
\begin_inset Formula 
\[
\mu_{p}(\sigma_{c}(R_{P}))=\sigma_{c}(\mu_{p}(R_{P}))
\]

\end_inset

 A causa del 
\emph on
ranking principle
\emph default
, un operatore 
\begin_inset Formula $\mu_{p}$
\end_inset

 può ritornare una tupla 
\emph on
t 
\emph default
se e solo se è garantito che non vi sia alcuna tupla 
\emph on
t' 
\emph default
tale che 
\begin_inset Formula $S_{P\cup\{p\}}^{+}(t')>S_{P\cup\{p\}}^{+}(t)$
\end_inset

.
 Ciò può essere ottenuto appena 
\begin_inset Formula $\mu_{p}$
\end_inset

 calcola una tupla 
\emph on
t'' 
\emph default
tale che 
\begin_inset Formula $S_{P\cup\{p\}}^{+}(t)\geq S_{P}^{+}(t'')$
\end_inset

.
 La scansione per 
\emph on
indice
\emph default
 (e anche quella sequenziale) sono anch'essi trattati come operatori, poichè
 potrebbero essere usati al posto di 
\begin_inset Formula $\mu$
\end_inset

 per ordinare le tuple in accordo a una 
\begin_inset Quotes eld
\end_inset

prefenza
\begin_inset Quotes erd
\end_inset

 
\emph on
p
\emph default
.
\end_layout

\begin_layout Standard
Facciamo un esempio utilizzando la seguente query
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM A,B,C
\end_layout

\begin_layout Plain Layout

WHERE A.X=B.X AND B.Y=C.Y
\end_layout

\begin_layout Plain Layout

	AND A.W=1 AND B.Z=1
\end_layout

\begin_layout Plain Layout

ORDER BY A.p1+A.p2+B.p3+B.p4+C.p5 DESC
\end_layout

\begin_layout Plain Layout

STOP AFTER k
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un piano tradizionale (che non conosce il 
\emph on
ranking
\emph default
) per riuscire a calcolare la query sfrutterebbe semplicemente l'operatore
 
\emph on
Top-Sort
\emph default
 per evitare di ordinare tutte le tuple prodotte dal secondo (il più alto)
 join.
 Si veda la figura del piano d'accesso tradizione (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:plantraditional"

\end_inset

)
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:plantraditional"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename plantraditional.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Invece con operatori consci del ranking esistono diversi piani, tutti possibili.
 Si veda la figura (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:planalternatives"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:planalternatives"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename planalternatives.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Risultati sperimentali mostano che nessun piano di accesso è il migliore,
 ha bisogno di ottimizzazione.
 Il piano (anche se prendiamo quello ottimale) tradizionale non è quasi
 mai il migliore.
\end_layout

\begin_layout Standard
Come problema finale riguardante le 
\emph on
top-k queries
\emph default
, consideriamo il problema di dove l'operatore 
\emph on
Top
\emph default
 può essere posizionato in un piano di accesso.
 La posizione di default dell'operatore è in cima al piano di accesso: notiamo
 che questo è anche il caso dei piani di accesso precedentemente mostrati
 (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:planalternatives"

\end_inset

).
\end_layout

\begin_layout Standard
In alcuni casi è possibile scartare alcune tuple in eccesso anticipatamente,
 per esempio, nella seguente query
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT E.*, D.Dname
\end_layout

\begin_layout Plain Layout

FROM EMP AS E, DEPT AS D
\end_layout

\begin_layout Plain Layout

WHERE E.DNO=D.DNO
\end_layout

\begin_layout Plain Layout

ORDER BY E.Salary DESC
\end_layout

\begin_layout Plain Layout

STOP AFTER 100
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In questo caso possiamo effettuare il join dei top-100 impiegati, e il piano
 di accesso risultante è il seguente (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pianoaccesso01"

\end_inset

): questo perchè i top-100 impiegati risultano indipendenti dal dipartimento,
 ovvero il join su dipartimento serve solo per avere una informazione in
 più 
\begin_inset Quotes eld
\end_inset

D.Dname
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pianoaccesso01"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pianoaccesso01.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se anticipassimo la valutazione dell'operatore 
\emph on
Top
\emph default
, dobbiamo essere sicuri che nessuna delle sue tuple di output possa essere
 successivamente eliminata dagli altri operatori.
 Questo può essere verificato controllando i vincoli di integrità del database
 (come FK, PK, NOT NULL, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

) e verificando che i predicati della query che rimangono da valutare successivi
 all'operatore 
\emph on
Top
\emph default
 vengano eseguiti.
\end_layout

\begin_layout Standard
Ad esempio con la seguente query
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELET E.*, D.Dname
\end_layout

\begin_layout Plain Layout

FROM EMP AS E, DEPT AS D
\end_layout

\begin_layout Plain Layout

WHERE E.DNO=D.DNO
\end_layout

\begin_layout Plain Layout

ORDER BY E.Salary DESC
\end_layout

\begin_layout Plain Layout

STOP AFTER 100
\end_layout

\end_inset

l'operatore 
\emph on
Top
\emph default
 può essere eseguito successivamente al join purchè E.DNO sia dichiarato
 come chiave esterna e con valori non nulli.
\end_layout

\begin_layout Subsubsection
Sommario top-k join M:N
\end_layout

\begin_layout Standard
Per 
\emph on
top-k join 
\emph default
M:N 
\emph on
query 
\emph default
il caso più semplice da affrontare lo si ha quando gli accessi casuali sono
 possibili, in tal caso si applicano i principi dell'algoritmo TA.
 L'operatore 
\emph on
Rank-Join 
\emph default
è stato creato per scenari in cui gli accessi casuali non sono possibili.
 Il 
\emph on
Rank-Join 
\emph default
con il 
\emph on
corner bound 
\emph default
è 
\emph on
ottimo per le istanze
\emph default
 solo quando le condizioni di join non sono tenute in considerazione o quando
 ci sono solo due input, ognuno con un solo punteggio parziale.
\end_layout

\begin_layout Standard
L'algebra RankSQL rappresenta un contributo rilevante nel creare 
\emph on
dbms 
\emph default
interamente consci del 
\emph on
ranking
\emph default
: i suoi principi di design derivano dalla necessità di 
\emph on
splitting 
\emph default
e 
\emph on
interleaving
\emph default
 della valutazione della 
\emph on
scoring function
\emph default
.
 Il RankSQL gestisce 
\emph on
rank-relations
\emph default
, in cui le tuple sono ordinate in accordo al 
\emph on
ranking principle
\emph default
.
 Il più recente operatore di 
\emph on
rank
\emph default
 valuta solo una singola 
\begin_inset Quotes eld
\end_inset

preferenza
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_body
\end_document
